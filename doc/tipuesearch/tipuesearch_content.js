var tipuesearch = {"pages":[{"title":" Quantum transport simulator ","text":"Quantum transport simulator Developer Info Jiang Cao","tags":"home","loc":"index.html"},{"title":"type_matrix_complex – Quantum transport simulator ","text":"type, public :: type_matrix_complex Contents Variables m size Source Code type_matrix_complex Components Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: m (:,:) complex matrix integer, public :: size (2) matrix size Source Code type type_matrix_complex complex ( 8 ), allocatable :: m (:, :) !! complex matrix integer :: size ( 2 ) !! matrix size end type type_matrix_complex","tags":"","loc":"type/type_matrix_complex.html"},{"title":"DFTI_DESCRIPTOR – Quantum transport simulator ","text":"type, public :: DFTI_DESCRIPTOR Contents Source Code DFTI_DESCRIPTOR Source Code TYPE , PUBLIC :: DFTI_DESCRIPTOR PRIVATE INTEGER :: dontuse ! Structure of this type is not used in Fortran code ! the pointer to this type is used only END TYPE DFTI_DESCRIPTOR","tags":"","loc":"type/dfti_descriptor.html"},{"title":"type_matrix_complex – Quantum transport simulator ","text":"type, public :: type_matrix_complex Contents Variables m size Source Code type_matrix_complex Components Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: m (:,:) complex matrix integer, public :: size (2) matrix size Source Code type type_matrix_complex complex ( 8 ), allocatable :: m (:, :) !! complex matrix integer :: size ( 2 ) !! matrix size end type type_matrix_complex","tags":"","loc":"type/type_matrix_complex~2.html"},{"title":"negf_solve – Quantum transport simulator","text":"public  subroutine negf_solve(nx, nen, nk, emin, emax, Hii, H1i, Sii, temp, mu, comm_size, comm_rank, local_NE, first_local_energy, nbnd, nslab, Lx) Uses cuda_rgf_mod matrix_c Output omp_lib proc~~negf_solve~~UsesGraph proc~negf_solve negf_mod::negf_solve module~cuda_rgf_mod cuda_rgf_mod proc~negf_solve->module~cuda_rgf_mod module~matrix_c matrix_c proc~negf_solve->module~matrix_c module~output Output proc~negf_solve->module~output omp_lib omp_lib proc~negf_solve->omp_lib module~cuda_rgf_mod->omp_lib cublas cublas module~cuda_rgf_mod->cublas cusolverdn cusolverdn module~cuda_rgf_mod->cusolverdn module~matrix_c->cublas module~output->module~matrix_c Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. $omp do $omp end do Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx number of slabs integer, intent(in) :: nen number of energy points integer, intent(in) :: nk number of k points real(kind=dp) :: emin min and max energy range real(kind=dp) :: emax min and max energy range type( type_matrix_complex ), intent(in), dimension(nx, nk) :: Hii type( type_matrix_complex ), intent(in), dimension(nx + 1, nk) :: H1i type( type_matrix_complex ), intent(in), dimension(nx, nk) :: Sii real(kind=dp), intent(in), dimension(2) :: temp temperatures real(kind=dp), intent(in), dimension(2) :: mu chemical potentials integer(kind=4), intent(in) :: comm_size integer(kind=4), intent(in) :: comm_rank integer(kind=4), intent(in) :: local_NE integer(kind=4), intent(in) :: first_local_energy integer, intent(in) :: nbnd number of bands / orbitals per cell integer, intent(in) :: nslab number of cells in a slab real(kind=dp), intent(in) :: Lx Lx Calls proc~~negf_solve~~CallsGraph proc~negf_solve negf_mod::negf_solve proc~cuda_rgf_constblocksize cuda_rgf_mod::cuda_rgf_constblocksize proc~negf_solve->proc~cuda_rgf_constblocksize proc~cuda_rgf_finish cuda_rgf_mod::cuda_rgf_finish proc~negf_solve->proc~cuda_rgf_finish proc~cuda_rgf_init cuda_rgf_mod::cuda_rgf_init proc~negf_solve->proc~cuda_rgf_init proc~write_spectrum_summed_over_k Output::write_spectrum_summed_over_k proc~negf_solve->proc~write_spectrum_summed_over_k omp_get_wtime omp_get_wtime proc~cuda_rgf_constblocksize->omp_get_wtime zaxpy zaxpy proc~cuda_rgf_constblocksize->zaxpy zcopy zcopy proc~cuda_rgf_constblocksize->zcopy zgemm zgemm proc~cuda_rgf_constblocksize->zgemm zgetrf zgetrf proc~cuda_rgf_constblocksize->zgetrf zgetrs zgetrs proc~cuda_rgf_constblocksize->zgetrs zscal zscal proc~cuda_rgf_constblocksize->zscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~negf_solve~~CalledByGraph proc~negf_solve negf_mod::negf_solve program~main main program~main->proc~negf_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code negf_solve Source Code subroutine negf_solve ( nx , nen , nk , emin , emax , Hii , H1i , Sii , temp , mu , & comm_size , comm_rank , local_NE , first_local_energy , nbnd , nslab , Lx ) use matrix_c , only : type_matrix_complex , malloc , free , sizeof use cuda_rgf_mod , only : cuda_rgf_variableblock_forward , cuda_rgf_constblocksize , cuda_rgf_init , cuda_rgf_finish ! use rgf_mod, only: rgf_variableblock_forward use Output , only : write_spectrum_summed_over_k use omp_lib type ( type_matrix_complex ), intent ( in ), dimension ( nx , nk ) :: Hii , Sii type ( type_matrix_complex ), intent ( in ), dimension ( nx + 1 , nk ) :: H1i integer ( kind = 4 ), intent ( in ) :: comm_size , comm_rank , local_NE , first_local_energy integer , intent ( in ) :: nx !! number of slabs integer , intent ( in ) :: nen !! number of energy points integer , intent ( in ) :: nk !! number of k points integer , intent ( in ) :: nbnd !! number of bands / orbitals per cell integer , intent ( in ) :: nslab !! number of cells in a slab real ( dp ), intent ( in ), dimension ( 2 ) :: temp !! temperatures real ( dp ), intent ( in ), dimension ( 2 ) :: mu !! chemical potentials real ( dp ), intent ( in ) :: Lx !! Lx ! ---- real ( dp ) :: emin , emax !! min and max energy range integer :: nm ( 2 , nx ), ik , ie , iter , NB , NS , i integer ( kind = 4 ) :: ierr real ( dp ) :: en ( nen ), dE , local_energies ( local_NE ) real ( dp ), dimension (:, :), allocatable :: mul , mur , templ , tempr type ( type_matrix_complex ), dimension ( nx , local_NE , nk ) :: sigma_lesser_ph , sigma_r_ph , G_r , G_lesser , G_greater type ( type_matrix_complex ), dimension (:), allocatable :: Jdens , Gl , Gln real ( dp ), dimension ( nen , nk ) :: tr , tre character ( len = 20 ) :: filename character ( len = 8 ) :: fmt character ( len = 4 ) :: rank_str logical :: append ! !    include \"mpif.h\" fmt = '(I4.4)' write ( rank_str , fmt ) comm_rank append = ( comm_rank /= 0 ) nm = sizeof ( Hii (:, 1 )) allocate ( mul ( nm ( 1 , 1 ), nm ( 1 , 1 ))) allocate ( templ ( nm ( 1 , 1 ), nm ( 1 , 1 ))) allocate ( mur ( nm ( 1 , nx ), nm ( 1 , nx ))) allocate ( tempr ( nm ( 1 , nx ), nm ( 1 , nx ))) mul = mu ( 1 ) mur = mu ( 2 ) templ = temp ( 1 ) tempr = temp ( 2 ) do ik = 1 , nk do ie = 1 , local_NE call malloc ( sigma_lesser_ph (:, ie , ik ), nx , nm ) call malloc ( sigma_r_ph (:, ie , ik ), nx , nm ) call malloc ( G_r (:, ie , ik ), nx , nm ) call malloc ( G_lesser (:, ie , ik ), nx , nm ) call malloc ( G_greater (:, ie , ik ), nx , nm ) end do end do ! if ( comm_rank == 0 ) then print * , 'allocate memory DONE' end if ! dE = ( emax - emin ) / dble ( nen - 1 ) forall ( ie = 1 : nen ) En ( ie ) = emin + dble ( ie - 1 ) * dE ! global energy vector do ie = 1 , local_NE local_energies ( ie ) = En ( ie + first_local_energy - 1 ) ! local energy vector of rank-i end do ! iter = 0 ! !$omp parallel default(shared) private(ie,ik,Jdens,Gl,Gln) allocate ( Jdens ( nx ), Gl ( nx ), Gln ( nx )) call malloc ( Jdens , nx , nm ) ! call malloc(Gl, nx, nm) ! call malloc(Gln, nx, nm) call cuda_rgf_init ( nm ( 1 , 1 )) !!$omp do do ie = 1 , local_NE do ik = 1 , nk !  call rgf_variableblock_forward(nx, local_energies(ie), mul, mur, TEMPl, TEMPr, & !      Hii(:, ik), H1i(:, ik), Sii(:, ik), sigma_lesser_ph(:, ie, ik), & !      sigma_r_ph(:, ie, ik), G_r(:, ie, ik), G_lesser(:, ie, ik), G_greater(:, ie, ik), & !      Jdens, Gl, Gln, tr(ie, ik), tre(ie, ik)) call cuda_rgf_constblocksize ( nm ( 1 , 1 ), nx , local_energies ( ie ), mul , mur , TEMPl , TEMPr , & Hii (:, ik ), H1i (:, ik ), Sii (:, ik ), sigma_lesser_ph (:, ie , ik ), & sigma_r_ph (:, ie , ik ), G_r (:, ie , ik ), G_lesser (:, ie , ik ), G_greater (:, ie , ik ), & Jdens , tr ( ie , ik ), tre ( ie , ik )) end do end do !!$omp end do call cuda_rgf_finish () call free ( Jdens ) ! call free(Gl) ! call free(Gln) deallocate ( Jdens ) ! deallocate(Gl,Gln) !$omp end parallel ! NB = nbnd NS = nslab do i = 0 , comm_size - 1 if ( i == comm_rank ) then filename = 'ldos' call write_spectrum_summed_over_k ( filename , iter , G_r , local_NE , local_energies , & nk , nx , NB , NS , Lx , ( / 1.0d0 , - 2.0d0 / ), append ) filename = 'ndos' call write_spectrum_summed_over_k ( filename , iter , G_lesser , local_NE , local_energies , & nk , nx , NB , NS , Lx , ( / 1.0d0 , 1.0d0 / ), append ) filename = 'pdos' call write_spectrum_summed_over_k ( filename , iter , G_greater , local_NE , local_energies , & nk , nx , NB , NS , Lx , ( / 1.0d0 , - 1.0d0 / ), append ) end if !            call MPI_Barrier(MPI_COMM_WORLD, ierr) end do ! if ( comm_rank == 0 ) then print * , 'free memory' end if deallocate ( mul , mur , tempr , templ ) ! call free ( sigma_lesser_ph ) call free ( sigma_r_ph ) call free ( G_r ) call free ( G_lesser ) call free ( G_greater ) ! end subroutine negf_solve","tags":"","loc":"proc/negf_solve.html"},{"title":"cross – Quantum transport simulator","text":"public  function cross(a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), DIMENSION(3) :: a real(kind=8), intent(in), DIMENSION(3) :: b Return Value real(kind=8), DIMENSION(3) Contents Source Code cross Source Code FUNCTION cross ( a , b ) REAL ( 8 ), DIMENSION ( 3 ) :: cross REAL ( 8 ), DIMENSION ( 3 ), INTENT ( IN ) :: a , b cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION cross","tags":"","loc":"proc/cross.html"},{"title":"eig – Quantum transport simulator","text":"public  function eig(NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) Calls proc~~eig~~CallsGraph proc~eig linalg::eig zheev zheev proc~eig->zheev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code eig Source Code FUNCTION eig ( NN , A ) INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A ! ----- REAL ( 8 ) :: eig ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , liwork , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) ! CALL zheev ( 'N' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) ! deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eig (:) = W (:) END FUNCTION eig","tags":"","loc":"proc/eig.html"},{"title":"eigv – Quantum transport simulator","text":"public  function eigv(NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) Calls proc~~eigv~~CallsGraph proc~eigv linalg::eigv zheev zheev proc~eigv->zheev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code eigv Source Code FUNCTION eigv ( NN , A ) INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A ! ----- REAL ( 8 ) :: eigv ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , liwork , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) ! CALL zheev ( 'V' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) ! deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eigv (:) = W (:) END FUNCTION eigv","tags":"","loc":"proc/eigv.html"},{"title":"invert – Quantum transport simulator","text":"public  subroutine invert(A, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(nn, nn) :: A integer :: nn Calls proc~~invert~2~~CallsGraph proc~invert~2 linalg::invert zgetrf zgetrf proc~invert~2->zgetrf zgetri zgetri proc~invert~2->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~invert~2~~CalledByGraph proc~invert~2 linalg::invert proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->proc~invert~2 proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward proc~rgf_variableblock_forward->proc~invert~2 proc~sancho cuda_rgf_mod::sancho proc~sancho->proc~invert~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code invert Source Code subroutine invert ( A , nn ) integer :: info , nn integer , dimension (:), allocatable :: ipiv complex ( 8 ), dimension ( nn , nn ), intent ( inout ) :: A complex ( 8 ), dimension (:), allocatable :: work allocate ( work ( nn * nn )) allocate ( ipiv ( nn )) call zgetrf ( nn , nn , A , nn , ipiv , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgetrf failed, info=' , info A = czero else call zgetri ( nn , A , nn , ipiv , work , nn * nn , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgetri failed, info=' , info A = czero end if end if deallocate ( work ) deallocate ( ipiv ) end subroutine invert","tags":"","loc":"proc/invert~2.html"},{"title":"invert_banded – Quantum transport simulator","text":"public  subroutine invert_banded(A, nn, nb) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout) :: A (3*nb+1,nn) integer, intent(in) :: nn integer, intent(in) :: nb Calls proc~~invert_banded~~CallsGraph proc~invert_banded linalg::invert_banded zgbtrf zgbtrf proc~invert_banded->zgbtrf zgbtrs zgbtrs proc~invert_banded->zgbtrs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code invert_banded Source Code subroutine invert_banded ( A , nn , nb ) integer , intent ( in ) :: nn , nb complex ( 8 ), intent ( inout ) :: A ( 3 * nb + 1 , nn ) complex ( 8 ), allocatable :: work (:), B (:, :), X (:, :) integer , allocatable :: ipiv (:) integer :: info , lda , lwork , ldb , i , nrhs allocate ( ipiv ( nn )) allocate ( work ( nn * nn )) lda = 3 * nb + 1 call zgbtrf ( nn , nn , nb , nb , A , lda , ipiv , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgbtrf failed, info=' , info call abort () end if ldb = 1 allocate ( B ( ldb , nn )) allocate ( X ( lda , nn )) nrhs = ldb do i = 1 , nn B = 0.0d0 B ( 1 , i ) = 1.0d0 call zgbtrs ( 'N' , nn , nb , nb , nrhs , A , lda , ipiv , B , ldb , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgbtrs failed, info=' , info call abort () end if X ( 1 : nb * 2 + 1 , i ) = B ( 1 , i - nb : i + nb ) end do A = X deallocate ( B , work , ipiv , X ) end subroutine invert_banded","tags":"","loc":"proc/invert_banded.html"},{"title":"cuda_rgf_init – Quantum transport simulator","text":"public  subroutine cuda_rgf_init(nm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nm Called by proc~~cuda_rgf_init~~CalledByGraph proc~cuda_rgf_init cuda_rgf_mod::cuda_rgf_init proc~negf_solve negf_mod::negf_solve proc~negf_solve->proc~cuda_rgf_init program~main main program~main->proc~negf_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code cuda_rgf_init Source Code subroutine cuda_rgf_init ( nm ) integer , intent ( in ) :: nm Allocate ( H_BB ( nm , nm )) Allocate ( H_SS ( nm , nm )) Allocate ( H_01 ( nm , nm )) Allocate ( H_10 ( nm , nm )) Allocate ( Id ( nm , nm )) Allocate ( work ( nm , nm )) Allocate ( ipiv ( nm )) Allocate ( H00 ( nm , nm ), H10 ( nm , nm ), A ( nm , nm ), B ( nm , nm ), C ( nm , nm ), D ( nm , nm ), S00 ( nm , nm ), G00 ( nm , nm ), GBB ( nm , nm ), GN0 ( nm , nm ), Gn ( nm , nm ), Gp ( nm , nm )) Allocate ( sig ( nm , nm ), sigmal ( nm , nm ), sigmar ( nm , nm ), sig2 ( nm , nm ), glii ( nm , nm ), glpii ( nm , nm ), glnii ( nm , nm ), cur ( nm , nm )) !$omp target enter data map(to:H00,H10,G00,A,sigmal,S00,sig,sig2,B,C,D,Gn,Gp,ipiv,work,sigmar,glii,glnii,glpii,cur,GN0,H_BB,H_SS,H_01,H_10,Id,GBB) end subroutine cuda_rgf_init","tags":"","loc":"proc/cuda_rgf_init.html"},{"title":"cuda_rgf_finish – Quantum transport simulator","text":"public  subroutine cuda_rgf_finish() Arguments None Called by proc~~cuda_rgf_finish~~CalledByGraph proc~cuda_rgf_finish cuda_rgf_mod::cuda_rgf_finish proc~negf_solve negf_mod::negf_solve proc~negf_solve->proc~cuda_rgf_finish program~main main program~main->proc~negf_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code cuda_rgf_finish Source Code subroutine cuda_rgf_finish () !$omp target exit data map(delete:H00,H10,G00,A,sigmal,S00,sig,sig2,B,C,D,Gn,Gp,ipiv,work,sigmar,glii,glnii,glpii,cur,GN0,H_BB,H_SS,H_01,H_10,Id,GBB) deallocate ( H_BB , H_SS , H_01 , H_10 , Id , work , ipiv ) deallocate ( H00 , H10 , A , B , C , D , S00 , G00 , GBB , GN0 , Gn , Gp , sig , sigmal , sigmar , sig2 , glii , glpii , glnii , cur ) end subroutine cuda_rgf_finish","tags":"","loc":"proc/cuda_rgf_finish.html"},{"title":"cuda_rgf_constblocksize – Quantum transport simulator","text":"public  subroutine cuda_rgf_constblocksize(nm, nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, tr, tre) !$omp target exit data map(delete:H10,G00,A,sigmal,S00,sig2,B)\n! G<_i+1,i ! G<_i,i+1\n! G_i,i+1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nm lenght of the device integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre Calls proc~~cuda_rgf_constblocksize~~CallsGraph proc~cuda_rgf_constblocksize cuda_rgf_mod::cuda_rgf_constblocksize omp_get_wtime omp_get_wtime proc~cuda_rgf_constblocksize->omp_get_wtime zaxpy zaxpy proc~cuda_rgf_constblocksize->zaxpy zcopy zcopy proc~cuda_rgf_constblocksize->zcopy zgemm zgemm proc~cuda_rgf_constblocksize->zgemm zgetrf zgetrf proc~cuda_rgf_constblocksize->zgetrf zgetrs zgetrs proc~cuda_rgf_constblocksize->zgetrs zscal zscal proc~cuda_rgf_constblocksize->zscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cuda_rgf_constblocksize~~CalledByGraph proc~cuda_rgf_constblocksize cuda_rgf_mod::cuda_rgf_constblocksize proc~negf_solve negf_mod::negf_solve proc~negf_solve->proc~cuda_rgf_constblocksize program~main main program~main->proc~negf_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code cuda_rgf_constblocksize Source Code subroutine cuda_rgf_constblocksize ( nm , nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , tr , tre ) type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx , nm !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ) real ( dp ), intent ( out ) :: tr , tre ! ---- COMPLEX ( dp ) :: z integer :: i , j , k , l , info1 , info2 , ii real ( dp ) :: tim , start , finish , start_0 COMPLEX ( dp ), allocatable :: Gl (:,:,:), Gln (:,:,:), Glp (:,:,:) ! left-connected green function complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) ! z = dcmplx ( En , 0.0d-6 ) Id = dcmplx ( 0.0d0 , 0.0d0 ) forall ( ii = 1 : nm ) Id ( ii , ii ) = 1.0d0 ! allocate ( Gl ( nm , nm , nx )) allocate ( Gln ( nm , nm , nx )) allocate ( Glp ( nm , nm , nx )) ! ! Gln = 0.0d0 Glp = 0.0d0 Gl = 0.0d0 do l = 1 , nx G_r ( l )% m = 0.0d0 G_lesser ( l )% m = 0.0d0 G_greater ( l )% m = 0.0d0 Jdens ( l )% m = 0.0d0 enddo ! start = omp_get_wtime () start_0 = start ! ! self energy on the left contact S00 (:,:) = Sii ( 1 )% m sig (:,:) = sigma_r_ph ( 1 )% m !$omp target update to(sig,S00) !$omp target data use_device_ptr(sig,S00,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) H00 (:,:) = Hii ( 1 )% m + B (:,:) H10 (:,:) = H1i ( 1 )% m ! call sancho ( nm , En , S00 , H00 , transpose ( conjg ( H10 )), G00 , GBB ) ! sig2 (:,:) = sigma_lesser_ph ( 1 )% m ! !$omp target update to(H10,G00,sigmal,S00,sig2) !$omp target data use_device_ptr(H10,G00,A,sigmal,S00,sig2,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , G00 , nm , beta , A , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , sigmal , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update from(B,sigmal) !!!$omp target exit data map(delete:H10,G00,A,sigmal,S00,sig2,B) sig (:,:) =- ( sigmal (:,:) - transpose ( conjg ( sigmal (:,:)))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) + B (:,:) A = z * S00 - H00 - sigmal ! ! call invert(A,nm) !$omp target update to(A, Id) !$omp target data use_device_ptr(A,ipiv,work,Id) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrf ( nm , nm , A , nm , ipiv , info1 ) call zgetrs ( 'n' , nm , nm , A , nm , ipiv , work , nm , info2 ) call zcopy ( nm * nm , work , 1 , A , 1 ) !$omp end target data !$omp target update from(A) Gl (:,:, 1 ) = A (:,:) ! !$omp target update to(sig,A) !$omp target data use_device_ptr(A,sig,B,C) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) !$omp end target data !$omp target update from(C) Gln (:,:, 1 ) = C (:,:) ! finish = omp_get_wtime () print * , \"---- left contact took seconds\" , finish - start start = finish ! Do l = 2 , nx - 1 H00 (:,:) = Hii ( l )% m + sigma_r_ph ( l )% m H10 (:,:) = H1i ( l )% m G00 (:,:) = Gl (:,:, l - 1 ) sig = Gln (:,:, l - 1 ) sig2 = sigma_lesser_ph ( l )% m S00 (:,:) = Sii ( l )% m ! !$omp target update to(H00,H10,G00,S00,sig,sig2) !$omp target data use_device_ptr(H10,G00,B,C,A,H00,S00,Gn,sig,sig2,work,ipiv,Id) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , G00 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) call zcopy ( nm * nm , C , 1 , A , 1 ) call zaxpy ( nm * nm , alpha , H00 , 1 , A , 1 ) call zaxpy ( nm * nm , - z , S00 , 1 , A , 1 ) call zscal ( nm * nm , - alpha , A , 1 ) ! A=z*S00-H00-C ! ! call invert(A,nm) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrf ( nm , nm , A , nm , ipiv , info1 ) call zgetrs ( 'n' , nm , nm , A , nm , ipiv , work , nm , info2 ) call zcopy ( nm * nm , work , 1 , A , 1 ) call zcopy ( nm * nm , A , 1 , G00 , 1 ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) ! ! C(:,:)=C(:,:)+B(:,:) call zaxpy ( nm * nm , alpha , B , 1 , C , 1 ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , C , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , A , nm , beta , Gn , nm ) !$omp end target data !$omp target update from(Gn,G00) Gln (:,:, l ) = Gn (:,:) Gl (:,:, l ) = G00 (:,:) if ( info1 . ne . 0 ) then print * , 'SEVERE warning: zgetrf failed, info=' , info1 call abort () end if if ( info2 . ne . 0 ) then print * , 'SEVERE warning: zgetri failed, info=' , info2 call abort () end if enddo finish = omp_get_wtime () print * , \"---- first pass took seconds\" , finish - start start = finish ! self energy on the right contact S00 (:,:) = Sii ( nx )% m sig2 (:,:) = sigma_r_ph ( nx )% m !$omp target update to(S00,sig2) !$omp target data use_device_ptr(S00,sig2,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update to(B) H00 (:,:) = Hii ( nx )% m + B (:,:) H10 (:,:) = H1i ( nx )% m ! call sancho ( NM , En , S00 , H00 , H10 , G00 , GBB ) ! Glii = Gl (:,:, nx - 1 ) !$omp target update to(H10,G00,Glii) !$omp target data use_device_ptr(H10,G00,A,sigmar,G00,B,C,Glii) call zgemm ( 'c' , 'n' , nm , nm , nm , alpha , H10 , nm , G00 , nm , beta , A , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , sigmar , nm ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , Glii , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) !$omp end target data !$omp target update from(C,sigmar) ! G00 = z * S00 - H00 - sigmar - C ! ! call invert(G00,nm) !$omp target update to(G00, work) !$omp target data use_device_ptr(G00,ipiv,work,Id) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrf ( nm , nm , G00 , nm , ipiv , info1 ) call zgetrs ( 'n' , nm , nm , G00 , nm , ipiv , work , nm , info2 ) call zcopy ( nm * nm , work , 1 , G00 , 1 ) !$omp end target data !$omp target update from(G00) ! G_r ( nx )% m = G00 (:,:) !dcmplx(0.0d0,1.0d0)*(G00(:,:)-transpose(conjg(G00(:,:)))) sig = Gln (:,:, nx - 1 ) sig2 = sigma_lesser_ph ( nx )% m !$omp target update to(sig,sig2,S00) !$omp target data use_device_ptr(H10,sig,B,C,sig2,S00) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) ! C=H10 Gl< H01 call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) ! B=Sig< S00 sig (:,:) =- ( sigmar (:,:) - transpose ( conjg ( sigmar (:,:)))) * ferm (( En - mur ) / ( BOLTZ * TEMPl )) + C (:,:) + B (:,:) ! !$omp target update to(G00,sig) !$omp target data use_device_ptr(G00,sig,Gn,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , G00 , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , G00 , nm , beta , Gn , nm ) !$omp end target data !$omp target update from(Gn) ! G<00 = G00 sig< G00' G_lesser ( nx )% m = Gn (:,:) Gp (:,:) = Gn (:,:) + ( G00 (:,:) - transpose ( conjg ( G00 (:,:)))) G_greater ( nx )% m = Gp (:,:) A =- ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPl )) ! !$omp target update to(A,Gp) !$omp target data use_device_ptr(A,Gp,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gp , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) ! A =- ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPl )) - 1.0d0 ) ! !$omp target update to(A,Gn) !$omp target data use_device_ptr(A,Gn,C) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gn , nm , beta , C , nm ) !$omp end target data !$omp target update from(C) tim = 0.0d0 do i = 1 , nm do j = i , i !1,nm tim = tim - dble ( B ( i , j ) - C ( i , j )) enddo enddo tr = tim ! transmission !------------------------- finish = omp_get_wtime () print * , \"---- right contact took seconds\" , finish - start start = finish do l = nx - 1 , 1 , - 1 H10 (:,:) = H1i ( l )% m A = Gn Glii = Gl (:,:, l ) Glpii = Glp (:,:, l ) Glnii = Gln (:,:, l ) !$omp target update to(H10,A,Glii,Glpii,Glnii) !$omp target data use_device_ptr(H10,G00,B,C,A,D,H00,S00,Glii,Glpii,Glnii,cur,Gn,Gp,GN0) ! call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , H10 , nm , Glii , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , B , nm , beta , C , nm ) call zcopy ( nm * nm , Glnii , 1 , A , 1 ) ! A=Gln(:,:,l) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , A , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , G00 , nm , B , nm , beta , A , nm ) call zcopy ( nm * nm , C , 1 , B , 1 ) call zaxpy ( nm * nm , alpha , A , 1 , B , 1 ) ! B=C+A call zgemm ( 'c' , 'n' , nm , nm , nm , alpha , H10 , nm , B , nm , beta , A , nm ) !!! G<_i+1,i call zcopy ( nm * nm , A , 1 , cur , 1 ) ! cur=dble(A(:,:)) !------------------------- call zcopy ( nm * nm , Gn , 1 , A , 1 ) ! A=Gn call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) ! g H10 G< call zcopy ( nm * nm , Glnii , 1 , A , 1 ) ! A=Glnii call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , G00 , nm , beta , A , nm ) ! g< H10 G' call zcopy ( nm * nm , C , 1 , B , 1 ) call zaxpy ( nm * nm , alpha , A , 1 , B , 1 ) ! B=C+A call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , B , nm , beta , A , nm ) !!! G<_i,i+1 call zaxpy ( nm * nm , - alpha , A , 1 , cur , 1 ) ! cur=cur-dble(A(:,:)) !------------------------- call zcopy ( nm * nm , Glii , 1 , D , 1 ) ! D(:,:)= Glii call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , G00 , nm , beta , GN0 , nm ) !!! G_i,i+1 call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , GN0 , nm , H10 , nm , beta , A , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Glii , nm , beta , C , nm ) call zcopy ( nm * nm , Glii , 1 , G00 , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , G00 , 1 ) ! G00(:,:)=Glii+C(:,:)                                       !!! G_i,i !------------------------- ! A(:,:)=Gn(:,:) call zcopy ( nm * nm , Gn , 1 , A , 1 ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , C , nm , H10 , nm , beta , A , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , Glii , nm , beta , C , nm ) call zcopy ( nm * nm , Glnii , 1 , Gn , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , Gn , 1 ) ! Gn(:,:)= Glnii + C(:,:) call zcopy ( nm * nm , Glnii , 1 , A , 1 ) ! A(:,:)=Glnii call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , GN0 , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , Gn , 1 ) ! Gn(:,:)= Gn(:,:)+C(:,:)! call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , GN0 , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , Gn , 1 ) ! Gn(:,:)= Gn(:,:)+C(:,:)!     \t\t\t\t\t !!! G<_i,i !------------------------- ! A(:,:)=Gp(:,:) call zcopy ( nm * nm , Gp , 1 , A , 1 ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , C , nm , H10 , nm , beta , A , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , Glii , nm , beta , C , nm ) ! call zcopy ( nm * nm , Glpii , 1 , Gp , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , Gp , 1 ) ! Gp(:,:)= Glpii + C(:,:) ! A(:,:)=Glp(:,:,l) call zcopy ( nm * nm , Glpii , 1 , A , 1 ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , GN0 , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) ! call zaxpy ( nm * nm , alpha , C , 1 , Gp , 1 ) ! Gp(:,:)= Gp(:,:)+C(:,:)! call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , GN0 , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , Gp , 1 ) ! Gp(:,:)= Gp(:,:)+C(:,:)!     \t\t\t\t\t !!! G>_i,i !------------------------- !$omp end target data !$omp target update from(Gn,Gp,G00,cur) G_lesser ( l )% m = Gn (:,:) G_greater ( l )% m = Gp (:,:) G_r ( l )% m = G00 (:,:) Jdens ( l )% m = cur enddo ! finish = omp_get_wtime () print * , \"---- second pass took seconds\" , finish - start start = finish ! Gp (:,:) = Gn (:,:) + ( G00 (:,:) - transpose ( conjg ( G00 (:,:)))) A =- ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPr )) ! !$omp target update to(A,Gp) !$omp target data use_device_ptr(A,Gp,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gp , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) ! A =- ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPr )) - 1.0d0 ) !$omp target update to(A,Gn) !$omp target data use_device_ptr(A,Gn,C) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gn , nm , beta , C , nm ) !$omp end target data !$omp target update from(C) ! tim = 0.0d0 do i = 1 , nm tim = tim + dble ( B ( i , i ) - C ( i , i )) enddo tre = tim ! deallocate ( Gl ) deallocate ( Gln ) deallocate ( Glp ) print * , \"RGF took seconds\" , finish - start_0 end subroutine cuda_rgf_constblocksize","tags":"","loc":"proc/cuda_rgf_constblocksize.html"},{"title":"cuda_rgf_variableblock_forward – Quantum transport simulator","text":"public  subroutine cuda_rgf_variableblock_forward(nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) !$omp critical\n        open (unit=10, file='sancho_g00.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(G00))\n        close (10)\n        open (unit=10, file='sancho_gbb.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(Gbb))\n        close (10)\n!$omp end critical !$omp critical\n        open (unit=10, file='sancho_g00.dat', position='append')\n        write (10, ) En, 1, -aimag(trace(G00))\n        close (10)\n        open (unit=10, file='sancho_gbb.dat', position='append')\n        write (10, ) En, 1, -aimag(trace(Gbb))\n        close (10)\n!$omp end critical Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) type( type_matrix_complex ), intent(inout) :: Gl (nx) type( type_matrix_complex ), intent(inout) :: Gln (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre Contents Source Code cuda_rgf_variableblock_forward Source Code subroutine cuda_rgf_variableblock_forward ( nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ), Gl ( nx ), Gln ( nx ) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: M , ii , jj complex ( dp ) :: z real ( dp ) :: tim complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) !!!$omp declare target device_type(any) z = dcmplx ( En , 0.0d0 ) ! ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmal ( M , M )) allocate ( sig ( M , M )) ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B H10 = H1i ( ii )% m call sancho ( M , En , Sii ( ii )% m , H00 , transpose ( conjg ( H10 )), G00 , GBB ) !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical !! \\Sigma&#94;R = H(i,i+1) * G00 * H(i+1,i) !! Gl(i) = [E*S(i,i) - H00 - \\Sigma_R]&#94;{-1} call triMUL_c ( H10 , G00 , H10 , sigmal , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmal call invert ( B , M ) Gl ( ii )% m = B ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + (-(\\Sigma&#94;R - \\Sigma_R&#94;\\dagger)*ferm(..))] * Gl(i)&#94;\\dagger call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig , H10 ) ! allocate ( A ( M , M )) ! inside device l -> r do ii = 2 , nx - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) !! Gl(i) = [E*S(i,i) - H00 - H(i,i-1) * Gl(i-1) * H(i-1,i)]&#94;{-1} call triMUL_c ( H1i ( ii )% m , Gl ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B call invert ( A , M ) Gl ( ii )% m = A ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)&#94;\\dagger call triMUL_c ( H1i ( ii )% m , Gln ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmar ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = H1i ( nx + 1 )% m ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H10 , G00 , H10 , sigmar , 'c' , 'n' , 'n' ) !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical call triMUL_c ( H1i ( nx )% m , Gl ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B - sigmar ! call invert ( A , M ) G_r ( ii )% m = A Gl ( ii )% m = A ! !! \\Sigma&#94;< = \\Sigma_11&#94;< + \\Sigma_{ph}&#94;< + \\Sigma_s&#94;< call triMUL_c ( H1i ( nx )% m , Gln ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( nx )% m , Sii ( nx )% m , 'n' , 'n' , A ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !! G&#94;< = G * \\Sigma&#94;< * G&#94;\\dagger call triMUL_c ( G_r ( ii )% m , sig , G_r ( ii )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( ii )% m = B G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) ! A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) ! Jdens ( ii )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( ii )% m ( jj , jj )) end do tr = tim ! transmission deallocate ( sigmar , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! inside device r -> l do ii = nx - 1 , 1 , - 1 M = size ( Hii ( ii )% m , 1 ) !! A = G&#94;<(i+1) * H(i+1,i) * Gl(i)&#94;\\dagger + G(i+1) * H(i+1,i) * Gln(i) call triMUL_c ( G_lesser ( ii + 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii + 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !! B = H(i,i+1) * A !! Jdens(i) = -2 * B call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * B (:, :) ! !! GN0 = Gl(i) * H(i,i+1) * G(i+1) !! G(i) = Gl(i) + GN0 * H(i+1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii + 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !! G&#94;<(i) = Gln(i) + Gl(i) * H(i,i+1) * G&#94;<(i+1) * H(i+1,i) *Gl(i)&#94;\\dagger call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii + 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + GN0 * H(i+1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + Gln(i) * H(i,i+1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;>(i) = G&#94;<(i) + [G(i) - G(i)&#94;\\dagger] G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ii = 1 ! on the left contact A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tre = tim deallocate ( B , A , C , GN0 , sigmal ) end subroutine cuda_rgf_variableblock_forward","tags":"","loc":"proc/cuda_rgf_variableblock_forward.html"},{"title":"DftiCreateDescriptor – Quantum transport simulator","text":"public interface DftiCreateDescriptor Called by interface~~dfticreatedescriptor~~CalledByGraph interface~dfticreatedescriptor MKL_DFTI::DftiCreateDescriptor proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->interface~dfticreatedescriptor proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Functions dfti_create_descriptor_1d dfti_create_descriptor_highd dfti_create_descriptor_s_1d dfti_create_descriptor_s_md dfti_create_descriptor_d_1d dfti_create_descriptor_d_md Functions public  function dfti_create_descriptor_1d(desc, precision, domain, dim, length) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: precision integer, intent(in) :: domain integer, intent(in) :: dim integer, intent(in) :: length Return Value integer public  function dfti_create_descriptor_highd(desc, precision, domain, dim, length) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: precision integer, intent(in) :: domain integer, intent(in) :: dim integer, intent(in), DIMENSION(*) :: length Return Value integer public  function dfti_create_descriptor_s_1d(desc, s, dom, one, dim) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in) :: s integer, intent(in) :: dom integer, intent(in) :: one integer, intent(in) :: dim Return Value integer public  function dfti_create_descriptor_s_md(desc, s, dom, many, dims) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in) :: s integer, intent(in) :: dom integer, intent(in) :: many integer, intent(in), DIMENSION(*) :: dims Return Value integer public  function dfti_create_descriptor_d_1d(desc, d, dom, one, dim) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in) :: d integer, intent(in) :: dom integer, intent(in) :: one integer, intent(in) :: dim Return Value integer public  function dfti_create_descriptor_d_md(desc, d, dom, many, dims) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in) :: d integer, intent(in) :: dom integer, intent(in) :: many integer, intent(in), DIMENSION(*) :: dims Return Value integer","tags":"","loc":"interface/dfticreatedescriptor.html"},{"title":"DftiCopyDescriptor – Quantum transport simulator","text":"public interface DftiCopyDescriptor Contents Functions dfti_copy_descriptor_external Functions public  function dfti_copy_descriptor_external(desc, new_desc) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc type( DFTI_DESCRIPTOR ), POINTER :: new_desc Return Value integer","tags":"","loc":"interface/dfticopydescriptor.html"},{"title":"DftiCommitDescriptor – Quantum transport simulator","text":"public interface DftiCommitDescriptor Called by interface~~dfticommitdescriptor~~CalledByGraph interface~dfticommitdescriptor MKL_DFTI::DftiCommitDescriptor proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->interface~dfticommitdescriptor proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Functions dfti_commit_descriptor_external Functions public  function dfti_commit_descriptor_external(desc) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc Return Value integer","tags":"","loc":"interface/dfticommitdescriptor.html"},{"title":"DftiSetValue – Quantum transport simulator","text":"public interface DftiSetValue Called by interface~~dftisetvalue~~CalledByGraph interface~dftisetvalue MKL_DFTI::DftiSetValue proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->interface~dftisetvalue proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Functions dfti_set_value_intval dfti_set_value_sglval dfti_set_value_dblval dfti_set_value_intvec dfti_set_value_chars Functions public  function dfti_set_value_intval(desc, OptName, IntVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(in) :: IntVal Return Value integer public  function dfti_set_value_sglval(desc, OptName, sglval) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_SPKP), intent(in) :: sglval Return Value integer public  function dfti_set_value_dblval(desc, OptName, DblVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_DPKP), intent(in) :: DblVal Return Value integer public  function dfti_set_value_intvec(desc, OptName, IntVec) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(in), DIMENSION(*) :: IntVec Return Value integer public  function dfti_set_value_chars(desc, OptName, Chars) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName character(len=*), intent(in) :: Chars Return Value integer","tags":"","loc":"interface/dftisetvalue.html"},{"title":"DftiGetValue – Quantum transport simulator","text":"public interface DftiGetValue Contents Functions dfti_get_value_intval dfti_get_value_sglval dfti_get_value_dblval dfti_get_value_intvec dfti_get_value_chars Functions public  function dfti_get_value_intval(desc, OptName, IntVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(out) :: IntVal Return Value integer public  function dfti_get_value_sglval(desc, OptName, sglval) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_SPKP), intent(out) :: sglval Return Value integer public  function dfti_get_value_dblval(desc, OptName, DblVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_DPKP), intent(out) :: DblVal Return Value integer public  function dfti_get_value_intvec(desc, OptName, IntVec) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(out), DIMENSION(*) :: IntVec Return Value integer public  function dfti_get_value_chars(desc, OptName, Chars) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName character(len=*), intent(out) :: Chars Return Value integer","tags":"","loc":"interface/dftigetvalue.html"},{"title":"DftiComputeForward – Quantum transport simulator","text":"public interface DftiComputeForward Called by interface~~dfticomputeforward~~CalledByGraph interface~dfticomputeforward MKL_DFTI::DftiComputeForward proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->interface~dfticomputeforward proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Functions dfti_compute_forward_s dfti_compute_forward_c dfti_compute_forward_ss dfti_compute_forward_sc dfti_compute_forward_cc dfti_compute_forward_ssss dfti_compute_forward_d dfti_compute_forward_z dfti_compute_forward_dd dfti_compute_forward_dz dfti_compute_forward_zz dfti_compute_forward_dddd Functions public  function dfti_compute_forward_s(desc, sSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: sSrcDst Return Value integer public  function dfti_compute_forward_c(desc, cSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: cSrcDst Return Value integer public  function dfti_compute_forward_ss(desc, sSrcDstRe, sSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstRe real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstIm Return Value integer public  function dfti_compute_forward_sc(desc, sSrc, cDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrc complex(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: cDst Return Value integer public  function dfti_compute_forward_cc(desc, cSrc, cDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: cSrc complex(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: cDst Return Value integer public  function dfti_compute_forward_ssss(desc, sSrcRe, sSrcIm, sDstRe, sDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcRe real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcIm real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstRe real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstIm Return Value integer public  function dfti_compute_forward_d(desc, dSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: dSrcDst Return Value integer public  function dfti_compute_forward_z(desc, zSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: zSrcDst Return Value integer public  function dfti_compute_forward_dd(desc, dSrcDstRe, dSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstRe real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstIm Return Value integer public  function dfti_compute_forward_dz(desc, dSrc, zDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrc complex(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: zDst Return Value integer public  function dfti_compute_forward_zz(desc, zSrc, zDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: zSrc complex(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: zDst Return Value integer public  function dfti_compute_forward_dddd(desc, dSrcRe, dSrcIm, dDstRe, dDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcRe real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcIm real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstRe real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstIm Return Value integer","tags":"","loc":"interface/dfticomputeforward.html"},{"title":"DftiComputeBackward – Quantum transport simulator","text":"public interface DftiComputeBackward Called by interface~~dfticomputebackward~~CalledByGraph interface~dfticomputebackward MKL_DFTI::DftiComputeBackward proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->interface~dfticomputebackward proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Functions dfti_compute_backward_s dfti_compute_backward_c dfti_compute_backward_ss dfti_compute_backward_cs dfti_compute_backward_cc dfti_compute_backward_ssss dfti_compute_backward_d dfti_compute_backward_z dfti_compute_backward_dd dfti_compute_backward_zd dfti_compute_backward_zz dfti_compute_backward_dddd Functions public  function dfti_compute_backward_s(desc, sSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: sSrcDst Return Value integer public  function dfti_compute_backward_c(desc, cSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: cSrcDst Return Value integer public  function dfti_compute_backward_ss(desc, sSrcDstRe, sSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstRe real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstIm Return Value integer public  function dfti_compute_backward_cs(desc, cSrc, sDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: cSrc real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDst Return Value integer public  function dfti_compute_backward_cc(desc, cSrc, cDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: cSrc complex(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: cDst Return Value integer public  function dfti_compute_backward_ssss(desc, sSrcRe, sSrcIm, sDstRe, sDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcRe real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcIm real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstRe real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstIm Return Value integer public  function dfti_compute_backward_d(desc, dSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: dSrcDst Return Value integer public  function dfti_compute_backward_z(desc, zSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: zSrcDst Return Value integer public  function dfti_compute_backward_dd(desc, dSrcDstRe, dSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstRe real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstIm Return Value integer public  function dfti_compute_backward_zd(desc, zSrc, dDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: zSrc real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDst Return Value integer public  function dfti_compute_backward_zz(desc, zSrc, zDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: zSrc complex(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: zDst Return Value integer public  function dfti_compute_backward_dddd(desc, dSrcRe, dSrcIm, dDstRe, dDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcRe real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcIm real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstRe real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstIm Return Value integer","tags":"","loc":"interface/dfticomputebackward.html"},{"title":"DftiFreeDescriptor – Quantum transport simulator","text":"public interface DftiFreeDescriptor Called by interface~~dftifreedescriptor~~CalledByGraph interface~dftifreedescriptor MKL_DFTI::DftiFreeDescriptor proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->interface~dftifreedescriptor proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Functions dfti_free_descriptor_external Functions public  function dfti_free_descriptor_external(desc) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc Return Value integer","tags":"","loc":"interface/dftifreedescriptor.html"},{"title":"DftiErrorClass – Quantum transport simulator","text":"public interface DftiErrorClass Contents Functions dfti_error_class_external Functions public  function dfti_error_class_external(Status, ErrorClass) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Status integer, intent(in) :: ErrorClass Return Value logical","tags":"","loc":"interface/dftierrorclass.html"},{"title":"DftiErrorMessage – Quantum transport simulator","text":"public interface DftiErrorMessage Contents Functions dfti_error_message_external Functions public  function dfti_error_message_external(Status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Status Return Value character(len=DFTI_MAX_MESSAGE_LENGTH)","tags":"","loc":"interface/dftierrormessage.html"},{"title":"devH_build_fromCOOfile – Quantum transport simulator","text":"public  subroutine devH_build_fromCOOfile(hfname, Hii, H1i, Sii, ext, contactBlockSize, nx, use0index, iscomplex, threshold, blocksize, sfname) Uses matrix_c graph_partition proc~~devh_build_fromcoofile~~UsesGraph proc~devh_build_fromcoofile deviceHam_mod::devH_build_fromCOOfile module~graph_partition graph_partition proc~devh_build_fromcoofile->module~graph_partition module~matrix_c matrix_c proc~devh_build_fromcoofile->module~matrix_c cublas cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hfname input H file name type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: Hii Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: H1i Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: Sii Hamiltonian blocks integer, intent(in) :: ext (2) number of extension blocks on left/right side integer, intent(in) :: contactBlockSize (2) number of orbitals in the contact block integer, intent(out) :: nx total number of slices logical, intent(in), optional :: use0index logical, intent(in), optional :: iscomplex real(kind=dp), intent(in), optional :: threshold integer, intent(in), optional :: blocksize blocksize of H character(len=*), intent(in), optional :: sfname input S file name Called by proc~~devh_build_fromcoofile~~CalledByGraph proc~devh_build_fromcoofile deviceHam_mod::devH_build_fromCOOfile program~main main program~main->proc~devh_build_fromcoofile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code devH_build_fromCOOfile Source Code subroutine devH_build_fromCOOfile ( hfname , Hii , H1i , Sii , ext , contactBlockSize , nx , use0index , iscomplex , threshold , blocksize , sfname ) use matrix_c , only : type_matrix_complex , malloc use graph_partition , only : slice , convert_fromCOO implicit none character ( len =* ), intent ( in ) :: hfname !! input H file name character ( len =* ), intent ( in ), optional :: sfname !! input S file name integer , intent ( in ) :: ext ( 2 ) !! number of extension blocks on left/right side integer , intent ( in ) :: contactBlockSize ( 2 ) !! number of orbitals in the contact block integer , intent ( out ) :: nx !! total number of slices integer , intent ( in ), optional :: blocksize !! blocksize of H type ( type_matrix_complex ), dimension (:), intent ( inout ), allocatable :: Hii , H1i , Sii !! Hamiltonian blocks logical , intent ( in ), optional :: use0index , iscomplex real ( dp ), intent ( in ), optional :: threshold ! ---- integer :: nnz , norb , i , newnnz , j , num_slices , nmax , ix , mm , nn integer , allocatable , dimension (:, :) :: nmii , nm1i complex ( dp ), allocatable , dimension (:) :: H , newH !! Hamiltonian matrix value in COO complex ( dp ), allocatable , dimension (:) :: S , newS !! overlap matrix value in COO integer , allocatable , dimension (:) :: row , col !! Hamiltonian matrix index in COO integer , allocatable , dimension (:) :: newrow , newcol !! Hamiltonian matrix index in COO integer , allocatable , dimension (:, :) :: Slices !! slicing information , refer to [[graph_partition]] integer , allocatable , dimension (:, :) :: g !! graph , refer to [[graph_partition]] integer , dimension ( contactBlockSize ( 1 )) :: E1 !! edge 1 , refer to [[graph_partition]] integer , dimension ( contactBlockSize ( 2 )) :: E2 !! edge 2 , refer to [[graph_partition]] ! if ( present ( sfname )) call load_COOmatrix ( trim ( Sfname ), S , nnz , norb , row , col , use0index , iscomplex ) call load_COOmatrix ( trim ( hfname ), H , nnz , norb , row , col , use0index , iscomplex ) ! ! ! optionally remove small matrix elements below threshold ! if (present(threshold)) then !     newnnz = count(abs(H) > threshold) !     allocate (newH(newnnz)) !     if (present(sfname)) allocate (newS(newnnz)) !     allocate (newrow(newnnz)) !     allocate (newcol(newnnz)) !     j = 0 !     do i = 1, nnz !         if (abs(H(i)) > threshold) then !             j = j + 1 !             newH(j) = H(i) !             if (present(sfname)) newS(j) = S(i) !             newrow(j) = row(i) !             newcol(j) = col(i) !         end if !     end do !     deallocate (H, row, col) !     if (present(sfname)) deallocate (S) !     call move_alloc(newH, H) !     if (present(sfname)) call move_alloc(newS, S) !     call move_alloc(newrow, row) !     call move_alloc(newcol, col) !     nnz = newnnz ! end if ! ! convert sparse matrix to a graph ! call convert_fromCOO(nnz, row, col, g) ! forall (i=1:contactBlockSize(1)) E1(i) = i ! forall (i=1:contactBlockSize(2)) E2(i) = norb - contactBlockSize(2) + i ! ! slice the device ! nmax = 100 ! ! try 1 contact slicing from left ! call slice(g, E1, Slices) ! slicing from left to right ! num_slices = size(Slices, 2) ! if (((Slices(1, num_slices) - 1) < contactBlockSize(2)) .or. & !     ((maxval(Slices(1, :)) - minval(Slices(1, :))) > (2*minval(Slices(1, :))))) then !     ! too small right contact , or very unbalanced slicing !     ! try 1 contact slicing from right !     call slice(g, E2, Slices) ! slicing from right to left !     num_slices = size(Slices, 2) !     if (((Slices(1, 1) - 1) < contactBlockSize(1)) .or. & !         ((maxval(Slices(1, :)) - minval(Slices(1, :))) > (2*minval(Slices(1, :))))) then !         ! too small left contact , or very unbalanced slicing !         call slice(g, E1, E2, NMAX, Slices) ! try 2 contact slicing !         num_slices = size(Slices, 2) !     end if ! end if ! print *, ' Slicing info: ', num_slices, ' slices, with block sizes = ' ! print '(12 I8)', slices(1, :) - 1 ! allocate the blocks : left extension|device|right extension if ( present ( blocksize )) then nx = norb / blocksize else nx = ext ( 1 ) + num_slices + ext ( 2 ) endif ! print * , \"---- nx=\" , nx , \"norb=\" , norb print * , \"---- nnz=\" , nnz print * , \"---- block size=\" , blocksize ! allocate ( nmii ( 2 , nx )) allocate ( nm1i ( 2 , nx + 1 )) ! if ( present ( blocksize )) then nmii = blocksize nm1i = blocksize else nmii (:, 1 : ext ( 1 )) = contactBlockSize ( 1 ) nmii (:, ( nx - ext ( 2 ) + 1 ): nx ) = contactBlockSize ( 2 ) nmii ( 1 , ext ( 1 ):( nx - ext ( 2 ))) = Slices ( 1 , :) - 1 nmii ( 2 , ext ( 1 ):( nx - ext ( 2 ))) = Slices ( 1 , :) - 1 nm1i (:, 1 ) = nmii (:, 1 ) nm1i (:, nx + 1 ) = nmii (:, nx ) nm1i ( 1 , 2 : nx ) = nmii ( 1 , 2 : nx ) nm1i ( 2 , 2 : nx ) = nmii ( 1 , 1 :( nx - 1 )) endif ! allocate ( Hii ( nx )) allocate ( Sii ( nx )) allocate ( H1i ( nx + 1 )) call malloc ( Hii , nx , nmii ) call malloc ( Sii , nx , nmii ) call malloc ( H1i , nx + 1 , nm1i ) ! build the blocks do i = 1 , nnz ix = row ( i ) / blocksize + 1 mm = row ( i ) - ( ix - 1 ) * blocksize nn = col ( i ) - ( ix - 1 ) * blocksize ! print *, i, ix, mm, nn if ( ix <= nx ) then if ( nn <= blocksize ) then Hii ( ix )% m ( mm , nn ) = H ( i ) Hii ( ix )% m ( nn , mm ) = conjg ( H ( i )) if ( present ( sfname )) then Sii ( ix )% m ( mm , nn ) = S ( i ) endif else if ( nn <= blocksize * 2 ) then H1i ( ix )% m ( mm , nn - blocksize ) = H ( i ) endif endif endif enddo H1i ( nx + 1 )% m = H1i ( nx )% m if (. not . present ( sfname )) then do ix = 1 , nx do mm = 1 , blocksize Sii ( ix )% m ( mm , mm ) = 1.0d0 enddo enddo endif deallocate ( H , col , row , nmii , nm1i ) if ( present ( sfname )) deallocate ( S ) end subroutine devH_build_fromCOOfile","tags":"","loc":"proc/devh_build_fromcoofile.html"},{"title":"devH_build_fromWannierFile – Quantum transport simulator","text":"public  subroutine devH_build_fromWannierFile(fname, Hii, H1i, Sii, nx, nslab, nband, nk, k, length_x, lreorder_axis, axis) Uses wannierHam3d matrix_c proc~~devh_build_fromwannierfile~~UsesGraph proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile module~matrix_c matrix_c proc~devh_build_fromwannierfile->module~matrix_c module~wannierham3d wannierHam3d proc~devh_build_fromwannierfile->module~wannierham3d cublas cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name type( type_matrix_complex ), intent(inout), dimension(:, :), allocatable :: Hii Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:, :), allocatable :: H1i Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:, :), allocatable :: Sii overlap matrix blocks integer, intent(in) :: nx number of slabs integer, intent(in) :: nslab number of cells per slab integer, intent(out) :: nband number of bands/orbitals per cell (from wannier90) integer, intent(in) :: nk real(kind=dp), intent(in) :: k (2,nk) real(kind=dp), intent(out) :: length_x logical, intent(in), optional :: lreorder_axis whether to reorder axis integer, intent(in), optional :: axis (3) permutation order Calls proc~~devh_build_fromwannierfile~~CallsGraph proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~w90_free_memory wannierHam3d::w90_free_memory proc~devh_build_fromwannierfile->proc~w90_free_memory proc~w90_load_from_file wannierHam3d::w90_load_from_file proc~devh_build_fromwannierfile->proc~w90_load_from_file proc~w90_mat_def wannierHam3d::w90_MAT_DEF proc~devh_build_fromwannierfile->proc~w90_mat_def proc~cross~2 wannierHam3d::cross proc~w90_load_from_file->proc~cross~2 proc~norm wannierHam3d::norm proc~w90_load_from_file->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~devh_build_fromwannierfile~~CalledByGraph proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile program~main main program~main->proc~devh_build_fromwannierfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code devH_build_fromWannierFile Source Code subroutine devH_build_fromWannierFile ( fname , Hii , H1i , Sii , nx , nslab , nband , nk , k , length_x , lreorder_axis , axis ) use matrix_c , only : type_matrix_complex , malloc use wannierHam3d , only : w90_load_from_file , w90_free_memory , w90_MAT_DEF , nb , Lx character ( len =* ), intent ( in ) :: fname !! input text file name logical , intent ( in ), optional :: lreorder_axis !! whether to reorder axis integer , intent ( in ), optional :: axis ( 3 ) !! permutation order integer , intent ( in ) :: nx !! number of slabs integer , intent ( in ) :: nslab !! number of cells per slab integer , intent ( out ) :: nband !! number of bands/orbitals per cell (from wannier90) type ( type_matrix_complex ), dimension (:, :), intent ( inout ), allocatable :: Hii , H1i !! Hamiltonian blocks type ( type_matrix_complex ), dimension (:, :), intent ( inout ), allocatable :: Sii !! overlap matrix blocks real ( dp ), intent ( in ) :: k ( 2 , nk ) real ( dp ), intent ( out ) :: length_x integer , intent ( in ) :: nk ! ---- complex ( dp ), allocatable , dimension (:, :) :: H00 , H10 real ( dp ) :: kx , ky , kz integer :: nm , i , im , ik integer , dimension ( 2 , nx + 1 ) :: nmm print * , \"read w90\" open ( unit = 10 , file = trim ( fname ), status = 'unknown' ) call w90_load_from_file ( 10 , lreorder_axis , axis ) close ( 10 ) print * , \"read w90 DONE\" nm = nb * nslab nband = nb length_x = Lx nmm = nm allocate ( H00 ( nm , nm )) allocate ( H10 ( nm , nm )) kx = 0.0d0 ! allocate ( Hii ( nx , nk )) allocate ( H1i ( nx + 1 , nk )) allocate ( Sii ( nx , nk )) do ik = 1 , nk ky = k ( 1 , ik ) kz = k ( 2 , ik ) call w90_MAT_DEF ( H00 , H10 , kx , ky , kz , nslab ) ! call malloc ( Hii (:, ik ), nx , nmm (:, 1 : nx )) call malloc ( Sii (:, ik ), nx , nmm (:, 1 : nx )) call malloc ( H1i (:, ik ), nx + 1 , nmm ) ! do i = 1 , nx Hii ( i , ik )% m = H00 H1i ( i , ik )% m = H10 Sii ( i , ik )% m = dcmplx ( 0.0d0 , 0.0d0 ) do im = 1 , nm Sii ( i , ik )% m ( im , im ) = 1.0d0 end do end do H1i ( nx + 1 , ik )% m = H10 end do deallocate ( H00 , H10 ) call w90_free_memory () end subroutine devH_build_fromWannierFile","tags":"","loc":"proc/devh_build_fromwannierfile.html"},{"title":"norm – Quantum transport simulator","text":"public  function norm(vector) Arguments Type Intent Optional Attributes Name real(kind=8) :: vector (3) Return Value real(kind=8) Called by proc~~norm~~CalledByGraph proc~norm wannierHam3d::norm proc~w90_load_from_file wannierHam3d::w90_load_from_file proc~w90_load_from_file->proc~norm proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->proc~w90_load_from_file program~main main program~main->proc~devh_build_fromwannierfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/norm.html"},{"title":"cross – Quantum transport simulator","text":"public  function cross(a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), DIMENSION(3) :: a real(kind=8), intent(in), DIMENSION(3) :: b Return Value real(kind=8), DIMENSION(3) Called by proc~~cross~2~~CalledByGraph proc~cross~2 wannierHam3d::cross proc~w90_load_from_file wannierHam3d::w90_load_from_file proc~w90_load_from_file->proc~cross~2 proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->proc~w90_load_from_file program~main main program~main->proc~devh_build_fromwannierfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code cross Source Code FUNCTION cross ( a , b ) implicit none REAL ( 8 ), DIMENSION ( 3 ) :: cross REAL ( 8 ), DIMENSION ( 3 ), INTENT ( IN ) :: a , b cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION cross","tags":"","loc":"proc/cross~2.html"},{"title":"eig – Quantum transport simulator","text":"public  function eig(NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) Calls proc~~eig~2~~CallsGraph proc~eig~2 wannierHam3d::eig zheev zheev proc~eig~2->zheev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code eig Source Code FUNCTION eig ( NN , A ) implicit none INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A REAL ( 8 ) :: eig ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) CALL zheev ( 'N' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eig (:) = W (:) END FUNCTION eig","tags":"","loc":"proc/eig~2.html"},{"title":"eigv – Quantum transport simulator","text":"public  function eigv(NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) Calls proc~~eigv~2~~CallsGraph proc~eigv~2 wannierHam3d::eigv zheev zheev proc~eigv~2->zheev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code eigv Source Code FUNCTION eigv ( NN , A ) implicit none INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A REAL ( 8 ) :: eigv ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) CALL zheev ( 'V' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eigv (:) = W (:) END FUNCTION eigv","tags":"","loc":"proc/eigv~2.html"},{"title":"w90_free_memory – Quantum transport simulator","text":"public  subroutine w90_free_memory() Arguments None Called by proc~~w90_free_memory~~CalledByGraph proc~w90_free_memory wannierHam3d::w90_free_memory proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->proc~w90_free_memory program~main main program~main->proc~devh_build_fromwannierfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code w90_free_memory Source Code SUBROUTINE w90_free_memory () deallocate ( Hr ) if ( allocated ( rmn )) deallocate ( rmn ) if ( allocated ( pmn )) deallocate ( pmn ) if ( allocated ( Vmn )) deallocate ( Vmn ) deallocate ( wannier_center ) END SUBROUTINE w90_free_memory","tags":"","loc":"proc/w90_free_memory.html"},{"title":"w90_load_from_file – Quantum transport simulator","text":"public  subroutine w90_load_from_file(fid, lreorder_axis, axis) Uses iso_fortran_env proc~~w90_load_from_file~~UsesGraph proc~w90_load_from_file wannierHam3d::w90_load_from_file iso_fortran_env iso_fortran_env proc~w90_load_from_file->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: fid logical, intent(in), optional :: lreorder_axis integer, intent(in), optional :: axis (3) Calls proc~~w90_load_from_file~~CallsGraph proc~w90_load_from_file wannierHam3d::w90_load_from_file proc~cross~2 wannierHam3d::cross proc~w90_load_from_file->proc~cross~2 proc~norm wannierHam3d::norm proc~w90_load_from_file->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~w90_load_from_file~~CalledByGraph proc~w90_load_from_file wannierHam3d::w90_load_from_file proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->proc~w90_load_from_file program~main main program~main->proc~devh_build_fromwannierfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code w90_load_from_file Source Code SUBROUTINE w90_load_from_file ( fid , lreorder_axis , axis ) use , intrinsic :: iso_fortran_env !        include \"mpif.h\" integer , intent ( in ) :: fid logical , intent ( in ), optional :: lreorder_axis integer , intent ( in ), optional :: axis ( 3 ) integer :: n , i , nkx , nky , nkz character ( len = 40 ) :: line , comment REAL ( 8 ) :: dky , dkz , aux1 ( 3 ), aux2 ( 3 , 3 ) integer , allocatable :: ind (:) REAL ( 8 ), allocatable :: ham (:, :), energ (:, :), aux3 (:, :) integer ( kind = int32 ) :: rank integer ( kind = int32 ) :: ierror ! Get the individual process (rank) !        call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierror) rank = 0 read ( fid , * ) nvb , spin_deg ! number of VBs, spin-degeneracy read ( fid , * ) comment read ( fid , * ) alpha read ( fid , * ) beta read ( fid , * ) gamm cell (:, 1 ) = alpha cell (:, 2 ) = beta cell (:, 3 ) = gamm read ( fid , * ) comment if ( present ( lreorder_axis )) then if ( lreorder_axis ) then aux2 (:, :) = cell (:, axis ) cell = aux2 alpha = cell (:, 1 ) beta = cell (:, 2 ) gamm = cell (:, 3 ) end if endif read ( fid , * ) n allocate ( ham ( n , 7 )) do i = 1 , n read ( fid , * ) ham ( i , :) end do if ( present ( lreorder_axis )) then if ( ( lreorder_axis )) then allocate ( aux3 ( n , 7 )) aux3 = ham aux3 (:, 1 : 3 ) = ham (:, axis ) ham = aux3 deallocate ( aux3 ) end if endif xmin = minval ( ham (:, 1 )) xmax = maxval ( ham (:, 1 )) ymin = minval ( ham (:, 2 )) ymax = maxval ( ham (:, 2 )) zmin = minval ( ham (:, 3 )) zmax = maxval ( ham (:, 3 )) nb = maxval ( ham (:, 4 )) nx = xmax - xmin + 1 ny = ymax - ymin + 1 nz = zmax - zmin + 1 xhat = alpha / norm ( alpha ) yhat = - cross ( xhat , gamm ) yhat = yhat / norm ( yhat ) zhat = gamm / norm ( gamm ) Ly = abs ( dot_product ( beta , yhat )); ! L is in unit of A Lx = abs ( dot_product ( alpha , xhat )); Lz = norm ( gamm ) if ( rank == 0 ) then print '(A40)' , 'reading Wannier H from file, info:' print '(8a5)' , 'xmin' , 'xmax' , 'ymin' , 'ymax' , 'zmin' , 'zmax' , 'nb' , 'nvb' print '(8i5)' , xmin , xmax , ymin , ymax , zmin , zmax , nb , nvb print '(3a5)' , 'Lx' , 'Ly' , 'Lz' print '(3f5.1)' , Lx , Ly , Lz end if b1 = cross ( beta , gamm ) / dot_product ( alpha , cross ( beta , gamm )) b2 = cross ( gamm , alpha ) / dot_product ( beta , cross ( gamm , alpha )) allocate ( Hr ( nb , nb , nx , ny , nz )) Hr (:, :, :, :, :) = zzero do i = 1 , n Hr ( floor ( ham ( i , 4 )), floor ( ham ( i , 5 )), floor ( ham ( i , 1 )) - xmin + 1 ,& & floor ( ham ( i , 2 )) - ymin + 1 , floor ( ham ( i , 3 )) - zmin + 1 ) = ham ( i , 6 ) + z1j * ham ( i , 7 ); end do !print *, 'Find CBM and VBM' nkx = floor (( 1.0d0 / Lx ) / 0.01d0 ) + 1 nky = floor (( 1.0d0 / Ly ) / 0.01d0 ) + 1 nkz = floor (( 1.0d0 / Lz ) / 0.01d0 ) + 1 if ( nx == 1 ) nkx = 1 if ( ny == 1 ) nky = 1 if ( nz == 1 ) nkz = 1 if ( ny . eq . 1 ) then nky = 1 end if if ( nx . eq . 1 ) then nkx = 1 end if if ( nz . eq . 1 ) then nkz = 1 end if if ( nky > 1 ) then dky = 1.0d0 / dble ( nky - 1 ) * 2 * pi / Ly else dky = 2 * pi / Ly end if if ( nkz > 1 ) then dkz = 1.0d0 / dble ( nkz - 1 ) * 2 * pi / Lz else dkz = 2 * pi / Lz end if allocate ( energ ( nb , nkx * nky * nkz )) allocate ( ind ( nb )) call w90_PLOT_BZ ( nkx , nky , nkz , energ ) ind = maxloc ( energ , 2 ) kt_vbm = mod ( ind ( nvb ), nkx ) * dky - pi / Ly ! k transverse corresponding to VBMax ind = minloc ( energ , 2 ) kt_cbm = mod ( ind ( nvb + 1 ), nkx ) * dky - pi / Ly ! k transverse corresponding to CBM if ( ny . eq . 1 ) then kt_cbm = 0.0d0 kt_vbm = 0.0d0 end if ind = maxloc ( energ , 2 ) VBM = energ ( nvb , ind ( nvb )) ind = minloc ( energ , 2 ) CBM = energ ( nvb + 1 , ind ( nvb + 1 )) Eg = CBM - VBM if ( rank == 0 ) then print '(3A8)' , 'CBM' , 'VBM' , 'Eg' print '(3f8.3)' , CBM , VBM , CBM - VBM print '(3A8)' , 'kt_CBM' , 'kt_VBM' , '2pi/Ly' print '(2f8.3)' , kt_cbm / ( 2.0 * pi / Ly ), kt_vbm / ( 2.0 * pi / Ly ) print '(A40)' , 'reading Wannier centers from file' end if read ( fid , * ) comment allocate ( wannier_center ( 3 , nb )) do i = 1 , nb read ( fid , * ) wannier_center (:, i ) end do if ( present ( lreorder_axis ) ) then if ( ( lreorder_axis )) then allocate ( aux3 ( 3 , nb )) aux3 = wannier_center aux3 ( 1 : 3 , :) = wannier_center ( axis , :) wannier_center = aux3 deallocate ( aux3 ) end if endif ! bring wannier_center into the first unit-cell, only works for orth. ! to-do: make this general do i = 1 , NB if ( wannier_center ( 1 , i ) < 0 ) wannier_center (:, i ) = wannier_center (:, i ) + alpha if ( wannier_center ( 1 , i ) > Lx ) wannier_center (:, i ) = wannier_center (:, i ) - alpha if ( wannier_center ( 2 , i ) < 0 ) wannier_center (:, i ) = wannier_center (:, i ) + beta if ( wannier_center ( 2 , i ) > Ly ) wannier_center (:, i ) = wannier_center (:, i ) - beta if ( wannier_center ( 3 , i ) < 0 ) wannier_center (:, i ) = wannier_center (:, i ) + gamm if ( wannier_center ( 3 , i ) > Lz ) wannier_center (:, i ) = wannier_center (:, i ) - gamm end do ! center z around 0 wannier_center ( 3 , :) = wannier_center ( 3 , :) - ( sum ( wannier_center ( 3 , :) / dble ( NB ))) deallocate ( ham ) deallocate ( energ ) deallocate ( ind ) END SUBROUTINE w90_load_from_file","tags":"","loc":"proc/w90_load_from_file.html"},{"title":"w90_MAT_DEF – Quantum transport simulator","text":"public  subroutine w90_MAT_DEF(Hii, H1i, kx, ky, kz, ns) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: Hii complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: H1i real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: ns Called by proc~~w90_mat_def~~CalledByGraph proc~w90_mat_def wannierHam3d::w90_MAT_DEF proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->proc~w90_mat_def program~main main program~main->proc~devh_build_fromwannierfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code w90_MAT_DEF Source Code SUBROUTINE w90_MAT_DEF ( Hii , H1i , kx , ky , kz , ns ) ! ky in [2pi/Ang] implicit none integer , intent ( in ) :: ns COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB * ns , NB * ns ) :: Hii , H1i real ( 8 ), intent ( in ) :: ky , kx , kz integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r Hii (:, :) = zzero H1i (:, :) = zzero do i = 1 , ns do k = 1 , ns do j = ymin , ymax do l = zmin , zmax kv = kx * xhat + ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Hr (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) end if if ((( i - k + ns ) <= xmax ) . and . (( i - k + ns ) >= xmin )) then H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Hr (:, :, i - k - xmin + ns + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) end if end do end do end do end do END SUBROUTINE w90_MAT_DEF","tags":"","loc":"proc/w90_mat_def.html"},{"title":"w90_MAT_DEF_full_device – Quantum transport simulator","text":"public  subroutine w90_MAT_DEF_full_device(Ham, ky, kz, length, NS) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(NB*length, NB*length) :: Ham real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: length integer, intent(in), optional :: NS Contents Source Code w90_MAT_DEF_full_device Source Code SUBROUTINE w90_MAT_DEF_full_device ( Ham , ky , kz , length , NS ) implicit none integer , intent ( in ) :: length integer , intent ( in ), optional :: NS real ( 8 ), intent ( in ) :: ky , kz complex ( 8 ), intent ( inout ), dimension ( NB * length , NB * length ) :: Ham integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r complex ( 8 ) :: phi Ham = dcmplx ( 0.0d0 , 0.0d0 ) do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm phi = dcmplx ( 0.0d0 , - dot_product ( r , kv )) if ( present ( NS )) then if (( i - k <= min ( NS , xmax )) . and . ( i - k >= max ( - NS , xmin ))) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & Hr (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if else if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & Hr (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if end if end do end do end do end do END SUBROUTINE w90_MAT_DEF_full_device","tags":"","loc":"proc/w90_mat_def_full_device.html"},{"title":"w90_bare_coulomb_blocks – Quantum transport simulator","text":"public  subroutine w90_bare_coulomb_blocks(Hii, H1i, kx, ky, kz, eps, r0, ns, ldiag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: Hii complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: H1i real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz real(kind=8), intent(in) :: eps real(kind=8), intent(in) :: r0 integer, intent(in) :: ns logical, intent(in) :: ldiag Contents Source Code w90_bare_coulomb_blocks Source Code SUBROUTINE w90_bare_coulomb_blocks ( Hii , H1i , kx , ky , kz , eps , r0 , NS , ldiag ) ! ky in [2pi/Ang] implicit none integer , intent ( in ) :: ns COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB * ns , NB * ns ) :: Hii , H1i real ( 8 ), intent ( in ) :: ky , kx , kz real ( 8 ), intent ( in ) :: eps ! dielectric constant real ( 8 ), intent ( in ) :: r0 ! length [ang] to remove singularity of 1/r logical , intent ( in ) :: ldiag ! include diagonal integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r Hii (:, :) = zzero H1i (:, :) = zzero kv = kx * xhat + ky * yhat + kz * zhat do i = 1 , ns do k = 1 , ns do j = ymin , ymax do l = zmin , zmax r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k + ns , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end do end do end do end do END SUBROUTINE w90_bare_coulomb_blocks","tags":"","loc":"proc/w90_bare_coulomb_blocks.html"},{"title":"w90_bare_coulomb_full_device – Quantum transport simulator","text":"public  subroutine w90_bare_coulomb_full_device(V, ky, kz, length, eps, r0, ldiag, NS, method) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), dimension(NB*length, NB*length) :: V real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: length real(kind=8), intent(in) :: eps real(kind=8), intent(in) :: r0 logical, intent(in) :: ldiag integer, intent(in), optional :: NS character(len=*), intent(in), optional :: method Contents Source Code w90_bare_coulomb_full_device Source Code SUBROUTINE w90_bare_coulomb_full_device ( V , ky , kz , length , eps , r0 , ldiag , NS , method ) implicit none integer , intent ( in ) :: length integer , intent ( in ), optional :: NS real ( 8 ), intent ( in ) :: ky , kz , eps ! dielectric constant / to reduce V real ( 8 ), intent ( in ) :: r0 ! length [ang] to remove singularity of 1/r logical , intent ( in ) :: ldiag ! include diagonal character ( len =* ), intent ( in ), optional :: method character ( len = 20 ) :: cmethod complex ( 8 ), intent ( out ), dimension ( NB * length , NB * length ) :: V integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r V = dcmplx ( 0.0d0 , 0.0d0 ) if ( present ( method )) then cmethod = method else cmethod = 'pointlike' end if select case ( trim ( cmethod )) case ( 'pointlike' ) do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm if ( present ( NS )) then if (( i - k <= NS ) . and . ( i - k >= - NS )) then V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end if else V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end if end do end do end do end do case ( 'fromfile' ) call w90_load_coulomb_blocks do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm if ( present ( NS )) then if (( i - k <= NS ) . and . ( i - k >= - NS )) then V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Vmn (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) / eps end if else if ( abs ( i - k ) < 4 ) then V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Vmn (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) / eps else V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end if end if end do end do end do end do end select END SUBROUTINE w90_bare_coulomb_full_device","tags":"","loc":"proc/w90_bare_coulomb_full_device.html"},{"title":"w90_momentum_blocks – Quantum transport simulator","text":"public  subroutine w90_momentum_blocks(Hii, H1i, kx, ky, kz, ns, method) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns, 3) :: Hii complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns, 3) :: H1i real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: ns character(len=*), intent(in) :: method Contents Source Code w90_momentum_blocks Source Code SUBROUTINE w90_momentum_blocks ( Hii , H1i , kx , ky , kz , NS , method ) ! ky in [2pi/Ang] implicit none integer , intent ( in ) :: ns COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB * ns , NB * ns , 3 ) :: Hii , H1i ! momentum matrix block [eV] real ( 8 ), intent ( in ) :: ky , kx , kz character ( len =* ), intent ( in ) :: method integer :: i , j , k , l , v real ( 8 ), dimension ( 3 ) :: kv , r complex ( 8 ) :: phi Hii (:, :, :) = zzero H1i (:, :, :) = zzero call calc_momentum_operator ( method ) kv = kx * xhat + ky * yhat + kz * zhat do v = 1 , 3 ! cart direction do i = 1 , ns do k = 1 , ns do j = ymin , ymax do l = zmin , zmax r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm phi = dcmplx ( 0.0d0 , - dot_product ( r , kv )) if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if if ((( i - k + ns ) <= xmax ) . and . (( i - k + ns ) >= xmin )) then H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 + NS , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if end do end do end do end do end do END SUBROUTINE w90_momentum_blocks","tags":"","loc":"proc/w90_momentum_blocks.html"},{"title":"w90_momentum_full_device – Quantum transport simulator","text":"public  subroutine w90_momentum_full_device(Ham, ky, kz, length, NS, method) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(NB*length, NB*length, 3) :: Ham real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: length integer, intent(in), optional :: NS character(len=*), intent(in) :: method Contents Source Code w90_momentum_full_device Source Code SUBROUTINE w90_momentum_full_device ( Ham , ky , kz , length , NS , method ) implicit none integer , intent ( in ) :: length integer , intent ( in ), optional :: NS real ( 8 ), intent ( in ) :: ky , kz complex ( 8 ), intent ( inout ), dimension ( NB * length , NB * length , 3 ) :: Ham ! momentum matrix [eV] character ( len =* ), intent ( in ) :: method integer :: i , j , k , v , l real ( 8 ), dimension ( 3 ) :: kv , r complex ( 8 ) :: phi Ham = dcmplx ( 0.0d0 , 0.0d0 ) call calc_momentum_operator ( method ) do v = 1 , 3 ! cart direction do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm phi = dcmplx ( 0.0d0 , - dot_product ( r , kv )) if ( present ( NS )) then if (( i - k <= min ( NS , xmax )) . and . ( i - k >= max ( - NS , xmin ))) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if else if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if end if end do end do end do end do end do END SUBROUTINE w90_momentum_full_device","tags":"","loc":"proc/w90_momentum_full_device.html"},{"title":"invert – Quantum transport simulator","text":"public  subroutine invert(A, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(nn, nn) :: A integer :: nn Calls proc~~invert~3~~CallsGraph proc~invert~3 wannierHam3d::invert zgetrf zgetrf proc~invert~3->zgetrf zgetri zgetri proc~invert~3->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code invert Source Code subroutine invert ( A , nn ) implicit none integer :: info , lda , lwork , nn integer , dimension (:), allocatable :: ipiv complex ( 8 ), dimension ( nn , nn ), intent ( inout ) :: A complex ( 8 ), dimension (:), allocatable :: work allocate ( work ( nn * nn )) allocate ( ipiv ( nn )) call zgetrf ( nn , nn , A , nn , ipiv , info ) call zgetri ( nn , A , nn , ipiv , work , nn * nn , info ) deallocate ( work ) deallocate ( ipiv ) end subroutine invert","tags":"","loc":"proc/invert~3.html"},{"title":"corr1d – Quantum transport simulator","text":"public  function corr1d(n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n) character(len=*), intent(in) :: method Return Value complex(kind=8), (2*n-1) Calls proc~~corr1d~~CallsGraph proc~corr1d fft_mod::corr1d proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~corr1d->proc~do_mkl_dfti_conv interface~dfticommitdescriptor MKL_DFTI::DftiCommitDescriptor proc~do_mkl_dfti_conv->interface~dfticommitdescriptor interface~dfticomputebackward MKL_DFTI::DftiComputeBackward proc~do_mkl_dfti_conv->interface~dfticomputebackward interface~dfticomputeforward MKL_DFTI::DftiComputeForward proc~do_mkl_dfti_conv->interface~dfticomputeforward interface~dfticreatedescriptor MKL_DFTI::DftiCreateDescriptor proc~do_mkl_dfti_conv->interface~dfticreatedescriptor interface~dftifreedescriptor MKL_DFTI::DftiFreeDescriptor proc~do_mkl_dfti_conv->interface~dftifreedescriptor interface~dftisetvalue MKL_DFTI::DftiSetValue proc~do_mkl_dfti_conv->interface~dftisetvalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code corr1d Source Code function corr1d ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n ) complex ( 8 ) :: Z ( 2 * n - 1 ) complex ( 8 ), allocatable , dimension (:) :: X_ , Y_ integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do i = - n + 1 , n - 1 do ie = max ( i + 1 , 1 ), min ( n , n + i ) Z ( i + n ) = Z ( i + n ) + X ( ie ) * Y ( ie - i ) end do end do case ( 'simple' ) do i = - n + 1 , n - 1 Z ( i + n ) = sum ( X ( max ( 1 , 1 + i ): min ( n + i , n )) * Y ( max ( 1 - i , 1 ): min ( n , n - i ))) end do case ( 'fft' ) allocate ( X_ ( n * 2 - 1 )) allocate ( Y_ ( n * 2 - 1 )) X_ = czero ! pad by zero Y_ = czero X_ ( 1 : n ) = X Y_ ( 1 : n ) = Y ( n : 1 : - 1 ) call do_mkl_dfti_conv ( n * 2 - 1 , X_ , Y_ , Z ) deallocate ( X_ , Y_ ) end select end function corr1d","tags":"","loc":"proc/corr1d.html"},{"title":"corr1d2 – Quantum transport simulator","text":"public  function corr1d2(n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n) character(len=*), intent(in) :: method Return Value complex(kind=8), (n) Calls proc~~corr1d2~~CallsGraph proc~corr1d2 fft_mod::corr1d2 proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~corr1d2->proc~do_mkl_dfti_conv interface~dfticommitdescriptor MKL_DFTI::DftiCommitDescriptor proc~do_mkl_dfti_conv->interface~dfticommitdescriptor interface~dfticomputebackward MKL_DFTI::DftiComputeBackward proc~do_mkl_dfti_conv->interface~dfticomputebackward interface~dfticomputeforward MKL_DFTI::DftiComputeForward proc~do_mkl_dfti_conv->interface~dfticomputeforward interface~dfticreatedescriptor MKL_DFTI::DftiCreateDescriptor proc~do_mkl_dfti_conv->interface~dfticreatedescriptor interface~dftifreedescriptor MKL_DFTI::DftiFreeDescriptor proc~do_mkl_dfti_conv->interface~dftifreedescriptor interface~dftisetvalue MKL_DFTI::DftiSetValue proc~do_mkl_dfti_conv->interface~dftisetvalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code corr1d2 Source Code function corr1d2 ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n ) complex ( 8 ) :: Z ( n ) complex ( 8 ), allocatable , dimension (:) :: X_ , Y_ , Z_ integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do i = - n / 2 + 1 , n / 2 - 1 do ie = max ( i + 1 , 1 ), min ( n , n + i ) Z ( i + n / 2 ) = Z ( i + n / 2 ) + X ( ie ) * Y ( ie - i ) end do end do case ( 'simple' ) do i = - n / 2 + 1 , n / 2 - 1 Z ( i + n / 2 ) = sum ( X ( max ( 1 , 1 + i ): min ( n + i , n )) * Y ( max ( 1 - i , 1 ): min ( n , n - i ))) end do case ( 'fft' ) allocate ( X_ ( n * 2 - 1 )) allocate ( Y_ ( n * 2 - 1 )) allocate ( Z_ ( n * 2 - 1 )) X_ = czero ! pad by zero Y_ = czero X_ ( 1 : n ) = X Y_ ( 1 : n ) = Y ( n : 1 : - 1 ) call do_mkl_dfti_conv ( n * 2 - 1 , X_ , Y_ , Z_ ) Z = Z_ ( n - n / 2 : n + n / 2 - 1 ) deallocate ( X_ , Y_ , Z_ ) end select end function corr1d2","tags":"","loc":"proc/corr1d2.html"},{"title":"conv1d – Quantum transport simulator","text":"public  function conv1d(n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n*2-1) character(len=*), intent(in) :: method Return Value complex(kind=8), (n) Calls proc~~conv1d~~CallsGraph proc~conv1d fft_mod::conv1d proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~conv1d->proc~do_mkl_dfti_conv interface~dfticommitdescriptor MKL_DFTI::DftiCommitDescriptor proc~do_mkl_dfti_conv->interface~dfticommitdescriptor interface~dfticomputebackward MKL_DFTI::DftiComputeBackward proc~do_mkl_dfti_conv->interface~dfticomputebackward interface~dfticomputeforward MKL_DFTI::DftiComputeForward proc~do_mkl_dfti_conv->interface~dfticomputeforward interface~dfticreatedescriptor MKL_DFTI::DftiCreateDescriptor proc~do_mkl_dfti_conv->interface~dfticreatedescriptor interface~dftifreedescriptor MKL_DFTI::DftiFreeDescriptor proc~do_mkl_dfti_conv->interface~dftifreedescriptor interface~dftisetvalue MKL_DFTI::DftiSetValue proc~do_mkl_dfti_conv->interface~dftisetvalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code conv1d Source Code function conv1d ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n * 2 - 1 ) complex ( 8 ) :: Z ( n ) complex ( 8 ), allocatable , dimension (:) :: x_in , y_in , z_in integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do ie = 1 , n do i = - n + 1 , n - 1 if (( ie . gt . max ( i , 1 )) . and . ( ie . lt . min ( n , ( n + i )))) then Z ( ie ) = Z ( ie ) + X ( ie - i ) * Y ( i + n ) end if end do end do case ( 'simple' ) do i = 1 , n Z ( i ) = sum ( X ( n : 1 : - 1 ) * Y ( i : i + n - 1 )) end do case ( 'fft' ) allocate ( X_in ( n * 2 - 1 )) allocate ( Y_in ( n * 2 - 1 )) allocate ( Z_in ( n * 2 - 1 )) X_in = czero X_in ( 1 : n ) = X Y_in = cshift ( Y , - n ) call do_mkl_dfti_conv ( n * 2 - 1 , Y_in , X_in , Z_in ) Z = Z_in ( 1 : n ) deallocate ( X_in , Y_in , Z_in ) end select end function conv1d","tags":"","loc":"proc/conv1d.html"},{"title":"conv1d2 – Quantum transport simulator","text":"public  function conv1d2(n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n) character(len=*), intent(in) :: method Return Value complex(kind=8), (n) Calls proc~~conv1d2~~CallsGraph proc~conv1d2 fft_mod::conv1d2 proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~conv1d2->proc~do_mkl_dfti_conv interface~dfticommitdescriptor MKL_DFTI::DftiCommitDescriptor proc~do_mkl_dfti_conv->interface~dfticommitdescriptor interface~dfticomputebackward MKL_DFTI::DftiComputeBackward proc~do_mkl_dfti_conv->interface~dfticomputebackward interface~dfticomputeforward MKL_DFTI::DftiComputeForward proc~do_mkl_dfti_conv->interface~dfticomputeforward interface~dfticreatedescriptor MKL_DFTI::DftiCreateDescriptor proc~do_mkl_dfti_conv->interface~dfticreatedescriptor interface~dftifreedescriptor MKL_DFTI::DftiFreeDescriptor proc~do_mkl_dfti_conv->interface~dftifreedescriptor interface~dftisetvalue MKL_DFTI::DftiSetValue proc~do_mkl_dfti_conv->interface~dftisetvalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code conv1d2 Source Code function conv1d2 ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n ) complex ( 8 ) :: Z ( n ) complex ( 8 ), allocatable , dimension (:) :: x_in , y_in , z_in integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do ie = 1 , n do i = - n / 2 + 1 , n / 2 - 1 if (( ie . gt . max ( i , 1 )) . and . ( ie . lt . min ( n , ( n + i )))) then Z ( ie ) = Z ( ie ) + X ( ie - i ) * Y ( i + n / 2 ) end if end do end do case ( 'simple' ) allocate ( Y_in ( n * 2 - 1 )) Y_in ( n - n / 2 : n + n / 2 - 1 ) = Y do i = 1 , n Z ( i ) = sum ( X ( n : 1 : - 1 ) * Y_in ( i : i + n - 1 )) end do deallocate ( Y_in ) case ( 'fft' ) allocate ( X_in ( n * 2 - 1 )) allocate ( Y_in ( n * 2 - 1 )) allocate ( Z_in ( n * 2 - 1 )) X_in = czero Y_in = czero X_in ( 1 : n ) = X Y_in ( 1 : n / 2 ) = Y ( n / 2 + 1 : n ) Y_in ( n * 2 - n / 2 : n * 2 - 1 ) = Y ( 1 : n / 2 ) call do_mkl_dfti_conv ( n * 2 - 1 , Y_in , X_in , Z_in ) Z = Z_in ( 1 : n ) deallocate ( X_in , Y_in , Z_in ) end select end function conv1d2","tags":"","loc":"proc/conv1d2.html"},{"title":"do_mkl_dfti_conv – Quantum transport simulator","text":"public  subroutine do_mkl_dfti_conv(n, X_in, Y_in, Z_out) Uses MKL_DFTI proc~~do_mkl_dfti_conv~~UsesGraph proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv module~mkl_dfti MKL_DFTI proc~do_mkl_dfti_conv->module~mkl_dfti module~mkl_dft_type MKL_DFT_TYPE module~mkl_dfti->module~mkl_dft_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer :: n complex(kind=8) :: X_in (n) complex(kind=8) :: Y_in (n) complex(kind=8) :: Z_out (n) Calls proc~~do_mkl_dfti_conv~~CallsGraph proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv interface~dfticommitdescriptor MKL_DFTI::DftiCommitDescriptor proc~do_mkl_dfti_conv->interface~dfticommitdescriptor interface~dfticomputebackward MKL_DFTI::DftiComputeBackward proc~do_mkl_dfti_conv->interface~dfticomputebackward interface~dfticomputeforward MKL_DFTI::DftiComputeForward proc~do_mkl_dfti_conv->interface~dfticomputeforward interface~dfticreatedescriptor MKL_DFTI::DftiCreateDescriptor proc~do_mkl_dfti_conv->interface~dfticreatedescriptor interface~dftifreedescriptor MKL_DFTI::DftiFreeDescriptor proc~do_mkl_dfti_conv->interface~dftifreedescriptor interface~dftisetvalue MKL_DFTI::DftiSetValue proc~do_mkl_dfti_conv->interface~dftisetvalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~do_mkl_dfti_conv~~CalledByGraph proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~conv1d fft_mod::conv1d proc~conv1d->proc~do_mkl_dfti_conv proc~conv1d2 fft_mod::conv1d2 proc~conv1d2->proc~do_mkl_dfti_conv proc~corr1d fft_mod::corr1d proc~corr1d->proc~do_mkl_dfti_conv proc~corr1d2 fft_mod::corr1d2 proc~corr1d2->proc~do_mkl_dfti_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code do_mkl_dfti_conv Source Code subroutine do_mkl_dfti_conv ( n , X_in , Y_in , Z_out ) ! 1D complex to complex Use MKL_DFTI integer :: n Complex ( 8 ) :: X_in ( n ), Y_in ( n ), Z_out ( n ) Complex ( 8 ) :: X_out ( n ), Y_out ( n ), Z_in ( n ) type ( DFTI_DESCRIPTOR ), POINTER :: My_Desc1_Handle , My_Desc2_Handle Integer :: Status ! Perform a complex to complex transform Status = DftiCreateDescriptor ( My_Desc1_Handle , DFTI_DOUBLE , DFTI_COMPLEX , 1 , n ) Status = DftiSetValue ( My_Desc1_Handle , DFTI_PLACEMENT , DFTI_NOT_INPLACE ) Status = DftiCommitDescriptor ( My_Desc1_Handle ) Status = DftiComputeForward ( My_Desc1_Handle , X_in , X_out ) Status = DftiComputeForward ( My_Desc1_Handle , Y_in , Y_out ) ! Z_in (:) = X_out (:) * Y_out (:) ! Status = DftiComputeBackward ( My_Desc1_Handle , Z_in , Z_out ) Status = DftiFreeDescriptor ( My_Desc1_Handle ) Z_out (:) = Z_out (:) / dble ( n ) end subroutine do_mkl_dfti_conv","tags":"","loc":"proc/do_mkl_dfti_conv.html"},{"title":"sancho – Quantum transport simulator","text":"public  subroutine sancho(nm, E, S00, H00, H10, G00, GBB) Uses linalg cublas proc~~sancho~~UsesGraph proc~sancho cuda_rgf_mod::sancho cublas cublas proc~sancho->cublas module~linalg linalg proc~sancho->module~linalg module~linalg->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer :: nm real(kind=dp) :: E complex(kind=dp), intent(in) :: S00 (nm,nm) complex(kind=dp), intent(in) :: H00 (nm,nm) complex(kind=dp), intent(in) :: H10 (nm,nm) complex(kind=dp), intent(out) :: G00 (nm,nm) complex(kind=dp), intent(out) :: GBB (nm,nm) Calls proc~~sancho~~CallsGraph proc~sancho cuda_rgf_mod::sancho proc~invert~2 linalg::invert proc~sancho->proc~invert~2 zgemm zgemm proc~sancho->zgemm zgetrf zgetrf proc~invert~2->zgetrf zgetri zgetri proc~invert~2->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code sancho Source Code subroutine sancho ( nm , E , S00 , H00 , H10 , G00 , GBB ) use cublas use linalg , only : invert integer i , j , k , nm , nmax COMPLEX ( dp ) :: z real ( dp ) :: E , error REAL ( dp ) :: TOL = 1.0D-100 ! [eV] COMPLEX ( dp ), INTENT ( IN ) :: S00 ( nm , nm ), H00 ( nm , nm ), H10 ( nm , nm ) COMPLEX ( dp ), INTENT ( OUT ) :: G00 ( nm , nm ), GBB ( nm , nm ) COMPLEX ( dp ), ALLOCATABLE :: A (:, :), B (:, :), C (:, :), tmp (:, :) COMPLEX ( dp ), ALLOCATABLE :: H_BB (:, :), H_SS (:, :), H_01 (:, :), H_10 (:, :), Id (:, :) COMPLEX ( dp ), EXTERNAL :: ZLANGE complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) ! Allocate ( H_BB ( nm , nm )) Allocate ( H_SS ( nm , nm )) Allocate ( H_01 ( nm , nm )) Allocate ( H_10 ( nm , nm )) Allocate ( Id ( nm , nm )) Allocate ( A ( nm , nm )) Allocate ( B ( nm , nm )) Allocate ( C ( nm , nm )) Allocate ( tmp ( nm , nm )) nmax = 50 z = dcmplx ( E , 1.0d-5 ) Id = dcmplx ( 0.0d0 , 0.0d0 ) tmp = 0.0d0 do i = 1 , nm Id ( i , i ) = 1.0d0 tmp ( i , i ) = dcmplx ( 0.0d0 , 1.0d0 ) end do H_BB = H00 H_10 = H10 H_01 = TRANSPOSE ( CONJG ( H_10 )) H_SS = H00 do i = 1 , nmax A = z * S00 - H_BB call invert ( A , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H_10 , nm , beta , B , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_SS = H_SS + C H_BB = H_BB + C call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , C , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H_01 , nm , beta , B , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , A , nm ) H_10 = C H_BB = H_BB + A call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_01 = C ! NORM --> inspect the diagonal of A error = 0.0d0 DO k = 1 , nm DO j = 1 , nm error = error + sqrt ( aimag ( C ( k , j )) ** 2 + Dble ( C ( k , j )) ** 2 ) END DO END DO !write(90,*)E,i,error tmp = H_SS IF ( abs ( error ) < TOL ) THEN !write(90,*) 'SR: Exited, abs(error)=',i,abs(error) EXIT ELSE END IF IF ( i . EQ . nmax ) THEN write ( * , * ) 'SEVERE warning: nmax reached in sancho!!!' , error END IF end do G00 = z * S00 - H_SS call invert ( G00 , nm ) ! GBB = z * S00 - H_BB call invert ( GBB , nm ) ! Deallocate ( tmp ) Deallocate ( A ) Deallocate ( B ) Deallocate ( C ) Deallocate ( H_BB ) Deallocate ( H_SS ) Deallocate ( H_01 ) Deallocate ( H_10 ) Deallocate ( Id ) end subroutine sancho","tags":"","loc":"proc/sancho.html"},{"title":"write_spectrum_summed_over_k – Quantum transport simulator","text":"public  subroutine write_spectrum_summed_over_k(dataset, i, G, nen, en, nk, length, NB, NS, Lx, coeff, append) !$omp parallel default(shared) private(ik, ib) reduction(+:tr)\n!$omp do\n!$omp end do\n!$omp end parallel Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dataset integer, intent(in) :: i type( type_matrix_complex ), intent(in), dimension(length, nen, nk) :: G integer, intent(in) :: nen real(kind=dp), intent(in) :: en (nen) integer, intent(in) :: nk integer, intent(in) :: length integer, intent(in) :: NB integer, intent(in) :: NS real(kind=dp), intent(in) :: Lx real(kind=dp), intent(in) :: coeff (2) logical, intent(in), optional :: append Called by proc~~write_spectrum_summed_over_k~~CalledByGraph proc~write_spectrum_summed_over_k Output::write_spectrum_summed_over_k proc~negf_solve negf_mod::negf_solve proc~negf_solve->proc~write_spectrum_summed_over_k program~main main program~main->proc~negf_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code write_spectrum_summed_over_k Source Code subroutine write_spectrum_summed_over_k ( dataset , i , G , nen , en , nk , length , NB , NS , Lx , coeff , append ) character ( len =* ), intent ( in ) :: dataset type ( type_matrix_complex ), intent ( in ), dimension ( length , nen , nk ) :: G integer , intent ( in ) :: i , nen , length , NB , NS , nk real ( dp ), intent ( in ) :: Lx , en ( nen ), coeff ( 2 ) logical , intent ( in ), optional :: append ! ---- integer :: ix , ie , j , ib , k , ik character ( len = 4 ) :: i_str character ( len = 8 ) :: fmt real ( dp ) :: xx complex ( dp ) :: tr logical append_ append_ = . false . if ( present ( append )) append_ = append fmt = '(I4.4)' write ( i_str , fmt ) i if ( append_ ) then open ( unit = 11 , file = trim ( dataset ) // i_str // '.dat' , status = 'unknown' , position = 'append' ) else open ( unit = 11 , file = trim ( dataset ) // i_str // '.dat' , status = 'unknown' ) end if ! do ie = 1 , nen xx = 0.0d0 ix = 0 do j = 1 , length do k = 1 , NS ix = ix + 1 xx = xx + Lx tr = 0.0d0 !!!$omp parallel default(shared) private(ik, ib) reduction(+:tr) !!!$omp do do ik = 1 , nk do ib = 1 , nb tr = tr + G ( j , ie , ik )% m ( ib + ( k - 1 ) * NB , ib + ( k - 1 ) * NB ) end do end do !!!$omp end do !!!$omp end parallel tr = tr / dble ( nk ) write ( 11 , '(4E18.4)' ) xx , en ( ie ), dble ( tr ) * coeff ( 1 ), aimag ( tr ) * coeff ( 2 ) end do end do write ( 11 , * ) end do close ( 11 ) end subroutine write_spectrum_summed_over_k","tags":"","loc":"proc/write_spectrum_summed_over_k.html"},{"title":"getPointsInAllSlices – Quantum transport simulator","text":"public  function getPointsInAllSlices(S) result(v) Function returns the points in all the slices Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information Return Value integer, (sum(S(1,:))-size(S,2)) Contents Source Code getPointsInAllSlices Source Code function getPointsInAllSlices ( S ) result ( v ) !! Function returns the points in all the slices implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer :: v ( sum ( S ( 1 , :)) - size ( S , 2 )) integer :: i , n n = 0 do i = 1 , size ( S , 2 ) v ( n + 1 : n + S ( 1 , i ) - 1 ) = S ( 2 : S ( 1 , i ), i ) n = n + S ( 1 , i ) - 1 end do end function getPointsInAllSlices","tags":"","loc":"proc/getpointsinallslices.html"},{"title":"getPointsInSlice – Quantum transport simulator","text":"public  function getPointsInSlice(S, i) result(v) Function returns the points in a slice number i Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information integer, intent(in) :: i Slice number Return Value integer, (S(1,i)-1) Contents Source Code getPointsInSlice Source Code function getPointsInSlice ( S , i ) result ( v ) !! Function returns the points in a slice number `i` implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer , intent ( in ) :: i !! Slice number integer :: v ( S ( 1 , i ) - 1 ) v (:) = S ( 2 : S ( 1 , i ), i ) end function getPointsInSlice","tags":"","loc":"proc/getpointsinslice.html"},{"title":"testSlicing – Quantum transport simulator","text":"public  function testSlicing(g, S) result(b) Function tests if a slicing from subroutine slice of the graph is consistent by\nlooking at the neighbors of all the points in each slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: S (:,:) Slices, 2nd index is the Slice number Return Value integer Test result Contents Source Code testSlicing Source Code function testSlicing ( g , S ) result ( b ) !! Function tests if a slicing from subroutine [[slice]]  of the graph is consistent by !! looking at the neighbors of all the points in each slice. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer :: b !! Test result integer , intent ( in ) :: S (:, :) !! Slices, 2nd index is the Slice number integer :: L ( size ( g , 2 )) !! Slice number of points integer :: i , k , j , err L = - 1 L = SliceNum ( S ) IF ( ANY ( L == - 1 )) then b = - 1 ! Not all points belong to a slice return end if do i = 1 , size ( S , 2 ) ! Loop over the slices do j = 2 , S ( 1 , i ) ! Loop over the points in one slice do k = 2 , g ( 1 , S ( j , i )) ! Loop over all its neighbor points if ( abs ( L ( g ( k , S ( j , i ))) - i ) > 1 ) then b = i ! It connects to a points too far print '(4I18)' , L ( g ( k , S ( j , i ))), g ( k , S ( j , i )), i , S ( j , i ) return end if end do end do end do b = 0 end Function testSlicing","tags":"","loc":"proc/testslicing.html"},{"title":"SaveSlicesTxt – Quantum transport simulator","text":"public  subroutine SaveSlicesTxt(handle, S, X, Y, Z) Procedure saves the slice information into a text file Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle file unit number integer, intent(in) :: S (:,:) Slices information real(kind=dp), intent(in), optional :: X (:) real(kind=dp), intent(in), optional :: Y (:) real(kind=dp), intent(in), optional :: Z (:) Contents Source Code SaveSlicesTxt Source Code subroutine SaveSlicesTxt ( handle , S , X , Y , Z ) !! Procedure saves the slice information into a text file implicit none integer , intent ( in ) :: handle !! file unit number integer , intent ( in ) :: S (:, :) !! Slices information real ( dp ), intent ( in ), optional :: X (:) real ( dp ), intent ( in ), optional :: Y (:) real ( dp ), intent ( in ), optional :: Z (:) integer :: i , j write ( handle , * ) '# number of points in each slice' write ( handle , '(8I10)' ) S ( 1 , :) - 1 ! number of points in each slice if ( present ( X ) . and . present ( Y ) . and . present ( Z )) then write ( handle , * ) '#     X         Y         Z       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(3E15.5,I10)' ) X ( S ( j , i )), Y ( S ( j , i )), Z ( S ( j , i )), i end do end do else write ( handle , * ) '#    Point#       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(2I10)' ) S ( j , i ), i end do end do end if end subroutine SaveSlicesTxt","tags":"","loc":"proc/saveslicestxt.html"},{"title":"AddEdge – Quantum transport simulator","text":"public  subroutine AddEdge(g, ij) Subroutine update the graph data (g) by adding an edge from node-i to node-j.\nThe memory space for (g) is already allocated before calling this procedure Arguments Type Intent Optional Attributes Name integer, intent(out) :: g (:,:) integer, intent(in) :: ij (2) Called by proc~~addedge~~CalledByGraph proc~addedge graph_partition::AddEdge proc~readgraphfromtext graph_partition::ReadGraphFromText proc~readgraphfromtext->proc~addedge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code AddEdge Source Code subroutine AddEdge ( g , ij ) !! Subroutine update the graph data (g) by adding an edge from node-i to node-j. !! The memory space for (g) is already allocated before calling this procedure implicit none integer , intent ( out ) :: g (:, :) integer , intent ( in ) :: ij ( 2 ) ! Find if this Edge is already present in the graph, avoiding duplicates if ( ANY ( g ( 2 : g ( 1 , ij ( 1 )), ij ( 1 )) == ij ( 2 ))) then return else g ( 1 , ij ( 1 )) = g ( 1 , ij ( 1 )) + 1 g ( 1 , ij ( 2 )) = g ( 1 , ij ( 2 )) + 1 g ( g ( 1 , ij ( 2 )), ij ( 2 )) = ij ( 1 ) g ( g ( 1 , ij ( 1 )), ij ( 1 )) = ij ( 2 ) end if end subroutine AddEdge","tags":"","loc":"proc/addedge.html"},{"title":"ReadEdgeFromText – Quantum transport simulator","text":"public  subroutine ReadEdgeFromText(fname, E, use0index) Subroutine for reading the edge data from an ASCII text file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: E (:) Edge index logical, intent(in), optional :: use0index Contents Source Code ReadEdgeFromText Source Code subroutine ReadEdgeFromText ( fname , E , use0index ) !! Subroutine for reading the edge data from an ASCII text file. implicit none integer , allocatable , intent ( out ) :: E (:) !! Edge index character ( len =* ), intent ( in ) :: fname !! input text file name logical , intent ( in ), optional :: use0index integer :: NPT , i integer , parameter :: handle = 677 logical :: l0index l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) read ( handle , * ) NPT ! number of points allocate ( E ( NPT )) read ( handle , * ) E (:) if ( l0index ) E (:) = E (:) + 1 !do i=1,NPT !        read(handle,*) E(i) !        if (l0index) then !          E(i) = E(i)+1 !        endif !enddo close ( handle ) end subroutine ReadEdgeFromText","tags":"","loc":"proc/readedgefromtext.html"},{"title":"ReadGraphFromText – Quantum transport simulator","text":"public  subroutine ReadGraphFromText(fname, g, threshold, use0index) Subroutine for reading in the graph data from an ASCII text file. Note The graph connectivity table is stored in a 2D integer array g(:,:) which\nis allocated inside this subroutine, so remember to deallocate it outside.\nThe 2nd index of g(:,:) refers to the point ID and 'g(1,:)-1' is the number of connections\nof the point. The text file should contain 2 columns of integers which are the point\nIDs of 2 connected points in the graph. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: g (:,:) Graph connectivity table. real(kind=8), intent(in), optional :: threshold logical, intent(in), optional :: use0index Calls proc~~readgraphfromtext~~CallsGraph proc~readgraphfromtext graph_partition::ReadGraphFromText proc~addedge graph_partition::AddEdge proc~readgraphfromtext->proc~addedge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code ReadGraphFromText Source Code subroutine ReadGraphFromText ( fname , g , threshold , use0index ) !! Subroutine for reading in the graph data from an ASCII text file. !! !! @note The graph connectivity table is stored in a 2D integer array `g(:,:)` which !! is allocated inside this subroutine, so remember to deallocate it outside. !! The 2nd index of `g(:,:)` refers to the point ID and 'g(1,:)-1' is the number of connections !! of the point. The text file should contain 2 columns of integers which are the point !! IDs of 2 connected points in the graph. !! implicit none integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table. character ( len =* ), intent ( in ) :: fname !! input text file name real ( 8 ), intent ( in ), optional :: threshold logical , intent ( in ), optional :: use0index integer , allocatable :: gn (:) !! Temporary array for sizing the Graph Table integer :: i , j , k !! Looping variables integer :: NL !! Number of lines in the text file integer :: IO !! IO state during reading integer :: M !! Number of points in the graph integer :: NC integer , parameter :: handle = 675 logical :: l0index real ( 8 ) :: weight l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of points in the graph do read ( handle , * , IOSTAT = IO ) i , j if ( l0index ) then i = i + 1 j = j + 1 end if if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of Points = \",i18)' , M allocate ( gn ( M )) gn = 0 ! Read again the file to know about the size of the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if else gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if end do NC = maxval ( gn ) print '(\"Max Number of Connections = \",i18)' , NC allocate ( g ( NC + 1 , M )) g (:, :) = 0 g ( 1 , :) = 1 deallocate ( gn ) ! Read last time the file for the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( i . ne . j ) then if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then call AddEdge ( g , ( / i , j / )) end if else call AddEdge ( g , ( / i , j / )) end if end if end do close ( handle ) end subroutine ReadGraphFromText","tags":"","loc":"proc/readgraphfromtext.html"},{"title":"SaveTxtGraph – Quantum transport simulator","text":"public  subroutine SaveTxtGraph(handle, g) Subroutine for saving the graph data into an ASCII text file. Note The 1st column is the point ID, and the following columns are the connecting points' ID. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle Unit number of the input text file integer, intent(in) :: g (:,:) Graph connectivity table. Contents Source Code SaveTxtGraph Source Code subroutine SaveTxtGraph ( handle , g ) !! Subroutine for saving the graph data into an ASCII text file. !! !! @note The 1st column is the point ID, and the following columns are the connecting points' ID. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ), optional :: handle !! Unit number of the input text file character ( len = 1024 ) :: str !! String for FORMAT writing integer :: i !! Looping variable write ( str , \"(I10)\" ) size ( g , 1 ) + 1 if ( present ( handle )) then do i = 1 , size ( g , 2 ) write ( handle , '(' // trim ( adjustl ( str )) // 'i10)' ) i , g ( 2 : g ( 1 , i ), i ) end do else do i = 1 , size ( g , 2 ) print '(' // trim ( adjustl ( str )) // 'i10)' , i , g ( 2 : g ( 1 , i ), i ) end do end if end subroutine SaveTxtGraph","tags":"","loc":"proc/savetxtgraph.html"},{"title":"convert_fromCOO – Quantum transport simulator","text":"public  subroutine convert_fromCOO(nnz, row, col, g) Subroutine convert a sparse matrix in COO format into a graph\n  The graph will be allocated inside the subroutine, so remember to deallocate the memory outside Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnz integer, intent(in), dimension(nnz) :: row IA and JA index vectors of a CSR matrix integer, intent(in), dimension(nnz) :: col IA and JA index vectors of a CSR matrix integer, intent(out), allocatable :: g (:,:) Graph connectivity table Contents Source Code convert_fromCOO Source Code subroutine convert_fromCOO ( nnz , row , col , g ) !! Subroutine convert a sparse matrix in COO format into a graph !!   The graph will be allocated inside the subroutine, so remember to deallocate the memory outside implicit none integer , intent ( in ) :: nnz integer , intent ( in ), dimension ( nnz ) :: row , col !! IA and JA index vectors of a CSR matrix integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table end subroutine convert_fromCOO","tags":"","loc":"proc/convert_fromcoo.html"},{"title":"slice – Quantum transport simulator","text":"public interface slice Contents Module Procedures slice_1contact slice_2contacts Module Procedures private  subroutine slice_1contact(g, E, S) Procedure returns the slices of the graph going from 1 edge. BFS algorithm is used to\nassign a distance to the edge for each point, then the slice number = distance. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E (:) Left Edge points' IDs integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number private recursive subroutine slice_2contacts(g, E1, E2, NMAX, S) Function returns the slices of the graph. The problem is solved in a divide-and-conquer\nmanner, using recursive bisection method described in [Journal of Computational Physics 228 (2009) 8548–8565]. Compute the left/right distance of points to left/right edges, by calling [[dist]] Divide the graph into 2 'balanced' parts, based on if the right distance is larger than the left distance Find the connections between 2 parts, and define a new set of edges Recursion, Slice seperately the 2 parts Combine the results Stop condition: either the 2 edges touch each other, or the number of points in the remaining part gets\nsmall enough. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E1 (:) Left Edge points' IDs integer, intent(in) :: E2 (:) RightEdge points' IDs integer, intent(in) :: NMAX Maximum number of points in a single slice integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number","tags":"","loc":"interface/slice.html"},{"title":"rgf_variableblock_forward – Quantum transport simulator","text":"public  subroutine rgf_variableblock_forward(nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) Uses linalg matrix_c proc~~rgf_variableblock_forward~~UsesGraph proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward module~linalg linalg proc~rgf_variableblock_forward->module~linalg module~matrix_c matrix_c proc~rgf_variableblock_forward->module~matrix_c cublas cublas module~linalg->cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. !$omp critical\n        open (unit=10, file='sancho_g00.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(G00))\n        close (10)\n        open (unit=10, file='sancho_gbb.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(Gbb))\n        close (10)\n!$omp end critical !$omp critical\n        open (unit=10, file='sancho_g00.dat', position='append')\n        write (10, ) En, 1, -aimag(trace(G00))\n        close (10)\n        open (unit=10, file='sancho_gbb.dat', position='append')\n        write (10, ) En, 1, -aimag(trace(Gbb))\n        close (10)\n!$omp end critical Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) type( type_matrix_complex ), intent(inout) :: Gl (nx) type( type_matrix_complex ), intent(inout) :: Gln (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre Calls proc~~rgf_variableblock_forward~~CallsGraph proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward omp_get_wtime omp_get_wtime proc~rgf_variableblock_forward->omp_get_wtime proc~invert~2 linalg::invert proc~rgf_variableblock_forward->proc~invert~2 proc~mul_c matrix_c::MUL_C proc~rgf_variableblock_forward->proc~mul_c proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_forward->proc~trimul_c zgetrf zgetrf proc~invert~2->zgetrf zgetri zgetri proc~invert~2->zgetri zgemm zgemm proc~mul_c->zgemm proc~trimul_c->proc~mul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code rgf_variableblock_forward Source Code subroutine rgf_variableblock_forward ( nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) use matrix_c , only : type_matrix_complex , MUL_C , triMUL_C , trace use linalg , only : invert type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ), Gl ( nx ), Gln ( nx ) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: M , ii , jj complex ( dp ) :: z real ( dp ) :: tim , start , finish , start_0 complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) ! z = dcmplx ( En , 0.0d0 ) ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmal ( M , M )) allocate ( sig ( M , M )) ! start = omp_get_wtime () start_0 = start ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B H10 = H1i ( ii )% m call sancho ( M , En , Sii ( ii )% m , H00 , transpose ( conjg ( H10 )), G00 , GBB ) !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical ! !! \\Sigma&#94;R = H(i,i+1) * G00 * H(i+1,i) !! Gl(i) = [E*S(i,i) - H00 - \\Sigma_R]&#94;{-1} call triMUL_c ( H10 , G00 , H10 , sigmal , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmal call invert ( B , M ) Gl ( ii )% m = B ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + (-(\\Sigma&#94;R - \\Sigma_R&#94;\\dagger)*ferm(..))] * Gl(i)&#94;\\dagger call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig , H10 ) ! finish = omp_get_wtime () print * , \"--- left contact took seconds\" , finish - start start = finish ! allocate ( A ( M , M )) ! inside device l -> r do ii = 2 , nx - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) !! Gl(i) = [E*S(i,i) - H00 - H(i,i-1) * Gl(i-1) * H(i-1,i)]&#94;{-1} call triMUL_c ( H1i ( ii )% m , Gl ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B call invert ( A , M ) Gl ( ii )% m = A ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)&#94;\\dagger call triMUL_c ( H1i ( ii )% m , Gln ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! finish = omp_get_wtime () print * , \"--- first pass took seconds\" , finish - start start = finish ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmar ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = H1i ( nx + 1 )% m ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H10 , G00 , H10 , sigmar , 'c' , 'n' , 'n' ) ! !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical ! call triMUL_c ( H1i ( nx )% m , Gl ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B - sigmar ! call invert ( A , M ) G_r ( ii )% m = A Gl ( ii )% m = A ! !! \\Sigma&#94;< = \\Sigma_11&#94;< + \\Sigma_{ph}&#94;< + \\Sigma_s&#94;< call triMUL_c ( H1i ( nx )% m , Gln ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( nx )% m , Sii ( nx )% m , 'n' , 'n' , A ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !! G&#94;< = G * \\Sigma&#94;< * G&#94;\\dagger call triMUL_c ( G_r ( ii )% m , sig , G_r ( ii )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( ii )% m = B G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) ! A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) ! Jdens ( ii )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( ii )% m ( jj , jj )) end do tr = tim ! transmission deallocate ( sigmar , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! finish = omp_get_wtime () print * , \"--- right contact took seconds\" , finish - start start = finish ! ! inside device r -> l do ii = nx - 1 , 1 , - 1 M = size ( Hii ( ii )% m , 1 ) !! A = G&#94;<(i+1) * H(i+1,i) * Gl(i)&#94;\\dagger + G(i+1) * H(i+1,i) * Gln(i) call triMUL_c ( G_lesser ( ii + 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii + 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !! B = H(i,i+1) * A !! Jdens(i) = -2 * B call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * B (:, :) ! !! GN0 = Gl(i) * H(i,i+1) * G(i+1) !! G(i) = Gl(i) + GN0 * H(i+1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii + 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !! G&#94;<(i) = Gln(i) + Gl(i) * H(i,i+1) * G&#94;<(i+1) * H(i+1,i) *Gl(i)&#94;\\dagger call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii + 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + GN0 * H(i+1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + Gln(i) * H(i,i+1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;>(i) = G&#94;<(i) + [G(i) - G(i)&#94;\\dagger] G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ! finish = omp_get_wtime () print * , \"--- second pass took seconds\" , finish - start start = finish ! ii = 1 ! on the left contact A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tre = tim deallocate ( B , A , C , GN0 , sigmal ) ! end subroutine rgf_variableblock_forward","tags":"","loc":"proc/rgf_variableblock_forward.html"},{"title":"rgf_variableblock_backward – Quantum transport simulator","text":"public  subroutine rgf_variableblock_backward(nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) Uses linalg matrix_c proc~~rgf_variableblock_backward~~UsesGraph proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward module~linalg linalg proc~rgf_variableblock_backward->module~linalg module~matrix_c matrix_c proc~rgf_variableblock_backward->module~matrix_c cublas cublas module~linalg->cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. !$omp critical\n       open (unit=10, file='sancho_g00.dat', position='append')\n       write (10, ) En, 2, -aimag(trace(G00))\n       close (10)\n       open (unit=10, file='sancho_gbb.dat', position='append')\n       write (10, ) En, 2, -aimag(trace(Gbb))\n       close (10)\n       !$omp end critical !$omp critical\n       open (unit=10, file='sancho_g00.dat', position='append')\n       write (10, ) En, 1, -aimag(trace(G00))\n       close (10)\n       open (unit=10, file='sancho_gbb.dat', position='append')\n       write (10, ) En, 1, -aimag(trace(Gbb))\n       close (10)\n       !$omp end critical Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) type( type_matrix_complex ), intent(inout) :: Gl (nx) type( type_matrix_complex ), intent(inout) :: Gln (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre Calls proc~~rgf_variableblock_backward~~CallsGraph proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~invert~2 linalg::invert proc~rgf_variableblock_backward->proc~invert~2 proc~mul_c matrix_c::MUL_C proc~rgf_variableblock_backward->proc~mul_c proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_backward->proc~trimul_c zgetrf zgetrf proc~invert~2->zgetrf zgetri zgetri proc~invert~2->zgetri zgemm zgemm proc~mul_c->zgemm proc~trimul_c->proc~mul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code rgf_variableblock_backward Source Code subroutine rgf_variableblock_backward ( nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) use matrix_c , only : type_matrix_complex , MUL_C , triMUL_C , trace use linalg , only : invert type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ), Gl ( nx ), Gln ( nx ) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: M , ii , jj complex ( dp ) :: z real ( dp ) :: tim complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) z = dcmplx ( En , 0.0d0 ) ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmar ( M , M )) allocate ( sig ( M , M )) ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B call sancho ( M , En , Sii ( ii )% m , H00 , H1i ( ii + 1 )% m , G00 , GBB ) !!        !$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(Gbb)) !!        close (10) !!        !$omp end critical ! !! \\Sigma&#94;R = H(i,i+1) * G00 * H(i+1,i) !! Gl(i) = [E*S(i,i) - H00 - \\Sigma_R]&#94;{-1} call triMUL_c ( H1i ( ii + 1 )% m , G00 , H1i ( ii + 1 )% m , sigmar , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmar call invert ( B , M ) Gl ( ii )% m = B ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + (-(\\Sigma&#94;R - \\Sigma_R&#94;\\dagger)*ferm(..))] * Gl(i)&#94;\\dagger call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig ) ! allocate ( A ( M , M )) ! inside device r -> l do ii = nx - 1 , 2 , - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) !! Gl(i) = [E*S(i,i) - H00 - H(i,i+1) * Gl(i+1) * H(i+1,i)]&#94;{-1} call triMUL_c ( H1i ( ii + 1 )% m , Gl ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B call invert ( A , M ) Gl ( ii )% m = A ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)&#94;\\dagger call triMUL_c ( H1i ( ii + 1 )% m , Gln ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmal ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = transpose ( conjg ( H1i ( 1 )% m )) ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H1i ( 1 )% m , G00 , H1i ( 1 )% m , sigmal , 'c' , 'n' , 'n' ) ! !!        !$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(Gbb)) !!        close (10) !!        !$omp end critical ! call triMUL_c ( H1i ( 2 )% m , Gl ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( 1 )% m - H00 - B - sigmal ! call invert ( A , M ) G_r ( 1 )% m = A Gl ( 1 )% m = G_r ( 1 )% m ! !! \\Sigma&#94;< = \\Sigma_11&#94;< + \\Sigma_{ph}&#94;< + \\Sigma_s&#94;< call triMUL_c ( H1i ( 2 )% m , Gln ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( 1 )% m , Sii ( 1 )% m , 'n' , 'n' , A ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !! G&#94;< = G * \\Sigma&#94;< * G&#94;\\dagger call triMUL_c ( G_r ( 1 )% m , sig , G_r ( 1 )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( 1 )% m = B G_greater ( 1 )% m = G_lesser ( 1 )% m + ( G_r ( 1 )% m - transpose ( conjg ( G_r ( 1 )% m ))) ! A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( 1 )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( 1 )% m , 'n' , 'n' , C ) ! Jdens ( 1 )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( 1 )% m ( jj , jj )) end do tre = tim deallocate ( sigmal , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! inside device l -> r do ii = 2 , nx M = size ( Hii ( ii )% m , 1 ) !! A = G&#94;<(i-1) * H(i-1,i) * Gl(i)&#94;\\dagger + G(i-1) * H(i-1,i) * Gln(i) call triMUL_c ( G_lesser ( ii - 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii - 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !! B = H(i,i-1) * A !! Jdens(i) = -2 * re(B) call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * B (:, :) ! !! GN0 = Gl(i) * H(i,i-1) * G(i-1) !! G(i) = Gl(i) + GN0 * H(i-1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii - 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !! G&#94;<(i) = Gln(i) + Gl(i) * H(i,i-1) * G&#94;<(i-1) * H(i-1,i) *Gl(i)&#94;\\dagger call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii - 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + GN0 * H(i-1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + Gln(i) * H(i,i-1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;>(i) = G&#94;<(i) + [G(i) - G(i)&#94;\\dagger] G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ii = nx ! on the right contact A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tr = tim deallocate ( B , A , C , GN0 , sigmar ) ! end subroutine rgf_variableblock_backward","tags":"","loc":"proc/rgf_variableblock_backward.html"},{"title":"array_eye – Quantum transport simulator","text":"public pure function array_eye(n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n) Called by proc~~array_eye~~CalledByGraph proc~array_eye matrix_c::array_eye interface~eye matrix_c::eye interface~eye->proc~array_eye proc~array_power matrix_c::array_power proc~array_power->proc~array_eye interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_eye Source Code pure function array_eye ( n ) result ( R ) implicit none integer , intent ( in ) :: n complex ( 8 ) :: R ( n , n ) INTEGER :: ii R = dcmplx ( 0.0d0 , 0.0d0 ) forall ( ii = 1 : n ) R ( ii , ii ) = dcmplx ( 1.0d0 , 0.0d0 ) end function array_eye","tags":"","loc":"proc/array_eye.html"},{"title":"matrix_list_size – Quantum transport simulator","text":"public pure function matrix_list_size(list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) Called by proc~~matrix_list_size~~CalledByGraph proc~matrix_list_size matrix_c::matrix_list_size interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_list_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_size Source Code pure function matrix_list_size ( list , dim ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) integer , intent ( in ) :: dim INTEGER :: nm ( size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm ( ii ) = list ( ii )% size ( dim ) end function matrix_list_size","tags":"","loc":"proc/matrix_list_size.html"},{"title":"matrix_list_size2 – Quantum transport simulator","text":"public pure function matrix_list_size2(list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list)) Called by proc~~matrix_list_size2~~CalledByGraph proc~matrix_list_size2 matrix_c::matrix_list_size2 interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_list_size2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_size2 Source Code pure function matrix_list_size2 ( list ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) INTEGER :: nm ( 2 , size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm (:, ii ) = list ( ii )% size (:) end function matrix_list_size2","tags":"","loc":"proc/matrix_list_size2.html"},{"title":"array_size – Quantum transport simulator","text":"public pure function array_size(this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) Called by proc~~array_size~~CalledByGraph proc~array_size matrix_c::array_size interface~sizeof matrix_c::sizeof interface~sizeof->proc~array_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_size Source Code pure function array_size ( this ) result ( s ) implicit none complex ( 8 ), intent ( in ) :: this (:, :) integer :: s ( 2 ), ii FORALL ( ii = 1 : 2 ) s ( ii ) = size ( this , dim = ii ) end function array_size","tags":"","loc":"proc/array_size.html"},{"title":"matrix_size – Quantum transport simulator","text":"public pure function matrix_size(this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) Called by proc~~matrix_size~~CalledByGraph proc~matrix_size matrix_c::matrix_size interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_size Source Code pure function matrix_size ( this ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer :: s ( 2 ) s (:) = this % size end function matrix_size","tags":"","loc":"proc/matrix_size.html"},{"title":"matrix_size_dim – Quantum transport simulator","text":"public pure function matrix_size_dim(this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer Called by proc~~matrix_size_dim~~CalledByGraph proc~matrix_size_dim matrix_c::matrix_size_dim interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_size_dim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_size_dim Source Code pure function matrix_size_dim ( this , dim ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: s s = this % size ( dim ) end function matrix_size_dim","tags":"","loc":"proc/matrix_size_dim.html"},{"title":"array_testHermitian – Quantum transport simulator","text":"public pure function array_testHermitian(M) result(b) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: M (:,:) Return Value logical Contents Source Code array_testHermitian Source Code pure function array_testHermitian ( M ) result ( b ) implicit none complex ( 8 ), intent ( in ) :: M (:, :) logical :: b integer :: i , j real ( 8 ), parameter :: TOL = 1.0D-10 b = . true . do i = 1 , size ( M , 2 ) do j = 1 , i if ( abs ( M ( i , j ) - conjg ( M ( j , i ))) . gt . TOL ) then b = . false . return end if end do end do end function array_testHermitian","tags":"","loc":"proc/array_testhermitian.html"},{"title":"array_times_array_dagger – Quantum transport simulator","text":"public pure function array_times_array_dagger(A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1)) Calls proc~~array_times_array_dagger~~CallsGraph proc~array_times_array_dagger matrix_c::array_times_array_dagger proc~array_times_array matrix_c::array_times_array proc~array_times_array_dagger->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_times_array_dagger~~CalledByGraph proc~array_times_array_dagger matrix_c::array_times_array_dagger interface~operator(.md.) matrix_c::operator(.md.) interface~operator(.md.)->proc~array_times_array_dagger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_times_array_dagger Source Code pure function array_times_array_dagger ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 1 )) C = array_times_array ( A , B , trA = . false ., trB = . true ., cjA = . false ., cjB = . true .) end function array_times_array_dagger","tags":"","loc":"proc/array_times_array_dagger.html"},{"title":"array_dagger_times_array – Quantum transport simulator","text":"public pure function array_dagger_times_array(A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2)) Calls proc~~array_dagger_times_array~~CallsGraph proc~array_dagger_times_array matrix_c::array_dagger_times_array proc~array_times_array matrix_c::array_times_array proc~array_dagger_times_array->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_dagger_times_array~~CalledByGraph proc~array_dagger_times_array matrix_c::array_dagger_times_array interface~operator(.dm.) matrix_c::operator(.dm.) interface~operator(.dm.)->proc~array_dagger_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_dagger_times_array Source Code pure function array_dagger_times_array ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 2 ), size ( B , 2 )) C = array_times_array ( A , B , trA = . true ., trB = . false ., cjA = . true ., cjB = . false .) end function array_dagger_times_array","tags":"","loc":"proc/array_dagger_times_array.html"},{"title":"array_times_array – Quantum transport simulator","text":"public pure function array_times_array(A, B, trA, trB, cjA, cjB) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) logical(kind=4), intent(in) :: trA logical(kind=4), intent(in) :: trB logical(kind=4), intent(in), optional :: cjA logical(kind=4), intent(in), optional :: cjB Return Value complex(kind=8), (size(A,merge(2,1,trA)),size(B,merge(1,2,trB))) Called by proc~~array_times_array~~CalledByGraph proc~array_times_array matrix_c::array_times_array proc~array_dagger_times_array matrix_c::array_dagger_times_array proc~array_dagger_times_array->proc~array_times_array proc~array_times_array_dagger matrix_c::array_times_array_dagger proc~array_times_array_dagger->proc~array_times_array proc~array_times_array_simple matrix_c::array_times_array_simple proc~array_times_array_simple->proc~array_times_array interface~operator(.dm.) matrix_c::operator(.dm.) interface~operator(.dm.)->proc~array_dagger_times_array interface~operator(.m.) matrix_c::operator(.m.) interface~operator(.m.)->proc~array_times_array_simple interface~operator(.md.) matrix_c::operator(.md.) interface~operator(.md.)->proc~array_times_array_dagger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_times_array Source Code pure function array_times_array ( A , B , trA , trB , cjA , cjB ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) LOGICAL ( KIND = 4 ), intent ( in ) :: trA , trB complex ( 8 ) :: C ( size ( A , merge ( 2 , 1 , trA )), size ( B , merge ( 1 , 2 , trB ))) LOGICAL ( KIND = 4 ), intent ( in ), optional :: cjA , cjB integer :: lda , ldb , k , m , kb , n character :: ctrA , ctrB interface pure subroutine ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) COMPLEX ( 8 ), intent ( in ) :: ALPHA , BETA INTEGER , intent ( in ) :: K , LDA , LDB , LDC , M , N CHARACTER , intent ( in ) :: TRANSA , TRANSB COMPLEX ( 8 ), intent ( in ) :: A ( lda , * ), B ( ldb , * ) COMPLEX ( 8 ), intent ( inout ) :: C ( ldc , * ) end subroutine ZGEMM end interface lda = size ( A , 1 ) ldb = size ( B , 1 ) if (. not . trA ) then k = size ( A , 2 ) m = size ( A , 1 ) ctrA = 'n' else k = size ( A , 1 ) m = size ( A , 2 ) if ( present ( cjA ) . and . cjA ) then ctrA = 'c' else ctrA = 't' end if end if if (. not . trB ) then kb = size ( B , 1 ) n = size ( B , 2 ) ctrB = 'n' else kb = size ( B , 2 ) n = size ( B , 1 ) if ( present ( cjB ) . and . cjB ) then ctrB = 'c' else ctrB = 't' end if end if call zgemm ( ctrA , ctrB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), C , m ) end function array_times_array","tags":"","loc":"proc/array_times_array.html"},{"title":"array_times_array_simple – Quantum transport simulator","text":"public pure function array_times_array_simple(A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2)) Calls proc~~array_times_array_simple~~CallsGraph proc~array_times_array_simple matrix_c::array_times_array_simple proc~array_times_array matrix_c::array_times_array proc~array_times_array_simple->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_times_array_simple~~CalledByGraph proc~array_times_array_simple matrix_c::array_times_array_simple interface~operator(.m.) matrix_c::operator(.m.) interface~operator(.m.)->proc~array_times_array_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_times_array_simple Source Code pure function array_times_array_simple ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 2 )) C = array_times_array ( A , B , . false ., . false .) end function array_times_array_simple","tags":"","loc":"proc/array_times_array_simple.html"},{"title":"array_power – Quantum transport simulator","text":"public  function array_power(A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) Calls proc~~array_power~~CallsGraph proc~array_power matrix_c::array_power proc~array_eye matrix_c::array_eye proc~array_power->proc~array_eye proc~array_inverse matrix_c::array_inverse proc~array_power->proc~array_inverse zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_power~~CalledByGraph proc~array_power matrix_c::array_power interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_power Source Code function array_power ( A , n ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: n complex ( 8 ) :: B ( size ( A , 1 ), size ( A , 1 )) complex ( 8 ) :: C ( size ( A , 1 ), size ( A , 1 )) integer :: ii if ( n > 0 ) then B = A do ii = 2 , n B = B . m . A end do C = B elseif ( n == 0 ) then C = array_eye ( size ( A , dim = 1 )) elseif ( n == - 1 ) then C = array_inverse ( A ) else C = array_inverse ( A ) B = C do ii = 2 , - n B = B . m . C end do C = B end if end function array_power","tags":"","loc":"proc/array_power.html"},{"title":"array_transpose – Quantum transport simulator","text":"public pure function array_transpose(A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1)) Called by proc~~array_transpose~~CalledByGraph proc~array_transpose matrix_c::array_transpose interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_transpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_transpose Source Code pure function array_transpose ( A , t ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) character , intent ( in ) :: t complex ( 8 ) :: C ( size ( A , 2 ), size ( A , 1 )) if (( t == 't' ) . or . ( t == 'T' )) then C = Transpose ( A ) elseif (( t == 'c' ) . or . ( t == 'C' )) then C = Transpose ( Conjg ( A )) end if end function array_transpose","tags":"","loc":"proc/array_transpose.html"},{"title":"array_eigen – Quantum transport simulator","text":"public  function array_eigen(A, B, eigvec, itype, uplo) result(eig) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in), optional :: B (:,:) complex(kind=8), intent(inout), optional :: eigvec (size(A,1),size(A,2)) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: uplo Return Value real(kind=8), (size(A,1)) Calls proc~~array_eigen~~CallsGraph proc~array_eigen matrix_c::array_eigen zheev zheev proc~array_eigen->zheev zhegv zhegv proc~array_eigen->zhegv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_eigen Source Code function array_eigen ( A , B , eigvec , itype , uplo ) result ( eig ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ), intent ( in ), optional :: B (:, :) real ( 8 ) :: eig ( size ( A , 1 )) complex ( 8 ), intent ( inout ), optional :: eigvec ( size ( A , 1 ), size ( A , 2 )) integer , intent ( in ), optional :: itype CHARACTER , intent ( in ), optional :: uplo integer :: LDA , N , LDB , lwork , INFO , itypeop CHARACTER :: jobz , uploop real ( 8 ) :: RWORK ( 3 * size ( A , 2 )) complex ( 8 ) :: work ( 1 + 4 * size ( A , 2 ) + size ( A , 2 ) ** 2 ), C ( size ( A , 1 ), size ( A , 2 )) C (:, :) = A (:, :) if ( present ( eigvec )) then jobz = 'V' else jobz = 'N' end if uploop = merge ( uplo , 'U' , present ( uplo )) itypeop = merge ( itype , 1 , present ( itype )) N = size ( A , dim = 2 ) LDA = size ( A , dim = 1 ) LWORK = size ( WORK ) if ( present ( B )) then LDB = size ( B , dim = 1 ) call zhegv ( itypeop , jobz , uploop , N , C , LDA , B , LDB , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEGV fails with INFO=' , INFO call abort () end if else LDB = LDA call zheev ( jobz , uploop , N , C , LDA , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEEV fails with INFO=' , INFO call abort () end if end if if ( present ( eigvec )) eigvec = C end function array_eigen","tags":"","loc":"proc/array_eigen.html"},{"title":"array_to_diag – Quantum transport simulator","text":"public pure function array_to_diag(A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1)) Called by proc~~array_to_diag~~CalledByGraph proc~array_to_diag matrix_c::array_to_diag interface~diag matrix_c::diag interface~diag->proc~array_to_diag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_to_diag Source Code pure function array_to_diag ( A ) result ( diag ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: diag ( size ( A , 1 )) integer :: ii do concurrent ( ii = 1 : size ( A , 1 )) diag ( ii ) = A ( ii , ii ) end do end function array_to_diag","tags":"","loc":"proc/array_to_diag.html"},{"title":"array_inverse2 – Quantum transport simulator","text":"public  function array_inverse2(A, UPLO) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: UPLO Return Value complex(kind=8), (size(A,dim=1),size(A,dim=1)) Calls proc~~array_inverse2~~CallsGraph proc~array_inverse2 matrix_c::array_inverse2 zhetrf zhetrf proc~array_inverse2->zhetrf zhetri zhetri proc~array_inverse2->zhetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_inverse2 Source Code function array_inverse2 ( A , UPLO ) ! for Hermitian matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: array_inverse2 ( size ( A , dim = 1 ), size ( A , dim = 1 )) CHARACTER , intent ( in ) :: UPLO integer :: info , lda , lwork , n , nnz integer :: ipiv ( size ( A , 1 )) complex ( 8 ), allocatable :: work (:, :) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse2 (:, :) = A (:, :) allocate ( work ( n * n , n * n )) LDA = size ( A , 2 ) call zhetrf ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , size ( WORK ), info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRF fails with INFO=' , info call abort () end if call zhetri ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRI fails with INFO=' , info call abort () end if end function array_inverse2","tags":"","loc":"proc/array_inverse2.html"},{"title":"array_inverse – Quantum transport simulator","text":"public  function array_inverse(A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), dimension(size(A, dim=1), size(A, dim=1)) Calls proc~~array_inverse~~CallsGraph proc~array_inverse matrix_c::array_inverse zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_inverse~~CalledByGraph proc~array_inverse matrix_c::array_inverse proc~array_power matrix_c::array_power proc~array_power->proc~array_inverse interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_inverse Source Code function array_inverse ( A ) ! for General matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: info , n integer :: ipiv ( size ( A , 1 )) complex ( 8 ), dimension ( size ( A , dim = 1 ), size ( A , dim = 1 )) :: array_inverse complex ( 8 ), allocatable :: work (:) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse (:, :) = A (:, :) allocate ( work ( n * n )) call zgetrf ( n , n , array_inverse , n , ipiv , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRF fails with INFO=' , info call abort () end if call zgetri ( n , array_inverse , n , ipiv , work , n * n , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRI fails with INFO=' , info call abort () end if end function array_inverse","tags":"","loc":"proc/array_inverse.html"},{"title":"array_trace – Quantum transport simulator","text":"public pure function array_trace(A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) Called by proc~~array_trace~~CalledByGraph proc~array_trace matrix_c::array_trace interface~trace matrix_c::trace interface~trace->proc~array_trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_trace Source Code pure function array_trace ( A ) result ( tr ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: tr integer :: ii tr = sum (( / ( A ( ii , ii ), ii = 1 , size ( A , 1 )) / )) end function array_trace","tags":"","loc":"proc/array_trace.html"},{"title":"matrix_trace – Quantum transport simulator","text":"public elemental function matrix_trace(M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8) Called by proc~~matrix_trace~~CalledByGraph proc~matrix_trace matrix_c::matrix_trace interface~trace matrix_c::trace interface~trace->proc~matrix_trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_trace Source Code elemental function matrix_trace ( M ) result ( tr ) implicit none type ( type_matrix_complex ), intent ( in ) :: M complex ( 8 ) :: tr integer :: ii tr = sum (( / ( M % m ( ii , ii ), ii = 1 , M % size ( 1 )) / )) end function matrix_trace","tags":"","loc":"proc/matrix_trace.html"},{"title":"matrix_alloc – Quantum transport simulator","text":"public pure subroutine matrix_alloc(M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) Calls proc~~matrix_alloc~~CallsGraph proc~matrix_alloc matrix_c::matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_alloc->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_alloc~~CalledByGraph proc~matrix_alloc matrix_c::matrix_alloc interface~malloc matrix_c::malloc interface~malloc->proc~matrix_alloc proc~matrix_read matrix_c::matrix_read proc~matrix_read->proc~matrix_alloc interface~readtxt matrix_c::ReadTxt interface~readtxt->proc~matrix_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_alloc Source Code pure subroutine matrix_alloc ( M , n , nn , source ) implicit none type ( type_matrix_complex ), intent ( out ) :: M integer , intent ( in ) :: n integer , intent ( in ), optional :: nn complex ( 8 ), intent ( in ), optional :: source (:, :) if ( present ( nn )) then call matrix_alloc2 ( M , ( / n , nn / ), source = source ) else call matrix_alloc2 ( M , ( / n , n / ), source = source ) end if end subroutine matrix_alloc","tags":"","loc":"proc/matrix_alloc.html"},{"title":"matrix_alloc2 – Quantum transport simulator","text":"public pure subroutine matrix_alloc2(M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) Called by proc~~matrix_alloc2~~CalledByGraph proc~matrix_alloc2 matrix_c::matrix_alloc2 interface~malloc matrix_c::malloc interface~malloc->proc~matrix_alloc2 proc~matrix_alloc matrix_c::matrix_alloc interface~malloc->proc~matrix_alloc proc~matrix_list_allocelem matrix_c::matrix_list_allocElem interface~malloc->proc~matrix_list_allocelem proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 interface~malloc->proc~matrix_list_allocelem2 proc~matrix_alloc->proc~matrix_alloc2 proc~matrix_list_allocelem->proc~matrix_alloc2 proc~matrix_list_allocelem2->proc~matrix_alloc2 proc~matrix_read matrix_c::matrix_read proc~matrix_read->proc~matrix_alloc interface~readtxt matrix_c::ReadTxt interface~readtxt->proc~matrix_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_alloc2 Source Code pure subroutine matrix_alloc2 ( M , n , source ) implicit none type ( type_matrix_complex ), intent ( inout ) :: M integer , intent ( in ) :: n ( 2 ) complex ( 8 ), intent ( in ), optional :: source ( 1 : n ( 1 ), 1 : n ( 2 )) if (. not . allocated ( M % m )) then allocate ( M % m ( n ( 1 ), n ( 2 ))) else if (( M % size ( 1 ) == n ( 1 )) . and . ( M % size ( 2 ) == n ( 2 ))) then else deallocate ( M % m ) allocate ( M % m ( n ( 1 ), n ( 2 ))) end if end if if ( present ( source )) then M % m (:, :) = source (:, :) else M % m (:, :) = dcmplx ( 0.0d0 , 0.0d0 ) end if M % size = n end subroutine matrix_alloc2","tags":"","loc":"proc/matrix_alloc2.html"},{"title":"array_alloc – Quantum transport simulator","text":"public pure subroutine array_alloc(M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn Calls proc~~array_alloc~~CallsGraph proc~array_alloc matrix_c::array_alloc proc~array_alloc2 matrix_c::array_alloc2 proc~array_alloc->proc~array_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_alloc~~CalledByGraph proc~array_alloc matrix_c::array_alloc interface~malloc matrix_c::malloc interface~malloc->proc~array_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_alloc Source Code pure subroutine array_alloc ( M , n , nn ) implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n integer , intent ( in ), optional :: nn if ( present ( nn )) then call array_alloc2 ( M , ( / n , nn / )) else call array_alloc2 ( M , ( / n , n / )) end if end subroutine array_alloc","tags":"","loc":"proc/array_alloc.html"},{"title":"array_alloc2 – Quantum transport simulator","text":"public pure subroutine array_alloc2(M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2) Called by proc~~array_alloc2~~CalledByGraph proc~array_alloc2 matrix_c::array_alloc2 interface~malloc matrix_c::malloc interface~malloc->proc~array_alloc2 proc~array_alloc matrix_c::array_alloc interface~malloc->proc~array_alloc proc~array_alloc->proc~array_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_alloc2 Source Code pure subroutine array_alloc2 ( M , n ) !! This function allocates a 2D complex array. If the array is already allocated, this function !! will resize the array to the new size. The allocated array is initiated to zero. implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n ( 2 ) if (. not . allocated ( M )) then allocate ( M ( n ( 1 ), n ( 2 ))) else if (( size ( M , 1 ) == n ( 1 )) . and . ( size ( M , 2 ) == n ( 2 ))) then else deallocate ( M ) allocate ( M ( n ( 1 ), n ( 2 ))) end if end if M = dcmplx ( 0.0d0 , 0.0d0 ) end subroutine array_alloc2","tags":"","loc":"proc/array_alloc2.html"},{"title":"matrix_list_allocElem – Quantum transport simulator","text":"public pure subroutine matrix_list_allocElem(this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices Calls proc~~matrix_list_allocelem~~CallsGraph proc~matrix_list_allocelem matrix_c::matrix_list_allocElem proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_list_allocelem->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_list_allocelem~~CalledByGraph proc~matrix_list_allocelem matrix_c::matrix_list_allocElem interface~malloc matrix_c::malloc interface~malloc->proc~matrix_list_allocelem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_allocElem Source Code pure subroutine matrix_list_allocElem ( this , nx , nm , nn , source ) implicit none integer , intent ( in ) :: nx integer , intent ( in ) :: nm ( 1 : nx ) integer , intent ( in ), optional :: nn ( 1 : nx ) type ( type_matrix_complex ), intent ( out ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx if ( present ( nn )) then if ( present ( source )) then call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nn ( ii ) / ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nn ( ii ) / )) endif else if ( present ( source )) then call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nm ( ii ) / ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nm ( ii ) / )) endif end if end do end subroutine matrix_list_allocElem","tags":"","loc":"proc/matrix_list_allocelem.html"},{"title":"matrix_list_allocElem2 – Quantum transport simulator","text":"public pure subroutine matrix_list_allocElem2(this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices Calls proc~~matrix_list_allocelem2~~CallsGraph proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_list_allocelem2->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_list_allocelem2~~CalledByGraph proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 interface~malloc matrix_c::malloc interface~malloc->proc~matrix_list_allocelem2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_allocElem2 Source Code pure subroutine matrix_list_allocElem2 ( this , nx , n , source ) implicit none integer , intent ( in ) :: nx , n ( 2 , 1 : nx ) type ( type_matrix_complex ), intent ( inout ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx if ( present ( source )) then call matrix_alloc2 ( this ( ii ), n ( 1 : 2 , ii ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), n ( 1 : 2 , ii )) endif end do end subroutine matrix_list_allocElem2","tags":"","loc":"proc/matrix_list_allocelem2.html"},{"title":"matrix_free – Quantum transport simulator","text":"public elemental subroutine matrix_free(this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this Called by proc~~matrix_free~~CalledByGraph proc~matrix_free matrix_c::matrix_free interface~free matrix_c::free interface~free->proc~matrix_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_free Source Code elemental subroutine matrix_free ( this ) implicit none type ( type_matrix_complex ), intent ( out ) :: this if ( allocated ( this % m )) deallocate ( this % m ) end subroutine matrix_free","tags":"","loc":"proc/matrix_free.html"},{"title":"matrix_list_print – Quantum transport simulator","text":"public  subroutine matrix_list_print(handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) Called by proc~~matrix_list_print~~CalledByGraph proc~matrix_list_print matrix_c::matrix_list_print interface~savetxt matrix_c::SaveTxt interface~savetxt->proc~matrix_list_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_print Source Code subroutine matrix_list_print ( handle , this ) implicit none type ( type_matrix_complex ), intent ( in ) :: this (:) integer , intent ( in ), optional :: handle integer :: ii , xx , yy if ( present ( handle )) then write ( handle , '(1(i8))' ) size ( this ) do ii = 1 , size ( this ) write ( handle , '(2(i8))' ) this ( ii )% size (:) end do write ( handle , '(es15.4,es15.4)' ) ((( this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) else print '(3(i8),es15.4,es15.4)' , ((( ii , xx , yy , this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) end if end subroutine matrix_list_print","tags":"","loc":"proc/matrix_list_print.html"},{"title":"array_print – Quantum transport simulator","text":"public  subroutine array_print(handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:) Called by proc~~array_print~~CalledByGraph proc~array_print matrix_c::array_print interface~savetxt matrix_c::SaveTxt interface~savetxt->proc~array_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_print Source Code subroutine array_print ( handle , A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: handle integer :: xx , yy write ( handle , '(2(i8))' ) size ( A , 1 ), size ( A , 2 ) write ( handle , '(es15.4,es15.4)' ) (( A ( xx , yy ), xx = 1 , size ( A , 1 )), yy = 1 , size ( A , 2 )) write ( handle , '(A)' ) \"END\" end subroutine array_print","tags":"","loc":"proc/array_print.html"},{"title":"matrix_read – Quantum transport simulator","text":"public  subroutine matrix_read(handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A Calls proc~~matrix_read~~CallsGraph proc~matrix_read matrix_c::matrix_read proc~matrix_alloc matrix_c::matrix_alloc proc~matrix_read->proc~matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_alloc->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_read~~CalledByGraph proc~matrix_read matrix_c::matrix_read interface~readtxt matrix_c::ReadTxt interface~readtxt->proc~matrix_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_read Source Code subroutine matrix_read ( handle , A ) implicit none type ( type_matrix_complex ), intent ( out ) :: A integer , intent ( in ) :: handle integer :: xx , yy real ( 8 ) :: re , im character ( len = 100 ) :: s read ( handle , * ) xx , yy call matrix_alloc ( A , xx , yy ) read ( handle , '(100A)' ) s do while ( trim ( s ) /= \"END\" ) read ( s , * ) re , im A % m ( xx , yy ) = dcmplx ( re , im ) read ( handle , '(100A)' ) s end do end subroutine matrix_read","tags":"","loc":"proc/matrix_read.html"},{"title":"array_print_on_screen – Quantum transport simulator","text":"public  subroutine array_print_on_screen(A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Called by proc~~array_print_on_screen~~CalledByGraph proc~array_print_on_screen matrix_c::array_print_on_screen interface~show matrix_c::show interface~show->proc~array_print_on_screen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_print_on_screen Source Code subroutine array_print_on_screen ( A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: xx , yy do xx = 1 , size ( A , 1 ) print '(10(A,es8.1,\",\",es8.1,\")\"))' , ( \"(\" , A ( xx , yy ), yy = 1 , size ( A , 2 )) end do end subroutine array_print_on_screen","tags":"","loc":"proc/array_print_on_screen.html"},{"title":"matrix_copy – Quantum transport simulator","text":"public  subroutine matrix_copy(matrices, tab) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: matrices (:) complex(kind=8), intent(out) :: tab (:,:,:) Contents Source Code matrix_copy Source Code subroutine matrix_copy ( matrices , tab ) implicit none type ( type_matrix_complex ), intent ( in ) :: matrices (:) complex ( 8 ), intent ( out ) :: tab (:, :, :) integer :: i do concurrent ( i = 1 : size ( matrices )) tab ( 1 : matrices ( i )% size ( 1 ), 1 : matrices ( i )% size ( 2 ), i ) = matrices ( i )% m (:, :) end do end subroutine matrix_copy","tags":"","loc":"proc/matrix_copy.html"},{"title":"triMUL_C – Quantum transport simulator","text":"public  subroutine triMUL_C(A, B, C, R, trA, trB, trC) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in), dimension(:, :) :: A complex(kind=8), intent(in), dimension(:, :) :: B complex(kind=8), intent(in), dimension(:, :) :: C complex(kind=8), intent(inout), allocatable :: R (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB character(len=1), intent(in) :: trC Calls proc~~trimul_c~~CallsGraph proc~trimul_c matrix_c::triMUL_C proc~mul_c matrix_c::MUL_C proc~trimul_c->proc~mul_c zgemm zgemm proc~mul_c->zgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~trimul_c~~CalledByGraph proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->proc~trimul_c proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward proc~rgf_variableblock_forward->proc~trimul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code triMUL_C Source Code subroutine triMUL_C ( A , B , C , R , trA , trB , trC ) complex ( 8 ), intent ( in ), dimension (:, :) :: A , B , C complex ( 8 ), intent ( inout ), allocatable :: R (:, :) character , intent ( in ) :: trA , trB , trC complex ( 8 ), allocatable , dimension (:, :) :: tmp integer :: n , m , k , kb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trB is wrong: \" , trB call abort () end if if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in triMUL_C! Matrix dimension is wrong\" , k , kb call abort () end if call MUL_C ( A , B , trA , trB , tmp ) call MUL_C ( tmp , C , 'n' , trC , R ) deallocate ( tmp ) end subroutine triMUL_C","tags":"","loc":"proc/trimul_c.html"},{"title":"MUL_C – Quantum transport simulator","text":"public  subroutine MUL_C(A, B, trA, trB, R) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB complex(kind=8), intent(inout), allocatable :: R (:,:) Calls proc~~mul_c~~CallsGraph proc~mul_c matrix_c::MUL_C zgemm zgemm proc~mul_c->zgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mul_c~~CalledByGraph proc~mul_c matrix_c::MUL_C proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->proc~mul_c proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_backward->proc~trimul_c proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward proc~rgf_variableblock_forward->proc~mul_c proc~rgf_variableblock_forward->proc~trimul_c proc~trimul_c->proc~mul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code MUL_C Source Code subroutine MUL_C ( A , B , trA , trB , R ) complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ), intent ( inout ), allocatable :: R (:, :) CHARACTER , intent ( in ) :: trA , trB integer :: n , m , k , kb , lda , ldb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trB is wrong: \" , trB call abort () end if lda = size ( A , 1 ) ldb = size ( B , 1 ) if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in MUL_C! Matrix dimension is wrong\" , k , kb call abort () end if if ( allocated ( R )) then if (( size ( R , 1 ) . ne . m ) . or . ( size ( R , 2 ) . ne . n )) then deallocate ( R ) Allocate ( R ( m , n )) end if else Allocate ( R ( m , n )) end if R = dcmplx ( 0.0d0 , 0.0d0 ) call zgemm ( trA , trB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), R , m ) end subroutine MUL_C","tags":"","loc":"proc/mul_c.html"},{"title":"operator(.m.) – Quantum transport simulator","text":"public interface operator(.m.) Calls interface~~operator(.m.)~~CallsGraph interface~operator(.m.) matrix_c::operator(.m.) proc~array_times_array_simple matrix_c::array_times_array_simple interface~operator(.m.)->proc~array_times_array_simple proc~array_times_array matrix_c::array_times_array proc~array_times_array_simple->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_times_array_simple Module Procedures public pure function array_times_array_simple (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2))","tags":"","loc":"interface/operator(.m.).html"},{"title":"operator(**) – Quantum transport simulator","text":"public interface operator(**) Calls interface~~operator(ASTERISKASTERISK)~~CallsGraph interface~operator(ASTERISKASTERISK) matrix_c::operator(**) proc~array_power matrix_c::array_power interface~operator(ASTERISKASTERISK)->proc~array_power proc~array_transpose matrix_c::array_transpose interface~operator(ASTERISKASTERISK)->proc~array_transpose proc~array_eye matrix_c::array_eye proc~array_power->proc~array_eye proc~array_inverse matrix_c::array_inverse proc~array_power->proc~array_inverse zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_power array_transpose Module Procedures public  function array_power (A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) public pure function array_transpose (A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1))","tags":"","loc":"interface/operator(ASTERISKASTERISK).html"},{"title":"operator(.md.) – Quantum transport simulator","text":"public interface operator(.md.) Calls interface~~operator(.md.)~~CallsGraph interface~operator(.md.) matrix_c::operator(.md.) proc~array_times_array_dagger matrix_c::array_times_array_dagger interface~operator(.md.)->proc~array_times_array_dagger proc~array_times_array matrix_c::array_times_array proc~array_times_array_dagger->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_times_array_dagger Module Procedures public pure function array_times_array_dagger (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1))","tags":"","loc":"interface/operator(.md.).html"},{"title":"operator(.dm.) – Quantum transport simulator","text":"public interface operator(.dm.) Calls interface~~operator(.dm.)~~CallsGraph interface~operator(.dm.) matrix_c::operator(.dm.) proc~array_dagger_times_array matrix_c::array_dagger_times_array interface~operator(.dm.)->proc~array_dagger_times_array proc~array_times_array matrix_c::array_times_array proc~array_dagger_times_array->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_dagger_times_array Module Procedures public pure function array_dagger_times_array (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2))","tags":"","loc":"interface/operator(.dm.).html"},{"title":"sizeof – Quantum transport simulator","text":"public interface sizeof Calls interface~~sizeof~~CallsGraph interface~sizeof matrix_c::sizeof proc~array_size matrix_c::array_size interface~sizeof->proc~array_size proc~matrix_list_size matrix_c::matrix_list_size interface~sizeof->proc~matrix_list_size proc~matrix_list_size2 matrix_c::matrix_list_size2 interface~sizeof->proc~matrix_list_size2 proc~matrix_size matrix_c::matrix_size interface~sizeof->proc~matrix_size proc~matrix_size_dim matrix_c::matrix_size_dim interface~sizeof->proc~matrix_size_dim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_size matrix_size matrix_list_size matrix_size_dim matrix_list_size2 Module Procedures public pure function array_size (this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) public pure function matrix_size (this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) public pure function matrix_list_size (list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) public pure function matrix_size_dim (this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function matrix_list_size2 (list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list))","tags":"","loc":"interface/sizeof.html"},{"title":"ReadTxt – Quantum transport simulator","text":"public interface ReadTxt Calls interface~~readtxt~~CallsGraph interface~readtxt matrix_c::ReadTxt proc~matrix_read matrix_c::matrix_read interface~readtxt->proc~matrix_read proc~matrix_alloc matrix_c::matrix_alloc proc~matrix_read->proc~matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_alloc->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_read Module Procedures public  subroutine matrix_read (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A","tags":"","loc":"interface/readtxt.html"},{"title":"SaveTxt – Quantum transport simulator","text":"public interface SaveTxt Calls interface~~savetxt~~CallsGraph interface~savetxt matrix_c::SaveTxt proc~array_print matrix_c::array_print interface~savetxt->proc~array_print proc~matrix_list_print matrix_c::matrix_list_print interface~savetxt->proc~matrix_list_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_list_print array_print Module Procedures public  subroutine matrix_list_print (handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) public  subroutine array_print (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:)","tags":"","loc":"interface/savetxt.html"},{"title":"show – Quantum transport simulator","text":"public interface show Calls interface~~show~~CallsGraph interface~show matrix_c::show proc~array_print_on_screen matrix_c::array_print_on_screen interface~show->proc~array_print_on_screen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_print_on_screen Module Procedures public  subroutine array_print_on_screen (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:)","tags":"","loc":"interface/show.html"},{"title":"malloc – Quantum transport simulator","text":"public interface malloc Calls interface~~malloc~~CallsGraph interface~malloc matrix_c::malloc proc~array_alloc matrix_c::array_alloc interface~malloc->proc~array_alloc proc~array_alloc2 matrix_c::array_alloc2 interface~malloc->proc~array_alloc2 proc~matrix_alloc matrix_c::matrix_alloc interface~malloc->proc~matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 interface~malloc->proc~matrix_alloc2 proc~matrix_list_allocelem matrix_c::matrix_list_allocElem interface~malloc->proc~matrix_list_allocelem proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 interface~malloc->proc~matrix_list_allocelem2 proc~array_alloc->proc~array_alloc2 proc~matrix_alloc->proc~matrix_alloc2 proc~matrix_list_allocelem->proc~matrix_alloc2 proc~matrix_list_allocelem2->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_list_allocElem2 matrix_list_allocElem matrix_alloc matrix_alloc2 array_alloc array_alloc2 Module Procedures public pure subroutine matrix_list_allocElem2 (this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_list_allocElem (this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_alloc (M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) public pure subroutine matrix_alloc2 (M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) public pure subroutine array_alloc (M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn public pure subroutine array_alloc2 (M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2)","tags":"","loc":"interface/malloc.html"},{"title":"free – Quantum transport simulator","text":"public interface free Calls interface~~free~~CallsGraph interface~free matrix_c::free proc~matrix_free matrix_c::matrix_free interface~free->proc~matrix_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_free Module Procedures public elemental subroutine matrix_free (this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this","tags":"","loc":"interface/free.html"},{"title":"eye – Quantum transport simulator","text":"public interface eye Calls interface~~eye~~CallsGraph interface~eye matrix_c::eye proc~array_eye matrix_c::array_eye interface~eye->proc~array_eye Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_eye Module Procedures public pure function array_eye (n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n)","tags":"","loc":"interface/eye.html"},{"title":"diag – Quantum transport simulator","text":"public interface diag Calls interface~~diag~~CallsGraph interface~diag matrix_c::diag proc~array_to_diag matrix_c::array_to_diag interface~diag->proc~array_to_diag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_to_diag Module Procedures public pure function array_to_diag (A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1))","tags":"","loc":"interface/diag.html"},{"title":"trace – Quantum transport simulator","text":"public interface trace Calls interface~~trace~~CallsGraph interface~trace matrix_c::trace proc~array_trace matrix_c::array_trace interface~trace->proc~array_trace proc~matrix_trace matrix_c::matrix_trace interface~trace->proc~matrix_trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_trace matrix_trace Module Procedures public pure function array_trace (A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) public elemental function matrix_trace (M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8)","tags":"","loc":"interface/trace.html"},{"title":"negf_mod – Quantum transport simulator","text":"Non-equilibrium Green's function (NEGF) module, upper-level driver for solving the NEGF equations Used by module~~negf_mod~~UsedByGraph module~negf_mod negf_mod program~main main program~main->module~negf_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines negf_solve Subroutines public  subroutine negf_solve (nx, nen, nk, emin, emax, Hii, H1i, Sii, temp, mu, comm_size, comm_rank, local_NE, first_local_energy, nbnd, nslab, Lx) $omp do $omp end do Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx number of slabs integer, intent(in) :: nen number of energy points integer, intent(in) :: nk number of k points real(kind=dp) :: emin min and max energy range real(kind=dp) :: emax min and max energy range type( type_matrix_complex ), intent(in), dimension(nx, nk) :: Hii type( type_matrix_complex ), intent(in), dimension(nx + 1, nk) :: H1i type( type_matrix_complex ), intent(in), dimension(nx, nk) :: Sii real(kind=dp), intent(in), dimension(2) :: temp temperatures real(kind=dp), intent(in), dimension(2) :: mu chemical potentials integer(kind=4), intent(in) :: comm_size integer(kind=4), intent(in) :: comm_rank integer(kind=4), intent(in) :: local_NE integer(kind=4), intent(in) :: first_local_energy integer, intent(in) :: nbnd number of bands / orbitals per cell integer, intent(in) :: nslab number of cells in a slab real(kind=dp), intent(in) :: Lx Lx","tags":"","loc":"module/negf_mod.html"},{"title":"linalg – Quantum transport simulator","text":"Uses cublas module~~linalg~~UsesGraph module~linalg linalg cublas cublas module~linalg->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~linalg~~UsedByGraph module~linalg linalg proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->module~linalg proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward proc~rgf_variableblock_forward->module~linalg proc~sancho cuda_rgf_mod::sancho proc~sancho->module~linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions cross eig eigv Subroutines invert invert_banded Functions public  function cross (a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), DIMENSION(3) :: a real(kind=8), intent(in), DIMENSION(3) :: b Return Value real(kind=8), DIMENSION(3) public  function eig (NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) public  function eigv (NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) Subroutines public  subroutine invert (A, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(nn, nn) :: A integer :: nn public  subroutine invert_banded (A, nn, nb) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout) :: A (3*nb+1,nn) integer, intent(in) :: nn integer, intent(in) :: nb","tags":"","loc":"module/linalg.html"},{"title":"cuda_rgf_mod – Quantum transport simulator","text":"Recursive Forward Green's solver\nSancho-Rubio\nFermi distribution function Uses omp_lib cusolverdn cublas module~~cuda_rgf_mod~~UsesGraph module~cuda_rgf_mod cuda_rgf_mod cublas cublas module~cuda_rgf_mod->cublas cusolverdn cusolverdn module~cuda_rgf_mod->cusolverdn omp_lib omp_lib module~cuda_rgf_mod->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~cuda_rgf_mod~~UsedByGraph module~cuda_rgf_mod cuda_rgf_mod proc~negf_solve negf_mod::negf_solve proc~negf_solve->module~cuda_rgf_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types type_matrix_complex Subroutines cuda_rgf_init cuda_rgf_finish cuda_rgf_constblocksize cuda_rgf_variableblock_forward Derived Types type, public :: type_matrix_complex Components Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: m (:,:) complex matrix integer, public :: size (2) matrix size Subroutines public  subroutine cuda_rgf_init (nm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nm public  subroutine cuda_rgf_finish () Arguments None public  subroutine cuda_rgf_constblocksize (nm, nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, tr, tre) !$omp target exit data map(delete:H10,G00,A,sigmal,S00,sig2,B)\n! G<_i+1,i ! G<_i,i+1\n! G_i,i+1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nm lenght of the device integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre public  subroutine cuda_rgf_variableblock_forward (nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) !$omp critical\n        open (unit=10, file='sancho_g00.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(G00))\n        close (10)\n        open (unit=10, file='sancho_gbb.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(Gbb))\n        close (10)\n!$omp end critical Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) type( type_matrix_complex ), intent(inout) :: Gl (nx) type( type_matrix_complex ), intent(inout) :: Gln (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre","tags":"","loc":"module/cuda_rgf_mod.html"},{"title":"MKL_DFT_TYPE – Quantum transport simulator","text":"Used by module~~mkl_dft_type~~UsedByGraph module~mkl_dft_type MKL_DFT_TYPE module~mkl_dfti MKL_DFTI module~mkl_dfti->module~mkl_dft_type proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->module~mkl_dfti Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables DFTI_SPKP DFTI_DPKP DFTI_FORWARD_DOMAIN DFTI_DIMENSION DFTI_LENGTHS DFTI_PRECISION DFTI_FORWARD_SCALE DFTI_BACKWARD_SCALE DFTI_NUMBER_OF_TRANSFORMS DFTI_COMPLEX_STORAGE DFTI_REAL_STORAGE DFTI_CONJUGATE_EVEN_STORAGE DFTI_PLACEMENT DFTI_INPUT_STRIDES DFTI_OUTPUT_STRIDES DFTI_INPUT_DISTANCE DFTI_OUTPUT_DISTANCE DFTI_WORKSPACE DFTI_ORDERING DFTI_TRANSPOSE DFTI_DESCRIPTOR_NAME DFTI_PACKED_FORMAT DFTI_COMMIT_STATUS DFTI_VERSION DFTI_NUMBER_OF_USER_THREADS DFTI_THREAD_LIMIT DFTI_COMMITTED DFTI_UNCOMMITTED DFTI_COMPLEX DFTI_REAL DFTI_SINGLE DFTI_DOUBLE DFTI_SINGLE_R DFTI_DOUBLE_R DFTI_COMPLEX_COMPLEX DFTI_COMPLEX_REAL DFTI_REAL_COMPLEX DFTI_REAL_REAL DFTI_INPLACE DFTI_NOT_INPLACE DFTI_ORDERED DFTI_BACKWARD_SCRAMBLED DFTI_ALLOW DFTI_AVOID DFTI_NONE DFTI_CCS_FORMAT DFTI_PACK_FORMAT DFTI_PERM_FORMAT DFTI_CCE_FORMAT DFTI_NO_ERROR DFTI_MEMORY_ERROR DFTI_INVALID_CONFIGURATION DFTI_INCONSISTENT_CONFIGURATION DFTI_MULTITHREADED_ERROR DFTI_BAD_DESCRIPTOR DFTI_UNIMPLEMENTED DFTI_MKL_INTERNAL_ERROR DFTI_NUMBER_OF_THREADS_ERROR DFTI_1D_LENGTH_EXCEEDS_INT32 DFTI_MAX_MESSAGE_LENGTH DFTI_MAX_NAME_LENGTH DFTI_VERSION_LENGTH Derived Types DFTI_DESCRIPTOR Variables Type Visibility Attributes Name Initial integer, public, parameter :: DFTI_SPKP = SELECTED_REAL_KIND(6, 37) integer, public, parameter :: DFTI_DPKP = SELECTED_REAL_KIND(15, 307) integer, public, parameter :: DFTI_FORWARD_DOMAIN = 0 integer, public, parameter :: DFTI_DIMENSION = 1 integer, public, parameter :: DFTI_LENGTHS = 2 integer, public, parameter :: DFTI_PRECISION = 3 integer, public, parameter :: DFTI_FORWARD_SCALE = 4 integer, public, parameter :: DFTI_BACKWARD_SCALE = 5 integer, public, parameter :: DFTI_NUMBER_OF_TRANSFORMS = 7 integer, public, parameter :: DFTI_COMPLEX_STORAGE = 8 integer, public, parameter :: DFTI_REAL_STORAGE = 9 integer, public, parameter :: DFTI_CONJUGATE_EVEN_STORAGE = 10 integer, public, parameter :: DFTI_PLACEMENT = 11 integer, public, parameter :: DFTI_INPUT_STRIDES = 12 integer, public, parameter :: DFTI_OUTPUT_STRIDES = 13 integer, public, parameter :: DFTI_INPUT_DISTANCE = 14 integer, public, parameter :: DFTI_OUTPUT_DISTANCE = 15 integer, public, parameter :: DFTI_WORKSPACE = 17 integer, public, parameter :: DFTI_ORDERING = 18 integer, public, parameter :: DFTI_TRANSPOSE = 19 integer, public, parameter :: DFTI_DESCRIPTOR_NAME = 20 integer, public, parameter :: DFTI_PACKED_FORMAT = 21 integer, public, parameter :: DFTI_COMMIT_STATUS = 22 integer, public, parameter :: DFTI_VERSION = 23 integer, public, parameter :: DFTI_NUMBER_OF_USER_THREADS = 26 integer, public, parameter :: DFTI_THREAD_LIMIT = 27 integer, public, parameter :: DFTI_COMMITTED = 30 integer, public, parameter :: DFTI_UNCOMMITTED = 31 integer, public, parameter :: DFTI_COMPLEX = 32 integer, public, parameter :: DFTI_REAL = 33 integer, public, parameter :: DFTI_SINGLE = 35 integer, public, parameter :: DFTI_DOUBLE = 36 real(kind=DFTI_SPKP), public, parameter :: DFTI_SINGLE_R = REAL(35) real(kind=DFTI_DPKP), public, parameter :: DFTI_DOUBLE_R = REAL(36) integer, public, parameter :: DFTI_COMPLEX_COMPLEX = 39 integer, public, parameter :: DFTI_COMPLEX_REAL = 40 integer, public, parameter :: DFTI_REAL_COMPLEX = 41 integer, public, parameter :: DFTI_REAL_REAL = 42 integer, public, parameter :: DFTI_INPLACE = 43 integer, public, parameter :: DFTI_NOT_INPLACE = 44 integer, public, parameter :: DFTI_ORDERED = 48 integer, public, parameter :: DFTI_BACKWARD_SCRAMBLED = 49 integer, public, parameter :: DFTI_ALLOW = 51 integer, public, parameter :: DFTI_AVOID = 52 integer, public, parameter :: DFTI_NONE = 53 integer, public, parameter :: DFTI_CCS_FORMAT = 54 integer, public, parameter :: DFTI_PACK_FORMAT = 55 integer, public, parameter :: DFTI_PERM_FORMAT = 56 integer, public, parameter :: DFTI_CCE_FORMAT = 57 integer, public, parameter :: DFTI_NO_ERROR = 0 integer, public, parameter :: DFTI_MEMORY_ERROR = 1 integer, public, parameter :: DFTI_INVALID_CONFIGURATION = 2 integer, public, parameter :: DFTI_INCONSISTENT_CONFIGURATION = 3 integer, public, parameter :: DFTI_MULTITHREADED_ERROR = 4 integer, public, parameter :: DFTI_BAD_DESCRIPTOR = 5 integer, public, parameter :: DFTI_UNIMPLEMENTED = 6 integer, public, parameter :: DFTI_MKL_INTERNAL_ERROR = 7 integer, public, parameter :: DFTI_NUMBER_OF_THREADS_ERROR = 8 integer, public, parameter :: DFTI_1D_LENGTH_EXCEEDS_INT32 = 9 integer, public, parameter :: DFTI_MAX_MESSAGE_LENGTH = 80 integer, public, parameter :: DFTI_MAX_NAME_LENGTH = 10 integer, public, parameter :: DFTI_VERSION_LENGTH = 198 Derived Types type, public :: DFTI_DESCRIPTOR","tags":"","loc":"module/mkl_dft_type.html"},{"title":"MKL_DFTI – Quantum transport simulator","text":"Uses MKL_DFT_TYPE module~~mkl_dfti~~UsesGraph module~mkl_dfti MKL_DFTI module~mkl_dft_type MKL_DFT_TYPE module~mkl_dfti->module~mkl_dft_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mkl_dfti~~UsedByGraph module~mkl_dfti MKL_DFTI proc~do_mkl_dfti_conv fft_mod::do_mkl_dfti_conv proc~do_mkl_dfti_conv->module~mkl_dfti Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces DftiCreateDescriptor DftiCopyDescriptor DftiCommitDescriptor DftiSetValue DftiGetValue DftiComputeForward DftiComputeBackward DftiFreeDescriptor DftiErrorClass DftiErrorMessage Interfaces public        interface DftiCreateDescriptor public  function dfti_create_descriptor_1d(desc, precision, domain, dim, length) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: precision integer, intent(in) :: domain integer, intent(in) :: dim integer, intent(in) :: length Return Value integer public  function dfti_create_descriptor_highd(desc, precision, domain, dim, length) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: precision integer, intent(in) :: domain integer, intent(in) :: dim integer, intent(in), DIMENSION(*) :: length Return Value integer public  function dfti_create_descriptor_s_1d(desc, s, dom, one, dim) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in) :: s integer, intent(in) :: dom integer, intent(in) :: one integer, intent(in) :: dim Return Value integer public  function dfti_create_descriptor_s_md(desc, s, dom, many, dims) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in) :: s integer, intent(in) :: dom integer, intent(in) :: many integer, intent(in), DIMENSION(*) :: dims Return Value integer public  function dfti_create_descriptor_d_1d(desc, d, dom, one, dim) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in) :: d integer, intent(in) :: dom integer, intent(in) :: one integer, intent(in) :: dim Return Value integer public  function dfti_create_descriptor_d_md(desc, d, dom, many, dims) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in) :: d integer, intent(in) :: dom integer, intent(in) :: many integer, intent(in), DIMENSION(*) :: dims Return Value integer public        interface DftiCopyDescriptor public  function dfti_copy_descriptor_external(desc, new_desc) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc type( DFTI_DESCRIPTOR ), POINTER :: new_desc Return Value integer public        interface DftiCommitDescriptor public  function dfti_commit_descriptor_external(desc) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc Return Value integer public        interface DftiSetValue public  function dfti_set_value_intval(desc, OptName, IntVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(in) :: IntVal Return Value integer public  function dfti_set_value_sglval(desc, OptName, sglval) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_SPKP), intent(in) :: sglval Return Value integer public  function dfti_set_value_dblval(desc, OptName, DblVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_DPKP), intent(in) :: DblVal Return Value integer public  function dfti_set_value_intvec(desc, OptName, IntVec) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(in), DIMENSION(*) :: IntVec Return Value integer public  function dfti_set_value_chars(desc, OptName, Chars) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName character(len=*), intent(in) :: Chars Return Value integer public        interface DftiGetValue public  function dfti_get_value_intval(desc, OptName, IntVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(out) :: IntVal Return Value integer public  function dfti_get_value_sglval(desc, OptName, sglval) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_SPKP), intent(out) :: sglval Return Value integer public  function dfti_get_value_dblval(desc, OptName, DblVal) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName real(kind=DFTI_DPKP), intent(out) :: DblVal Return Value integer public  function dfti_get_value_intvec(desc, OptName, IntVec) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName integer, intent(out), DIMENSION(*) :: IntVec Return Value integer public  function dfti_get_value_chars(desc, OptName, Chars) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc integer, intent(in) :: OptName character(len=*), intent(out) :: Chars Return Value integer public        interface DftiComputeForward public  function dfti_compute_forward_s(desc, sSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: sSrcDst Return Value integer public  function dfti_compute_forward_c(desc, cSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: cSrcDst Return Value integer public  function dfti_compute_forward_ss(desc, sSrcDstRe, sSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstRe real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstIm Return Value integer public  function dfti_compute_forward_sc(desc, sSrc, cDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrc complex(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: cDst Return Value integer public  function dfti_compute_forward_cc(desc, cSrc, cDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: cSrc complex(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: cDst Return Value integer public  function dfti_compute_forward_ssss(desc, sSrcRe, sSrcIm, sDstRe, sDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcRe real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcIm real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstRe real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstIm Return Value integer public  function dfti_compute_forward_d(desc, dSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: dSrcDst Return Value integer public  function dfti_compute_forward_z(desc, zSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: zSrcDst Return Value integer public  function dfti_compute_forward_dd(desc, dSrcDstRe, dSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstRe real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstIm Return Value integer public  function dfti_compute_forward_dz(desc, dSrc, zDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrc complex(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: zDst Return Value integer public  function dfti_compute_forward_zz(desc, zSrc, zDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: zSrc complex(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: zDst Return Value integer public  function dfti_compute_forward_dddd(desc, dSrcRe, dSrcIm, dDstRe, dDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcRe real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcIm real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstRe real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstIm Return Value integer public        interface DftiComputeBackward public  function dfti_compute_backward_s(desc, sSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: sSrcDst Return Value integer public  function dfti_compute_backward_c(desc, cSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(inout), DIMENSION(*) :: cSrcDst Return Value integer public  function dfti_compute_backward_ss(desc, sSrcDstRe, sSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstRe real(kind=DFTI_SPKP), DIMENSION(*) :: sSrcDstIm Return Value integer public  function dfti_compute_backward_cs(desc, cSrc, sDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: cSrc real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDst Return Value integer public  function dfti_compute_backward_cc(desc, cSrc, cDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: cSrc complex(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: cDst Return Value integer public  function dfti_compute_backward_ssss(desc, sSrcRe, sSrcIm, sDstRe, sDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcRe real(kind=DFTI_SPKP), intent(in), DIMENSION(*) :: sSrcIm real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstRe real(kind=DFTI_SPKP), intent(out), DIMENSION(*) :: sDstIm Return Value integer public  function dfti_compute_backward_d(desc, dSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: dSrcDst Return Value integer public  function dfti_compute_backward_z(desc, zSrcDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(inout), DIMENSION(*) :: zSrcDst Return Value integer public  function dfti_compute_backward_dd(desc, dSrcDstRe, dSrcDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstRe real(kind=DFTI_DPKP), DIMENSION(*) :: dSrcDstIm Return Value integer public  function dfti_compute_backward_zd(desc, zSrc, dDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: zSrc real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDst Return Value integer public  function dfti_compute_backward_zz(desc, zSrc, zDst) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc complex(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: zSrc complex(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: zDst Return Value integer public  function dfti_compute_backward_dddd(desc, dSrcRe, dSrcIm, dDstRe, dDstIm) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcRe real(kind=DFTI_DPKP), intent(in), DIMENSION(*) :: dSrcIm real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstRe real(kind=DFTI_DPKP), intent(out), DIMENSION(*) :: dDstIm Return Value integer public        interface DftiFreeDescriptor public  function dfti_free_descriptor_external(desc) Arguments Type Intent Optional Attributes Name type( DFTI_DESCRIPTOR ), POINTER :: desc Return Value integer public        interface DftiErrorClass public  function dfti_error_class_external(Status, ErrorClass) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Status integer, intent(in) :: ErrorClass Return Value logical public        interface DftiErrorMessage public  function dfti_error_message_external(Status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Status Return Value character(len=DFTI_MAX_MESSAGE_LENGTH)","tags":"","loc":"module/mkl_dfti.html"},{"title":"deviceHam_mod – Quantum transport simulator","text":"Used by module~~deviceham_mod~~UsedByGraph module~deviceham_mod deviceHam_mod program~main main program~main->module~deviceham_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines devH_build_fromCOOfile devH_build_fromWannierFile Subroutines public  subroutine devH_build_fromCOOfile (hfname, Hii, H1i, Sii, ext, contactBlockSize, nx, use0index, iscomplex, threshold, blocksize, sfname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: hfname input H file name type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: Hii Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: H1i Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: Sii Hamiltonian blocks integer, intent(in) :: ext (2) number of extension blocks on left/right side integer, intent(in) :: contactBlockSize (2) number of orbitals in the contact block integer, intent(out) :: nx total number of slices logical, intent(in), optional :: use0index logical, intent(in), optional :: iscomplex real(kind=dp), intent(in), optional :: threshold integer, intent(in), optional :: blocksize blocksize of H character(len=*), intent(in), optional :: sfname input S file name public  subroutine devH_build_fromWannierFile (fname, Hii, H1i, Sii, nx, nslab, nband, nk, k, length_x, lreorder_axis, axis) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name type( type_matrix_complex ), intent(inout), dimension(:, :), allocatable :: Hii Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:, :), allocatable :: H1i Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:, :), allocatable :: Sii overlap matrix blocks integer, intent(in) :: nx number of slabs integer, intent(in) :: nslab number of cells per slab integer, intent(out) :: nband number of bands/orbitals per cell (from wannier90) integer, intent(in) :: nk real(kind=dp), intent(in) :: k (2,nk) real(kind=dp), intent(out) :: length_x logical, intent(in), optional :: lreorder_axis whether to reorder axis integer, intent(in), optional :: axis (3) permutation order","tags":"","loc":"module/deviceham_mod.html"},{"title":"wannierHam3d – Quantum transport simulator","text":"Wannier-related functions ! construct the diagonal and off-diagonal blocks H(I,I), H(I+1,I)\n! construct the fully periodic Hamiltonian matrix\n! construct the full-device Hamiltonian Matrix\n! construct the diagonal and off-diagonal blocks V(I,I), V(I+1,I)\n! construct the bare Coulomb Matrix for the full-device\n! construct the diagonal and off-diagonal blocks P(I,I), P(I+1,I) Used by module~~wannierham3d~~UsedByGraph module~wannierham3d wannierHam3d proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->module~wannierham3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables wannier_center alpha beta b1 b2 Lx Ly Lz CBM VBM Eg kt_CBM kt_VBM nb nvb spin_deg Functions norm cross eig eigv Subroutines w90_free_memory w90_load_from_file w90_MAT_DEF w90_MAT_DEF_full_device w90_bare_coulomb_blocks w90_bare_coulomb_full_device w90_momentum_blocks w90_momentum_full_device invert Variables Type Visibility Attributes Name Initial real(kind=8), public, allocatable :: wannier_center (:,:) real(kind=8), public, DIMENSION(3) :: alpha real(kind=8), public, DIMENSION(3) :: beta real(kind=8), public, DIMENSION(3) :: b1 real(kind=8), public, DIMENSION(3) :: b2 real(kind=8), public :: Lx real(kind=8), public :: Ly real(kind=8), public :: Lz real(kind=8), public :: CBM real(kind=8), public :: VBM real(kind=8), public :: Eg real(kind=8), public :: kt_CBM real(kind=8), public :: kt_VBM integer, public :: nb integer, public :: nvb integer, public :: spin_deg Functions public  function norm (vector) Arguments Type Intent Optional Attributes Name real(kind=8) :: vector (3) Return Value real(kind=8) public  function cross (a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), DIMENSION(3) :: a real(kind=8), intent(in), DIMENSION(3) :: b Return Value real(kind=8), DIMENSION(3) public  function eig (NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) public  function eigv (NN, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NN complex(kind=8), intent(inout), DIMENSION(:, :) :: A Return Value real(kind=8), (NN) Subroutines public  subroutine w90_free_memory () Arguments None public  subroutine w90_load_from_file (fid, lreorder_axis, axis) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fid logical, intent(in), optional :: lreorder_axis integer, intent(in), optional :: axis (3) public  subroutine w90_MAT_DEF (Hii, H1i, kx, ky, kz, ns) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: Hii complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: H1i real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: ns public  subroutine w90_MAT_DEF_full_device (Ham, ky, kz, length, NS) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(NB*length, NB*length) :: Ham real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: length integer, intent(in), optional :: NS public  subroutine w90_bare_coulomb_blocks (Hii, H1i, kx, ky, kz, eps, r0, ns, ldiag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: Hii complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns) :: H1i real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz real(kind=8), intent(in) :: eps real(kind=8), intent(in) :: r0 integer, intent(in) :: ns logical, intent(in) :: ldiag public  subroutine w90_bare_coulomb_full_device (V, ky, kz, length, eps, r0, ldiag, NS, method) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), dimension(NB*length, NB*length) :: V real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: length real(kind=8), intent(in) :: eps real(kind=8), intent(in) :: r0 logical, intent(in) :: ldiag integer, intent(in), optional :: NS character(len=*), intent(in), optional :: method public  subroutine w90_momentum_blocks (Hii, H1i, kx, ky, kz, ns, method) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns, 3) :: Hii complex(kind=8), intent(out), DIMENSION(NB*ns, NB*ns, 3) :: H1i real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: ns character(len=*), intent(in) :: method public  subroutine w90_momentum_full_device (Ham, ky, kz, length, NS, method) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(NB*length, NB*length, 3) :: Ham real(kind=8), intent(in) :: ky real(kind=8), intent(in) :: kz integer, intent(in) :: length integer, intent(in), optional :: NS character(len=*), intent(in) :: method public  subroutine invert (A, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout), dimension(nn, nn) :: A integer :: nn","tags":"","loc":"module/wannierham3d.html"},{"title":"fft_mod – Quantum transport simulator","text":"FFT, conv, and corr functions Contents Functions corr1d corr1d2 conv1d conv1d2 Subroutines do_mkl_dfti_conv Functions public  function corr1d (n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n) character(len=*), intent(in) :: method Return Value complex(kind=8), (2*n-1) public  function corr1d2 (n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n) character(len=*), intent(in) :: method Return Value complex(kind=8), (n) public  function conv1d (n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n*2-1) character(len=*), intent(in) :: method Return Value complex(kind=8), (n) public  function conv1d2 (n, X, Y, method) result(Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=8), intent(in) :: X (n) complex(kind=8), intent(in) :: Y (n) character(len=*), intent(in) :: method Return Value complex(kind=8), (n) Subroutines public  subroutine do_mkl_dfti_conv (n, X_in, Y_in, Z_out) Arguments Type Intent Optional Attributes Name integer :: n complex(kind=8) :: X_in (n) complex(kind=8) :: Y_in (n) complex(kind=8) :: Z_out (n)","tags":"","loc":"module/fft_mod.html"},{"title":"cuda_rgf_mod – Quantum transport simulator","text":"Recursive  Green's  function  solvers module Sancho-Rubio Contents Subroutines sancho Subroutines public  subroutine sancho (nm, E, S00, H00, H10, G00, GBB) Arguments Type Intent Optional Attributes Name integer :: nm real(kind=dp) :: E complex(kind=dp), intent(in) :: S00 (nm,nm) complex(kind=dp), intent(in) :: H00 (nm,nm) complex(kind=dp), intent(in) :: H10 (nm,nm) complex(kind=dp), intent(out) :: G00 (nm,nm) complex(kind=dp), intent(out) :: GBB (nm,nm)","tags":"","loc":"module/cuda_rgf_mod~2.html"},{"title":"Output – Quantum transport simulator","text":"Uses matrix_c module~~output~~UsesGraph module~output Output module~matrix_c matrix_c module~output->module~matrix_c cublas cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~output~~UsedByGraph module~output Output proc~negf_solve negf_mod::negf_solve proc~negf_solve->module~output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines write_spectrum_summed_over_k Subroutines public  subroutine write_spectrum_summed_over_k (dataset, i, G, nen, en, nk, length, NB, NS, Lx, coeff, append) !$omp parallel default(shared) private(ik, ib) reduction(+:tr)\n!$omp do\n!$omp end do\n!$omp end parallel Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dataset integer, intent(in) :: i type( type_matrix_complex ), intent(in), dimension(length, nen, nk) :: G integer, intent(in) :: nen real(kind=dp), intent(in) :: en (nen) integer, intent(in) :: nk integer, intent(in) :: length integer, intent(in) :: NB integer, intent(in) :: NS real(kind=dp), intent(in) :: Lx real(kind=dp), intent(in) :: coeff (2) logical, intent(in), optional :: append","tags":"","loc":"module/output.html"},{"title":"static – Quantum transport simulator","text":"constants Contents Variables dp cone czero c1i hbar m0 eps0 c0 e0 pi twopi m0_ev kg2eV hbar_ev BOLTZ hb2m Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = 8 complex(kind=dp), public, parameter :: cone = dcmplx(1.0d0, 0.0d0) complex(kind=dp), public, parameter :: czero = dcmplx(0.0d0, 0.0d0) complex(kind=dp), public, parameter :: c1i = dcmplx(0.0d0, 1.0d0) real(kind=dp), public, parameter :: hbar = 1.0546d-34 real(kind=dp), public, parameter :: m0 = 9.109d-31 real(kind=dp), public, parameter :: eps0 = 8.854d-12 real(kind=dp), public, parameter :: c0 = 2.998d8 real(kind=dp), public, parameter :: e0 = 1.6022d-19 real(kind=dp), public, parameter :: pi = 3.14159265359d0 real(kind=dp), public, parameter :: twopi = 3.14159265359d0*2.0d0 real(kind=dp), public, parameter :: m0_ev = 5.6856D-16 real(kind=dp), public, parameter :: kg2eV = m0_ev/m0 real(kind=dp), public, parameter :: hbar_ev = 6.58211899E-16 real(kind=dp), public, parameter :: BOLTZ = 8.61734d-05 real(kind=dp), public, parameter :: hb2m = 7.6305d-16","tags":"","loc":"module/static.html"},{"title":"graph_partition – Quantum transport simulator","text":"Library cuts a graph into slices which have only connections with the left\nand right neighbor slices. slice is the main subroutine to call. Used by module~~graph_partition~~UsedByGraph module~graph_partition graph_partition proc~devh_build_fromcoofile deviceHam_mod::devH_build_fromCOOfile proc~devh_build_fromcoofile->module~graph_partition Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces slice Functions getPointsInAllSlices getPointsInSlice testSlicing Subroutines SaveSlicesTxt AddEdge ReadEdgeFromText ReadGraphFromText SaveTxtGraph convert_fromCOO Interfaces public        interface slice private  subroutine slice_1contact(g, E, S) Procedure returns the slices of the graph going from 1 edge. BFS algorithm is used to\nassign a distance to the edge for each point, then the slice number = distance. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E (:) Left Edge points' IDs integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number private recursive subroutine slice_2contacts(g, E1, E2, NMAX, S) Function returns the slices of the graph. The problem is solved in a divide-and-conquer\nmanner, using recursive bisection method described in [Journal of Computational Physics 228 (2009) 8548–8565]. Compute the left/right distance of points to left/right edges, by calling [[dist]] Divide the graph into 2 'balanced' parts, based on if the right distance is larger than the left distance Find the connections between 2 parts, and define a new set of edges Recursion, Slice seperately the 2 parts Combine the results Stop condition: either the 2 edges touch each other, or the number of points in the remaining part gets\nsmall enough. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E1 (:) Left Edge points' IDs integer, intent(in) :: E2 (:) RightEdge points' IDs integer, intent(in) :: NMAX Maximum number of points in a single slice integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number Functions public  function getPointsInAllSlices (S) result(v) Function returns the points in all the slices Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information Return Value integer, (sum(S(1,:))-size(S,2)) public  function getPointsInSlice (S, i) result(v) Function returns the points in a slice number i Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information integer, intent(in) :: i Slice number Return Value integer, (S(1,i)-1) public  function testSlicing (g, S) result(b) Function tests if a slicing from subroutine slice of the graph is consistent by\nlooking at the neighbors of all the points in each slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: S (:,:) Slices, 2nd index is the Slice number Return Value integer Test result Subroutines public  subroutine SaveSlicesTxt (handle, S, X, Y, Z) Procedure saves the slice information into a text file Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle file unit number integer, intent(in) :: S (:,:) Slices information real(kind=dp), intent(in), optional :: X (:) real(kind=dp), intent(in), optional :: Y (:) real(kind=dp), intent(in), optional :: Z (:) public  subroutine AddEdge (g, ij) Subroutine update the graph data (g) by adding an edge from node-i to node-j.\nThe memory space for (g) is already allocated before calling this procedure Arguments Type Intent Optional Attributes Name integer, intent(out) :: g (:,:) integer, intent(in) :: ij (2) public  subroutine ReadEdgeFromText (fname, E, use0index) Subroutine for reading the edge data from an ASCII text file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: E (:) Edge index logical, intent(in), optional :: use0index public  subroutine ReadGraphFromText (fname, g, threshold, use0index) Subroutine for reading in the graph data from an ASCII text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: g (:,:) Graph connectivity table. real(kind=8), intent(in), optional :: threshold logical, intent(in), optional :: use0index public  subroutine SaveTxtGraph (handle, g) Subroutine for saving the graph data into an ASCII text file. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle Unit number of the input text file integer, intent(in) :: g (:,:) Graph connectivity table. public  subroutine convert_fromCOO (nnz, row, col, g) Subroutine convert a sparse matrix in COO format into a graph\n  The graph will be allocated inside the subroutine, so remember to deallocate the memory outside Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnz integer, intent(in), dimension(nnz) :: row IA and JA index vectors of a CSR matrix integer, intent(in), dimension(nnz) :: col IA and JA index vectors of a CSR matrix integer, intent(out), allocatable :: g (:,:) Graph connectivity table","tags":"","loc":"module/graph_partition.html"},{"title":"rgf_mod – Quantum transport simulator","text":"Recursive  Green's  function  solvers module\n Recursive Forward Green's solver\n Recursive Backward Green's solver\n Fermi distribution function\n Sancho-Rubio Uses omp_lib module~~rgf_mod~~UsesGraph module~rgf_mod rgf_mod omp_lib omp_lib module~rgf_mod->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines rgf_variableblock_forward rgf_variableblock_backward Subroutines public  subroutine rgf_variableblock_forward (nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) !$omp critical\n        open (unit=10, file='sancho_g00.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(G00))\n        close (10)\n        open (unit=10, file='sancho_gbb.dat', position='append')\n        write (10, ) En, 2, -aimag(trace(Gbb))\n        close (10)\n!$omp end critical Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) type( type_matrix_complex ), intent(inout) :: Gl (nx) type( type_matrix_complex ), intent(inout) :: Gln (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre public  subroutine rgf_variableblock_backward (nx, En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) !$omp critical\n       open (unit=10, file='sancho_g00.dat', position='append')\n       write (10, ) En, 2, -aimag(trace(G00))\n       close (10)\n       open (unit=10, file='sancho_gbb.dat', position='append')\n       write (10, ) En, 2, -aimag(trace(Gbb))\n       close (10)\n       !$omp end critical Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx lenght of the device real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (nx) type( type_matrix_complex ), intent(in) :: H1i (nx+1) type( type_matrix_complex ), intent(in) :: Sii (nx) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (nx) type( type_matrix_complex ), intent(in) :: sigma_r_ph (nx) type( type_matrix_complex ), intent(inout) :: G_r (nx) type( type_matrix_complex ), intent(inout) :: G_lesser (nx) type( type_matrix_complex ), intent(inout) :: G_greater (nx) type( type_matrix_complex ), intent(inout) :: Jdens (nx) type( type_matrix_complex ), intent(inout) :: Gl (nx) type( type_matrix_complex ), intent(inout) :: Gln (nx) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre","tags":"","loc":"module/rgf_mod.html"},{"title":"matrix_c – Quantum transport simulator","text":"Complex Matrix Library\nA 2D complex array, element to form a list/table of complex matrices Uses cublas module~~matrix_c~~UsesGraph module~matrix_c matrix_c cublas cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~matrix_c~~UsedByGraph module~matrix_c matrix_c module~output Output module~output->module~matrix_c proc~devh_build_fromcoofile deviceHam_mod::devH_build_fromCOOfile proc~devh_build_fromcoofile->module~matrix_c proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile proc~devh_build_fromwannierfile->module~matrix_c proc~negf_solve negf_mod::negf_solve proc~negf_solve->module~matrix_c proc~negf_solve->module~output proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->module~matrix_c proc~rgf_variableblock_forward rgf_mod::rgf_variableblock_forward proc~rgf_variableblock_forward->module~matrix_c program~main main program~main->module~matrix_c Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces operator(.m.) operator(**) operator(.md.) operator(.dm.) sizeof ReadTxt SaveTxt show malloc free eye diag trace Derived Types type_matrix_complex Functions array_eye matrix_list_size matrix_list_size2 array_size matrix_size matrix_size_dim array_testHermitian array_times_array_dagger array_dagger_times_array array_times_array array_times_array_simple array_power array_transpose array_eigen array_to_diag array_inverse2 array_inverse array_trace matrix_trace Subroutines matrix_alloc matrix_alloc2 array_alloc array_alloc2 matrix_list_allocElem matrix_list_allocElem2 matrix_free matrix_list_print array_print matrix_read array_print_on_screen matrix_copy triMUL_C MUL_C Interfaces public        interface operator(.m.) public pure function array_times_array_simple (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2)) public        interface operator(**) public  function array_power (A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) public pure function array_transpose (A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1)) public        interface operator(.md.) public pure function array_times_array_dagger (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1)) public        interface operator(.dm.) public pure function array_dagger_times_array (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2)) public        interface sizeof public pure function array_size (this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) public pure function matrix_size (this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) public pure function matrix_list_size (list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) public pure function matrix_size_dim (this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function matrix_list_size2 (list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list)) public        interface ReadTxt public  subroutine matrix_read (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A public        interface SaveTxt public  subroutine matrix_list_print (handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) public  subroutine array_print (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:) public        interface show public  subroutine array_print_on_screen (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) public        interface malloc public pure subroutine matrix_list_allocElem2 (this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_list_allocElem (this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_alloc (M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) public pure subroutine matrix_alloc2 (M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) public pure subroutine array_alloc (M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn public pure subroutine array_alloc2 (M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2) public        interface free public elemental subroutine matrix_free (this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this public        interface eye public pure function array_eye (n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n) public        interface diag public pure function array_to_diag (A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1)) public        interface trace public pure function array_trace (A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) public elemental function matrix_trace (M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8) Derived Types type, public :: type_matrix_complex Components Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: m (:,:) complex matrix integer, public :: size (2) matrix size Functions public pure function array_eye (n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n) public pure function matrix_list_size (list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) public pure function matrix_list_size2 (list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list)) public pure function array_size (this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) public pure function matrix_size (this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) public pure function matrix_size_dim (this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function array_testHermitian (M) result(b) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: M (:,:) Return Value logical public pure function array_times_array_dagger (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1)) public pure function array_dagger_times_array (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2)) public pure function array_times_array (A, B, trA, trB, cjA, cjB) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) logical(kind=4), intent(in) :: trA logical(kind=4), intent(in) :: trB logical(kind=4), intent(in), optional :: cjA logical(kind=4), intent(in), optional :: cjB Return Value complex(kind=8), (size(A,merge(2,1,trA)),size(B,merge(1,2,trB))) public pure function array_times_array_simple (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2)) public  function array_power (A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) public pure function array_transpose (A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1)) public  function array_eigen (A, B, eigvec, itype, uplo) result(eig) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in), optional :: B (:,:) complex(kind=8), intent(inout), optional :: eigvec (size(A,1),size(A,2)) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: uplo Return Value real(kind=8), (size(A,1)) public pure function array_to_diag (A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1)) public  function array_inverse2 (A, UPLO) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: UPLO Return Value complex(kind=8), (size(A,dim=1),size(A,dim=1)) public  function array_inverse (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), dimension(size(A, dim=1), size(A, dim=1)) public pure function array_trace (A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) public elemental function matrix_trace (M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8) Subroutines public pure subroutine matrix_alloc (M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) public pure subroutine matrix_alloc2 (M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) public pure subroutine array_alloc (M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn public pure subroutine array_alloc2 (M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2) public pure subroutine matrix_list_allocElem (this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_list_allocElem2 (this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(inout) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public elemental subroutine matrix_free (this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this public  subroutine matrix_list_print (handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) public  subroutine array_print (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:) public  subroutine matrix_read (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A public  subroutine array_print_on_screen (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) public  subroutine matrix_copy (matrices, tab) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: matrices (:) complex(kind=8), intent(out) :: tab (:,:,:) public  subroutine triMUL_C (A, B, C, R, trA, trB, trC) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in), dimension(:, :) :: A complex(kind=8), intent(in), dimension(:, :) :: B complex(kind=8), intent(in), dimension(:, :) :: C complex(kind=8), intent(inout), allocatable :: R (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB character(len=1), intent(in) :: trC public  subroutine MUL_C (A, B, trA, trB, R) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB complex(kind=8), intent(inout), allocatable :: R (:,:)","tags":"","loc":"module/matrix_c.html"},{"title":"example_sgemm – Quantum transport simulator","text":"Contents Variables A B C ref tstart tstop elapsed_time gflops sum L2 devPtrA devPtrB devPtrC n size_of_real i j values seed index pi Source Code example_sgemm Variables Type Attributes Name Initial real(kind=4), dimension(:,:), allocatable :: A real(kind=4), dimension(:,:), allocatable :: B real(kind=4), dimension(:,:), allocatable :: C real(kind=4), dimension(:,:), allocatable :: ref real(kind=8) :: tstart real(kind=8) :: tstop real(kind=8) :: elapsed_time real(kind=8) :: gflops real(kind=8) :: sum real(kind=8) :: L2 integer(kind=8) :: devPtrA integer(kind=8) :: devPtrB integer(kind=8) :: devPtrC integer :: n = 2048 integer :: size_of_real = 4 integer :: i integer :: j integer, dimension(8) :: values integer :: seed integer :: index real(kind=8), parameter :: pi = 4.0*atan(1.0) Source Code program example_sgemm implicit none real ( 4 ), dimension (:,:), allocatable :: A , B , C , ref real ( 8 ) :: tstart , tstop , elapsed_time real ( 8 ) :: gflops , sum , L2 integer ( 8 ) :: devPtrA , devPtrB , devPtrC integer :: n = 2048 integer :: size_of_real = 4 !4->single precision; 8->double precision integer :: i , j integer , dimension ( 8 ) :: values integer :: seed integer :: index real ( 8 ), parameter :: pi = 4.0 * atan ( 1.0 ) allocate ( A ( n , n )) allocate ( B ( n , n )) allocate ( C ( n , n )) allocate ( ref ( n , n )) call cublas_alloc ( n * n , size_of_real , devPtrA ) call cublas_alloc ( n * n , size_of_real , devPtrB ) call cublas_alloc ( n * n , size_of_real , devPtrC ) call date_and_time ( VALUES = values ) !values(8) = milisecs of the second seed = values ( 8 ) !using value in milisecs as seeder call srand ( seed ) !not a std implementation, but i like it better. !initiating matrix value do j = 1 , n do i = 1 , n A ( i , j ) = 1.0 B ( i , j ) = 2.0 end do end do !solution matrix C = 0.0 !reference matrix ref = 0.0 !  call cpu_time(tstart) !copy data to GPU call cublas_set_matrix ( n , n , size_of_real , A , n , devPtrA , n ) call cublas_set_matrix ( n , n , size_of_real , B , n , devPtrB , n ) call cublas_set_matrix ( n , n , size_of_real , C , n , devPtrC , n ) call cpu_time ( tstart ) !call SGEMM from CUBLAS call cublas_sgemm ( 'n' , 'n' , n , n , n , 1.0 , devPtrA , n , devPtrB , n , 0.0 , devPtrC , n ) !copy data from GPU call cublas_get_matrix ( n , n , size_of_real , devPtrC , n , C , n ) call cpu_time ( tstop ) elapsed_time = tstop - tstart !in seconds write ( * , * ) 'Matrix A ' , n , 'x' , n write ( * , * ) 'Matrix B ' , n , 'x' , n write ( * , 20 ) 'Elapsed time : ' , elapsed_time , 'secs' gflops = 2 * float ( n ) * float ( n ) * float ( n ) / ( elapsed_time * 1.0e9 ) write ( * , 10 ) 'Performance:' , gflops , ' GFLOPS' 10 format ( A12 , 2 X , 1 F0 . 4 , 2 X , A7 ) 20 format ( A15 , 2 X , 1 F0 . 8 , 2 X , A4 ) !reference from CPU ref = matmul ( A , B ) print * , C ( 1 , 1 ) print * , ref ( 1 , 1 ) index = n sum = 0.0 !show result do j = 1 , index do i = 1 , index sum = sum + ( ref ( i , j ) - C ( i , j ) ) * ( ref ( i , j ) - C ( i , j ) ) end do end do L2 = sqrt ( sum / ( float ( index ) * float ( index ) ) ) write ( * , 30 ) 'L2-residual :' , L2 30 format ( A15 , 2 X , 1E18 . 8 ) !Free GPU memory call cublas_free ( devPtrA ) call cublas_free ( devPtrB ) call cublas_free ( devPtrC ) end program example_sgemm","tags":"","loc":"program/example_sgemm.html"},{"title":"main – Quantum transport simulator","text":"Uses negf_mod deviceHam_mod matrix_c omp_lib program~~main~~UsesGraph program~main main module~deviceham_mod deviceHam_mod program~main->module~deviceham_mod module~matrix_c matrix_c program~main->module~matrix_c module~negf_mod negf_mod program~main->module~negf_mod omp_lib omp_lib program~main->omp_lib cublas cublas module~matrix_c->cublas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~main~~CallsGraph program~main main proc~devh_build_fromcoofile deviceHam_mod::devH_build_fromCOOfile program~main->proc~devh_build_fromcoofile proc~devh_build_fromwannierfile deviceHam_mod::devH_build_fromWannierFile program~main->proc~devh_build_fromwannierfile proc~negf_solve negf_mod::negf_solve program~main->proc~negf_solve proc~w90_free_memory wannierHam3d::w90_free_memory proc~devh_build_fromwannierfile->proc~w90_free_memory proc~w90_load_from_file wannierHam3d::w90_load_from_file proc~devh_build_fromwannierfile->proc~w90_load_from_file proc~w90_mat_def wannierHam3d::w90_MAT_DEF proc~devh_build_fromwannierfile->proc~w90_mat_def proc~cuda_rgf_constblocksize cuda_rgf_mod::cuda_rgf_constblocksize proc~negf_solve->proc~cuda_rgf_constblocksize proc~cuda_rgf_finish cuda_rgf_mod::cuda_rgf_finish proc~negf_solve->proc~cuda_rgf_finish proc~cuda_rgf_init cuda_rgf_mod::cuda_rgf_init proc~negf_solve->proc~cuda_rgf_init proc~write_spectrum_summed_over_k Output::write_spectrum_summed_over_k proc~negf_solve->proc~write_spectrum_summed_over_k omp_get_wtime omp_get_wtime proc~cuda_rgf_constblocksize->omp_get_wtime zaxpy zaxpy proc~cuda_rgf_constblocksize->zaxpy zcopy zcopy proc~cuda_rgf_constblocksize->zcopy zgemm zgemm proc~cuda_rgf_constblocksize->zgemm zgetrf zgetrf proc~cuda_rgf_constblocksize->zgetrf zgetrs zgetrs proc~cuda_rgf_constblocksize->zgetrs zscal zscal proc~cuda_rgf_constblocksize->zscal proc~cross~2 wannierHam3d::cross proc~w90_load_from_file->proc~cross~2 proc~norm wannierHam3d::norm proc~w90_load_from_file->proc~norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Variables Hii H1i Sii nx ns nen nk nb temp mu emin emax k Lx file_path calc_type rc fu nomp start finish ierr comm_size comm_rank local_NE first_local_energy Source Code main Variables Type Attributes Name Initial type( type_matrix_complex ), allocatable, dimension(:, :) :: Hii type( type_matrix_complex ), allocatable, dimension(:, :) :: H1i type( type_matrix_complex ), allocatable, dimension(:, :) :: Sii integer :: nx integer :: ns integer :: nen integer :: nk integer :: nb real(kind=8), dimension(2) :: temp real(kind=8), dimension(2) :: mu real(kind=8) :: emin real(kind=8) :: emax real(kind=8) :: k (2,1) real(kind=8) :: Lx character(len=10) :: file_path character(len=10) :: calc_type integer :: rc integer :: fu integer :: nomp real(kind=8) :: start real(kind=8) :: finish integer(kind=4) :: ierr integer(kind=4) :: comm_size integer(kind=4) :: comm_rank integer(kind=4) :: local_NE integer(kind=4) :: first_local_energy Source Code PROGRAM main use omp_lib use negf_mod , only : negf_solve use matrix_c , only : type_matrix_complex , free use deviceHam_mod , only : devH_build_fromWannierFile , devH_build_fromCOOfile implicit none type ( type_matrix_complex ), allocatable , dimension (:, :) :: Hii , H1i , Sii integer :: nx , ns , nen , nk , nb real ( 8 ), dimension ( 2 ) :: temp , mu real ( 8 ) :: emin , emax real ( 8 ) :: k ( 2 , 1 ), Lx character ( len = 10 ) :: file_path character ( len = 10 ) :: calc_type integer :: rc , fu integer :: nomp ! openmp process number real ( 8 ) :: start , finish namelist / input / nx , ns , temp , mu , nk , nomp , nen , emin , emax , nb , calc_type ! MPI variables integer ( kind = 4 ) ierr integer ( kind = 4 ) comm_size integer ( kind = 4 ) comm_rank integer ( kind = 4 ) local_NE integer ( kind = 4 ) first_local_energy !    include \"mpif.h\" !    call MPI_Init(ierr) !    call MPI_Comm_size(MPI_COMM_WORLD, comm_size, ierr) !    call MPI_Comm_rank(MPI_COMM_WORLD, comm_rank, ierr) !    call MPI_Barrier(MPI_COMM_WORLD, ierr) comm_size = 1 comm_rank = 0 if ( comm_rank == 0 ) then print * , 'Comm Size =' , comm_size else print * , 'Comm Rank =' , comm_rank end if ! default values nx = 5 ns = 3 nb = 10 temp = 30 0.0d0 mu = 0.0d0 nk = 1 nen = 100 emin = - 1 0.0d0 emax = 5.0d0 k = 0.0d0 nomp = 4 calc_type = 'w90' print * , 'read input' ! Check whether file exists. file_path = 'input' inquire ( file = file_path , iostat = rc ) if ( rc /= 0 ) then write ( * , '(\"Warn: input file \", a, \" does not exist\")' ) file_path else ! Open and read Namelist file. open ( action = 'read' , file = file_path , iostat = rc , newunit = fu ) read ( nml = input , iostat = rc , unit = fu ) close ( fu ) end if call omp_set_num_threads ( nomp ) local_NE = nen / comm_size first_local_energy = local_NE * comm_rank + 1 if ( comm_rank == 0 ) then print * , \"read ham\" endif if ( calc_type == 'w90' ) then call devH_build_fromWannierFile ( 'ham_dat' , Hii , H1i , Sii , nx , ns , nb , nk , & k , Lx ) else call devH_build_fromCOOfile ( 'h_dat' , Hii , H1i , Sii , ( / 0 , 0 / ), ( / nb , nb / ), nx , & use0index = . true ., iscomplex = . false ., threshold = 1 d - 10 , blocksize = nb ) endif if ( comm_rank == 0 ) then print * , \"start NEGF solver ... \" endif start = omp_get_wtime () call negf_solve ( nx , nen , nk , emin , emax , Hii , H1i , Sii , temp , mu , & comm_size , comm_rank , local_NE , first_local_energy , NB , & NS , Lx ) finish = omp_get_wtime () if ( comm_rank == 0 ) then print * , \"Total Work took seconds\" , finish - start endif call free ( Hii ) call free ( H1i ) call free ( Sii ) !deallocate (Hii, H1i, Sii) ! call MPI_FINALIZE( ierr ) END PROGRAM main","tags":"","loc":"program/main.html"},{"title":"negf_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~negf_mod.f90~~EfferentGraph sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~cuda_rgf_mod.f90 cuda_rgf_mod.f90 sourcefile~negf_mod.f90->sourcefile~cuda_rgf_mod.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~negf_mod.f90->sourcefile~matrix_c.f90 sourcefile~output_mod.f90 output_mod.f90 sourcefile~negf_mod.f90->sourcefile~output_mod.f90 sourcefile~output_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~negf_mod.f90~~AfferentGraph sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules negf_mod Source Code negf_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! module negf_mod !! Non-equilibrium Green's function (NEGF) module, upper-level driver for solving the NEGF equations implicit none private integer , parameter :: dp = 8 public :: negf_solve contains subroutine negf_solve ( nx , nen , nk , emin , emax , Hii , H1i , Sii , temp , mu , & comm_size , comm_rank , local_NE , first_local_energy , nbnd , nslab , Lx ) use matrix_c , only : type_matrix_complex , malloc , free , sizeof use cuda_rgf_mod , only : cuda_rgf_variableblock_forward , cuda_rgf_constblocksize , cuda_rgf_init , cuda_rgf_finish ! use rgf_mod, only: rgf_variableblock_forward use Output , only : write_spectrum_summed_over_k use omp_lib type ( type_matrix_complex ), intent ( in ), dimension ( nx , nk ) :: Hii , Sii type ( type_matrix_complex ), intent ( in ), dimension ( nx + 1 , nk ) :: H1i integer ( kind = 4 ), intent ( in ) :: comm_size , comm_rank , local_NE , first_local_energy integer , intent ( in ) :: nx !! number of slabs integer , intent ( in ) :: nen !! number of energy points integer , intent ( in ) :: nk !! number of k points integer , intent ( in ) :: nbnd !! number of bands / orbitals per cell integer , intent ( in ) :: nslab !! number of cells in a slab real ( dp ), intent ( in ), dimension ( 2 ) :: temp !! temperatures real ( dp ), intent ( in ), dimension ( 2 ) :: mu !! chemical potentials real ( dp ), intent ( in ) :: Lx !! Lx ! ---- real ( dp ) :: emin , emax !! min and max energy range integer :: nm ( 2 , nx ), ik , ie , iter , NB , NS , i integer ( kind = 4 ) :: ierr real ( dp ) :: en ( nen ), dE , local_energies ( local_NE ) real ( dp ), dimension (:, :), allocatable :: mul , mur , templ , tempr type ( type_matrix_complex ), dimension ( nx , local_NE , nk ) :: sigma_lesser_ph , sigma_r_ph , G_r , G_lesser , G_greater type ( type_matrix_complex ), dimension (:), allocatable :: Jdens , Gl , Gln real ( dp ), dimension ( nen , nk ) :: tr , tre character ( len = 20 ) :: filename character ( len = 8 ) :: fmt character ( len = 4 ) :: rank_str logical :: append ! !    include \"mpif.h\" fmt = '(I4.4)' write ( rank_str , fmt ) comm_rank append = ( comm_rank /= 0 ) nm = sizeof ( Hii (:, 1 )) allocate ( mul ( nm ( 1 , 1 ), nm ( 1 , 1 ))) allocate ( templ ( nm ( 1 , 1 ), nm ( 1 , 1 ))) allocate ( mur ( nm ( 1 , nx ), nm ( 1 , nx ))) allocate ( tempr ( nm ( 1 , nx ), nm ( 1 , nx ))) mul = mu ( 1 ) mur = mu ( 2 ) templ = temp ( 1 ) tempr = temp ( 2 ) do ik = 1 , nk do ie = 1 , local_NE call malloc ( sigma_lesser_ph (:, ie , ik ), nx , nm ) call malloc ( sigma_r_ph (:, ie , ik ), nx , nm ) call malloc ( G_r (:, ie , ik ), nx , nm ) call malloc ( G_lesser (:, ie , ik ), nx , nm ) call malloc ( G_greater (:, ie , ik ), nx , nm ) end do end do ! if ( comm_rank == 0 ) then print * , 'allocate memory DONE' end if ! dE = ( emax - emin ) / dble ( nen - 1 ) forall ( ie = 1 : nen ) En ( ie ) = emin + dble ( ie - 1 ) * dE ! global energy vector do ie = 1 , local_NE local_energies ( ie ) = En ( ie + first_local_energy - 1 ) ! local energy vector of rank-i end do ! iter = 0 ! !$omp parallel default(shared) private(ie,ik,Jdens,Gl,Gln) allocate ( Jdens ( nx ), Gl ( nx ), Gln ( nx )) call malloc ( Jdens , nx , nm ) ! call malloc(Gl, nx, nm) ! call malloc(Gln, nx, nm) call cuda_rgf_init ( nm ( 1 , 1 )) !!$omp do do ie = 1 , local_NE do ik = 1 , nk !  call rgf_variableblock_forward(nx, local_energies(ie), mul, mur, TEMPl, TEMPr, & !      Hii(:, ik), H1i(:, ik), Sii(:, ik), sigma_lesser_ph(:, ie, ik), & !      sigma_r_ph(:, ie, ik), G_r(:, ie, ik), G_lesser(:, ie, ik), G_greater(:, ie, ik), & !      Jdens, Gl, Gln, tr(ie, ik), tre(ie, ik)) call cuda_rgf_constblocksize ( nm ( 1 , 1 ), nx , local_energies ( ie ), mul , mur , TEMPl , TEMPr , & Hii (:, ik ), H1i (:, ik ), Sii (:, ik ), sigma_lesser_ph (:, ie , ik ), & sigma_r_ph (:, ie , ik ), G_r (:, ie , ik ), G_lesser (:, ie , ik ), G_greater (:, ie , ik ), & Jdens , tr ( ie , ik ), tre ( ie , ik )) end do end do !!$omp end do call cuda_rgf_finish () call free ( Jdens ) ! call free(Gl) ! call free(Gln) deallocate ( Jdens ) ! deallocate(Gl,Gln) !$omp end parallel ! NB = nbnd NS = nslab do i = 0 , comm_size - 1 if ( i == comm_rank ) then filename = 'ldos' call write_spectrum_summed_over_k ( filename , iter , G_r , local_NE , local_energies , & nk , nx , NB , NS , Lx , ( / 1.0d0 , - 2.0d0 / ), append ) filename = 'ndos' call write_spectrum_summed_over_k ( filename , iter , G_lesser , local_NE , local_energies , & nk , nx , NB , NS , Lx , ( / 1.0d0 , 1.0d0 / ), append ) filename = 'pdos' call write_spectrum_summed_over_k ( filename , iter , G_greater , local_NE , local_energies , & nk , nx , NB , NS , Lx , ( / 1.0d0 , - 1.0d0 / ), append ) end if !            call MPI_Barrier(MPI_COMM_WORLD, ierr) end do ! if ( comm_rank == 0 ) then print * , 'free memory' end if deallocate ( mul , mur , tempr , templ ) ! call free ( sigma_lesser_ph ) call free ( sigma_r_ph ) call free ( G_r ) call free ( G_lesser ) call free ( G_greater ) ! end subroutine negf_solve end module negf_mod","tags":"","loc":"sourcefile/negf_mod.f90.html"},{"title":"linalg.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~linalg.f90~~AfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~_cuda_rgf_mod.f90 _cuda_rgf_mod.f90 sourcefile~_cuda_rgf_mod.f90->sourcefile~linalg.f90 sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~rgf_mod.f90->sourcefile~linalg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules linalg Source Code linalg.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! module linalg use cublas implicit none private integer , parameter :: dp = 8 complex ( dp ), parameter :: czero = dcmplx ( 0.0d0 , 0.0d0 ) public :: invert , invert_banded , cross , eig , eigv CONTAINS ! matrix inversion !$omp declare target device_type(any) subroutine invert ( A , nn ) integer :: info , nn integer , dimension (:), allocatable :: ipiv complex ( 8 ), dimension ( nn , nn ), intent ( inout ) :: A complex ( 8 ), dimension (:), allocatable :: work allocate ( work ( nn * nn )) allocate ( ipiv ( nn )) call zgetrf ( nn , nn , A , nn , ipiv , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgetrf failed, info=' , info A = czero else call zgetri ( nn , A , nn , ipiv , work , nn * nn , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgetri failed, info=' , info A = czero end if end if deallocate ( work ) deallocate ( ipiv ) end subroutine invert !$omp declare target device_type(any) ! find the inverse of a banded matrix A by solving a system of linear equations !   on exit, A contains the banded matrix of inv(A) !   banded format see [https://netlib.org/lapack/lug/node124.html] subroutine invert_banded ( A , nn , nb ) integer , intent ( in ) :: nn , nb complex ( 8 ), intent ( inout ) :: A ( 3 * nb + 1 , nn ) complex ( 8 ), allocatable :: work (:), B (:, :), X (:, :) integer , allocatable :: ipiv (:) integer :: info , lda , lwork , ldb , i , nrhs allocate ( ipiv ( nn )) allocate ( work ( nn * nn )) lda = 3 * nb + 1 call zgbtrf ( nn , nn , nb , nb , A , lda , ipiv , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgbtrf failed, info=' , info call abort () end if ldb = 1 allocate ( B ( ldb , nn )) allocate ( X ( lda , nn )) nrhs = ldb do i = 1 , nn B = 0.0d0 B ( 1 , i ) = 1.0d0 call zgbtrs ( 'N' , nn , nb , nb , nrhs , A , lda , ipiv , B , ldb , info ) if ( info . ne . 0 ) then print * , 'SEVERE warning: zgbtrs failed, info=' , info call abort () end if X ( 1 : nb * 2 + 1 , i ) = B ( 1 , i - nb : i + nb ) end do A = X deallocate ( B , work , ipiv , X ) end subroutine invert_banded ! vector cross-product FUNCTION cross ( a , b ) REAL ( 8 ), DIMENSION ( 3 ) :: cross REAL ( 8 ), DIMENSION ( 3 ), INTENT ( IN ) :: a , b cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION cross ! calculate eigen-values of a Hermitian matrix A FUNCTION eig ( NN , A ) INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A ! ----- REAL ( 8 ) :: eig ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , liwork , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) ! CALL zheev ( 'N' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) ! deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eig (:) = W (:) END FUNCTION eig ! calculate eigen-values and eigen-vectors of a Hermitian matrix A !   upon return A will be modified and contains the eigen-vectors FUNCTION eigv ( NN , A ) INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A ! ----- REAL ( 8 ) :: eigv ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , liwork , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) ! CALL zheev ( 'V' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) ! deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eigv (:) = W (:) END FUNCTION eigv end module linalg","tags":"","loc":"sourcefile/linalg.f90.html"},{"title":"cuda_rgf_mod.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~cuda_rgf_mod.f90~~AfferentGraph sourcefile~cuda_rgf_mod.f90 cuda_rgf_mod.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~negf_mod.f90->sourcefile~cuda_rgf_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules cuda_rgf_mod Source Code cuda_rgf_mod.f90 Source Code module cuda_rgf_mod use cublas use cusolverdn use omp_lib IMPLICIT NONE type type_matrix_complex complex ( 8 ), allocatable :: m (:, :) !! complex matrix integer :: size ( 2 ) !! matrix size end type type_matrix_complex private public :: cuda_rgf_variableblock_forward public :: cuda_rgf_constblocksize , cuda_rgf_init , cuda_rgf_finish integer , parameter :: dp = 8 complex ( dp ), parameter :: czero = dcmplx ( 0.0d0 , 0.0d0 ) REAL ( dp ), PARAMETER :: BOLTZ = 8.61734d-05 !eV K-1 COMPLEX ( dp ), allocatable :: H00 (:,:), H10 (:,:), A (:,:), B (:,:), C (:,:), D (:,:), S00 (:,:), G00 (:,:), GBB (:,:), GN0 (:,:), Gn (:,:), Gp (:,:) COMPLEX ( dp ), allocatable :: sig (:,:), sigmal (:,:), sigmar (:,:), sig2 (:,:), glii (:,:), glpii (:,:), glnii (:,:), cur (:,:) COMPLEX ( dp ), ALLOCATABLE :: H_BB (:, :), H_SS (:, :), H_01 (:, :), H_10 (:, :), Id (:, :) complex ( dp ), dimension (:,:), allocatable :: work integer , dimension (:), allocatable :: ipiv contains subroutine cuda_rgf_init ( nm ) integer , intent ( in ) :: nm Allocate ( H_BB ( nm , nm )) Allocate ( H_SS ( nm , nm )) Allocate ( H_01 ( nm , nm )) Allocate ( H_10 ( nm , nm )) Allocate ( Id ( nm , nm )) Allocate ( work ( nm , nm )) Allocate ( ipiv ( nm )) Allocate ( H00 ( nm , nm ), H10 ( nm , nm ), A ( nm , nm ), B ( nm , nm ), C ( nm , nm ), D ( nm , nm ), S00 ( nm , nm ), G00 ( nm , nm ), GBB ( nm , nm ), GN0 ( nm , nm ), Gn ( nm , nm ), Gp ( nm , nm )) Allocate ( sig ( nm , nm ), sigmal ( nm , nm ), sigmar ( nm , nm ), sig2 ( nm , nm ), glii ( nm , nm ), glpii ( nm , nm ), glnii ( nm , nm ), cur ( nm , nm )) !$omp target enter data map(to:H00,H10,G00,A,sigmal,S00,sig,sig2,B,C,D,Gn,Gp,ipiv,work,sigmar,glii,glnii,glpii,cur,GN0,H_BB,H_SS,H_01,H_10,Id,GBB) end subroutine cuda_rgf_init subroutine cuda_rgf_finish () !$omp target exit data map(delete:H00,H10,G00,A,sigmal,S00,sig,sig2,B,C,D,Gn,Gp,ipiv,work,sigmar,glii,glnii,glpii,cur,GN0,H_BB,H_SS,H_01,H_10,Id,GBB) deallocate ( H_BB , H_SS , H_01 , H_10 , Id , work , ipiv ) deallocate ( H00 , H10 , A , B , C , D , S00 , G00 , GBB , GN0 , Gn , Gp , sig , sigmal , sigmar , sig2 , glii , glpii , glnii , cur ) end subroutine cuda_rgf_finish subroutine cuda_rgf_constblocksize ( nm , nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , tr , tre ) type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx , nm !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ) real ( dp ), intent ( out ) :: tr , tre ! ---- COMPLEX ( dp ) :: z integer :: i , j , k , l , info1 , info2 , ii real ( dp ) :: tim , start , finish , start_0 COMPLEX ( dp ), allocatable :: Gl (:,:,:), Gln (:,:,:), Glp (:,:,:) ! left-connected green function complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) ! z = dcmplx ( En , 0.0d-6 ) Id = dcmplx ( 0.0d0 , 0.0d0 ) forall ( ii = 1 : nm ) Id ( ii , ii ) = 1.0d0 ! allocate ( Gl ( nm , nm , nx )) allocate ( Gln ( nm , nm , nx )) allocate ( Glp ( nm , nm , nx )) ! ! Gln = 0.0d0 Glp = 0.0d0 Gl = 0.0d0 do l = 1 , nx G_r ( l )% m = 0.0d0 G_lesser ( l )% m = 0.0d0 G_greater ( l )% m = 0.0d0 Jdens ( l )% m = 0.0d0 enddo ! start = omp_get_wtime () start_0 = start ! ! self energy on the left contact S00 (:,:) = Sii ( 1 )% m sig (:,:) = sigma_r_ph ( 1 )% m !$omp target update to(sig,S00) !$omp target data use_device_ptr(sig,S00,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) H00 (:,:) = Hii ( 1 )% m + B (:,:) H10 (:,:) = H1i ( 1 )% m ! call sancho ( nm , En , S00 , H00 , transpose ( conjg ( H10 )), G00 , GBB ) ! sig2 (:,:) = sigma_lesser_ph ( 1 )% m ! !$omp target update to(H10,G00,sigmal,S00,sig2) !$omp target data use_device_ptr(H10,G00,A,sigmal,S00,sig2,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , G00 , nm , beta , A , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , sigmal , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update from(B,sigmal) !!!$omp target exit data map(delete:H10,G00,A,sigmal,S00,sig2,B) sig (:,:) =- ( sigmal (:,:) - transpose ( conjg ( sigmal (:,:)))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) + B (:,:) A = z * S00 - H00 - sigmal ! ! call invert(A,nm) !$omp target update to(A, Id) !$omp target data use_device_ptr(A,ipiv,work,Id) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrf ( nm , nm , A , nm , ipiv , info1 ) call zgetrs ( 'n' , nm , nm , A , nm , ipiv , work , nm , info2 ) call zcopy ( nm * nm , work , 1 , A , 1 ) !$omp end target data !$omp target update from(A) Gl (:,:, 1 ) = A (:,:) ! !$omp target update to(sig,A) !$omp target data use_device_ptr(A,sig,B,C) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) !$omp end target data !$omp target update from(C) Gln (:,:, 1 ) = C (:,:) ! finish = omp_get_wtime () print * , \"---- left contact took seconds\" , finish - start start = finish ! Do l = 2 , nx - 1 H00 (:,:) = Hii ( l )% m + sigma_r_ph ( l )% m H10 (:,:) = H1i ( l )% m G00 (:,:) = Gl (:,:, l - 1 ) sig = Gln (:,:, l - 1 ) sig2 = sigma_lesser_ph ( l )% m S00 (:,:) = Sii ( l )% m ! !$omp target update to(H00,H10,G00,S00,sig,sig2) !$omp target data use_device_ptr(H10,G00,B,C,A,H00,S00,Gn,sig,sig2,work,ipiv,Id) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , G00 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) call zcopy ( nm * nm , C , 1 , A , 1 ) call zaxpy ( nm * nm , alpha , H00 , 1 , A , 1 ) call zaxpy ( nm * nm , - z , S00 , 1 , A , 1 ) call zscal ( nm * nm , - alpha , A , 1 ) ! A=z*S00-H00-C ! ! call invert(A,nm) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrf ( nm , nm , A , nm , ipiv , info1 ) call zgetrs ( 'n' , nm , nm , A , nm , ipiv , work , nm , info2 ) call zcopy ( nm * nm , work , 1 , A , 1 ) call zcopy ( nm * nm , A , 1 , G00 , 1 ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) ! ! C(:,:)=C(:,:)+B(:,:) call zaxpy ( nm * nm , alpha , B , 1 , C , 1 ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , C , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , A , nm , beta , Gn , nm ) !$omp end target data !$omp target update from(Gn,G00) Gln (:,:, l ) = Gn (:,:) Gl (:,:, l ) = G00 (:,:) if ( info1 . ne . 0 ) then print * , 'SEVERE warning: zgetrf failed, info=' , info1 call abort () end if if ( info2 . ne . 0 ) then print * , 'SEVERE warning: zgetri failed, info=' , info2 call abort () end if enddo finish = omp_get_wtime () print * , \"---- first pass took seconds\" , finish - start start = finish ! self energy on the right contact S00 (:,:) = Sii ( nx )% m sig2 (:,:) = sigma_r_ph ( nx )% m !$omp target update to(S00,sig2) !$omp target data use_device_ptr(S00,sig2,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update to(B) H00 (:,:) = Hii ( nx )% m + B (:,:) H10 (:,:) = H1i ( nx )% m ! call sancho ( NM , En , S00 , H00 , H10 , G00 , GBB ) ! Glii = Gl (:,:, nx - 1 ) !$omp target update to(H10,G00,Glii) !$omp target data use_device_ptr(H10,G00,A,sigmar,G00,B,C,Glii) call zgemm ( 'c' , 'n' , nm , nm , nm , alpha , H10 , nm , G00 , nm , beta , A , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , sigmar , nm ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , Glii , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) !$omp end target data !$omp target update from(C,sigmar) ! G00 = z * S00 - H00 - sigmar - C ! ! call invert(G00,nm) !$omp target update to(G00, work) !$omp target data use_device_ptr(G00,ipiv,work,Id) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrf ( nm , nm , G00 , nm , ipiv , info1 ) call zgetrs ( 'n' , nm , nm , G00 , nm , ipiv , work , nm , info2 ) call zcopy ( nm * nm , work , 1 , G00 , 1 ) !$omp end target data !$omp target update from(G00) ! G_r ( nx )% m = G00 (:,:) !dcmplx(0.0d0,1.0d0)*(G00(:,:)-transpose(conjg(G00(:,:)))) sig = Gln (:,:, nx - 1 ) sig2 = sigma_lesser_ph ( nx )% m !$omp target update to(sig,sig2,S00) !$omp target data use_device_ptr(H10,sig,B,C,sig2,S00) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , H10 , nm , beta , C , nm ) ! C=H10 Gl< H01 call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , sig2 , nm , S00 , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) ! B=Sig< S00 sig (:,:) =- ( sigmar (:,:) - transpose ( conjg ( sigmar (:,:)))) * ferm (( En - mur ) / ( BOLTZ * TEMPl )) + C (:,:) + B (:,:) ! !$omp target update to(G00,sig) !$omp target data use_device_ptr(G00,sig,Gn,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , G00 , nm , sig , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , G00 , nm , beta , Gn , nm ) !$omp end target data !$omp target update from(Gn) ! G<00 = G00 sig< G00' G_lesser ( nx )% m = Gn (:,:) Gp (:,:) = Gn (:,:) + ( G00 (:,:) - transpose ( conjg ( G00 (:,:)))) G_greater ( nx )% m = Gp (:,:) A =- ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPl )) ! !$omp target update to(A,Gp) !$omp target data use_device_ptr(A,Gp,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gp , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) ! A =- ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPl )) - 1.0d0 ) ! !$omp target update to(A,Gn) !$omp target data use_device_ptr(A,Gn,C) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gn , nm , beta , C , nm ) !$omp end target data !$omp target update from(C) tim = 0.0d0 do i = 1 , nm do j = i , i !1,nm tim = tim - dble ( B ( i , j ) - C ( i , j )) enddo enddo tr = tim ! transmission !------------------------- finish = omp_get_wtime () print * , \"---- right contact took seconds\" , finish - start start = finish do l = nx - 1 , 1 , - 1 H10 (:,:) = H1i ( l )% m A = Gn Glii = Gl (:,:, l ) Glpii = Glp (:,:, l ) Glnii = Gln (:,:, l ) !$omp target update to(H10,A,Glii,Glpii,Glnii) !$omp target data use_device_ptr(H10,G00,B,C,A,D,H00,S00,Glii,Glpii,Glnii,cur,Gn,Gp,GN0) ! call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , H10 , nm , Glii , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , B , nm , beta , C , nm ) call zcopy ( nm * nm , Glnii , 1 , A , 1 ) ! A=Gln(:,:,l) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , A , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , G00 , nm , B , nm , beta , A , nm ) call zcopy ( nm * nm , C , 1 , B , 1 ) call zaxpy ( nm * nm , alpha , A , 1 , B , 1 ) ! B=C+A call zgemm ( 'c' , 'n' , nm , nm , nm , alpha , H10 , nm , B , nm , beta , A , nm ) !!! G<_i+1,i call zcopy ( nm * nm , A , 1 , cur , 1 ) ! cur=dble(A(:,:)) !------------------------- call zcopy ( nm * nm , Gn , 1 , A , 1 ) ! A=Gn call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) ! g H10 G< call zcopy ( nm * nm , Glnii , 1 , A , 1 ) ! A=Glnii call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , G00 , nm , beta , A , nm ) ! g< H10 G' call zcopy ( nm * nm , C , 1 , B , 1 ) call zaxpy ( nm * nm , alpha , A , 1 , B , 1 ) ! B=C+A call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H10 , nm , B , nm , beta , A , nm ) !!! G<_i,i+1 call zaxpy ( nm * nm , - alpha , A , 1 , cur , 1 ) ! cur=cur-dble(A(:,:)) !------------------------- call zcopy ( nm * nm , Glii , 1 , D , 1 ) ! D(:,:)= Glii call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , G00 , nm , beta , GN0 , nm ) !!! G_i,i+1 call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , GN0 , nm , H10 , nm , beta , A , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Glii , nm , beta , C , nm ) call zcopy ( nm * nm , Glii , 1 , G00 , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , G00 , 1 ) ! G00(:,:)=Glii+C(:,:)                                       !!! G_i,i !------------------------- ! A(:,:)=Gn(:,:) call zcopy ( nm * nm , Gn , 1 , A , 1 ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , C , nm , H10 , nm , beta , A , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , Glii , nm , beta , C , nm ) call zcopy ( nm * nm , Glnii , 1 , Gn , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , Gn , 1 ) ! Gn(:,:)= Glnii + C(:,:) call zcopy ( nm * nm , Glnii , 1 , A , 1 ) ! A(:,:)=Glnii call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , GN0 , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , Gn , 1 ) ! Gn(:,:)= Gn(:,:)+C(:,:)! call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , GN0 , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , Gn , 1 ) ! Gn(:,:)= Gn(:,:)+C(:,:)!     \t\t\t\t\t !!! G<_i,i !------------------------- ! A(:,:)=Gp(:,:) call zcopy ( nm * nm , Gp , 1 , A , 1 ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , Glii , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) ! call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , C , nm , H10 , nm , beta , A , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , Glii , nm , beta , C , nm ) ! call zcopy ( nm * nm , Glpii , 1 , Gp , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , Gp , 1 ) ! Gp(:,:)= Glpii + C(:,:) ! A(:,:)=Glp(:,:,l) call zcopy ( nm * nm , Glpii , 1 , A , 1 ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , GN0 , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , B , nm , A , nm , beta , C , nm ) ! call zaxpy ( nm * nm , alpha , C , 1 , Gp , 1 ) ! Gp(:,:)= Gp(:,:)+C(:,:)! call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , A , nm , H10 , nm , beta , B , nm ) call zgemm ( 'n' , 'c' , nm , nm , nm , alpha , B , nm , GN0 , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , Gp , 1 ) ! Gp(:,:)= Gp(:,:)+C(:,:)!     \t\t\t\t\t !!! G>_i,i !------------------------- !$omp end target data !$omp target update from(Gn,Gp,G00,cur) G_lesser ( l )% m = Gn (:,:) G_greater ( l )% m = Gp (:,:) G_r ( l )% m = G00 (:,:) Jdens ( l )% m = cur enddo ! finish = omp_get_wtime () print * , \"---- second pass took seconds\" , finish - start start = finish ! Gp (:,:) = Gn (:,:) + ( G00 (:,:) - transpose ( conjg ( G00 (:,:)))) A =- ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPr )) ! !$omp target update to(A,Gp) !$omp target data use_device_ptr(A,Gp,B) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gp , nm , beta , B , nm ) !$omp end target data !$omp target update from(B) ! A =- ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPr )) - 1.0d0 ) !$omp target update to(A,Gn) !$omp target data use_device_ptr(A,Gn,C) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , Gn , nm , beta , C , nm ) !$omp end target data !$omp target update from(C) ! tim = 0.0d0 do i = 1 , nm tim = tim + dble ( B ( i , i ) - C ( i , i )) enddo tre = tim ! deallocate ( Gl ) deallocate ( Gln ) deallocate ( Glp ) print * , \"RGF took seconds\" , finish - start_0 end subroutine cuda_rgf_constblocksize !!  Recursive Forward Green's solver subroutine cuda_rgf_variableblock_forward ( nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ), Gl ( nx ), Gln ( nx ) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: M , ii , jj complex ( dp ) :: z real ( dp ) :: tim complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) !!!$omp declare target device_type(any) z = dcmplx ( En , 0.0d0 ) ! ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmal ( M , M )) allocate ( sig ( M , M )) ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B H10 = H1i ( ii )% m call sancho ( M , En , Sii ( ii )% m , H00 , transpose ( conjg ( H10 )), G00 , GBB ) !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical !! \\Sigma&#94;R = H(i,i+1) * G00 * H(i+1,i) !! Gl(i) = [E*S(i,i) - H00 - \\Sigma_R]&#94;{-1} call triMUL_c ( H10 , G00 , H10 , sigmal , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmal call invert ( B , M ) Gl ( ii )% m = B ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + (-(\\Sigma&#94;R - \\Sigma_R&#94;\\dagger)*ferm(..))] * Gl(i)&#94;\\dagger call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig , H10 ) ! allocate ( A ( M , M )) ! inside device l -> r do ii = 2 , nx - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) !! Gl(i) = [E*S(i,i) - H00 - H(i,i-1) * Gl(i-1) * H(i-1,i)]&#94;{-1} call triMUL_c ( H1i ( ii )% m , Gl ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B call invert ( A , M ) Gl ( ii )% m = A ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)&#94;\\dagger call triMUL_c ( H1i ( ii )% m , Gln ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmar ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = H1i ( nx + 1 )% m ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H10 , G00 , H10 , sigmar , 'c' , 'n' , 'n' ) !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical call triMUL_c ( H1i ( nx )% m , Gl ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B - sigmar ! call invert ( A , M ) G_r ( ii )% m = A Gl ( ii )% m = A ! !! \\Sigma&#94;< = \\Sigma_11&#94;< + \\Sigma_{ph}&#94;< + \\Sigma_s&#94;< call triMUL_c ( H1i ( nx )% m , Gln ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( nx )% m , Sii ( nx )% m , 'n' , 'n' , A ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !! G&#94;< = G * \\Sigma&#94;< * G&#94;\\dagger call triMUL_c ( G_r ( ii )% m , sig , G_r ( ii )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( ii )% m = B G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) ! A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) ! Jdens ( ii )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( ii )% m ( jj , jj )) end do tr = tim ! transmission deallocate ( sigmar , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! inside device r -> l do ii = nx - 1 , 1 , - 1 M = size ( Hii ( ii )% m , 1 ) !! A = G&#94;<(i+1) * H(i+1,i) * Gl(i)&#94;\\dagger + G(i+1) * H(i+1,i) * Gln(i) call triMUL_c ( G_lesser ( ii + 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii + 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !! B = H(i,i+1) * A !! Jdens(i) = -2 * B call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * B (:, :) ! !! GN0 = Gl(i) * H(i,i+1) * G(i+1) !! G(i) = Gl(i) + GN0 * H(i+1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii + 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !! G&#94;<(i) = Gln(i) + Gl(i) * H(i,i+1) * G&#94;<(i+1) * H(i+1,i) *Gl(i)&#94;\\dagger call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii + 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + GN0 * H(i+1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + Gln(i) * H(i,i+1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;>(i) = G&#94;<(i) + [G(i) - G(i)&#94;\\dagger] G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ii = 1 ! on the left contact A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tre = tim deallocate ( B , A , C , GN0 , sigmal ) end subroutine cuda_rgf_variableblock_forward subroutine invert ( A , nn ) integer :: info1 , info2 , nn , i integer , dimension (:), allocatable :: ipiv complex ( 8 ), dimension ( nn , nn ), intent ( inout ) :: A complex ( 8 ), dimension (:,:), allocatable :: work allocate ( work ( nn , nn )) allocate ( ipiv ( nn )) work = dcmplx ( 0.0d0 , 0.0d0 ) forall ( i = 1 : nn ) work ( i , i ) = 1.0d0 !$omp target enter data map(to:A,work,ipiv) !$omp target data use_device_ptr(A,work,ipiv) call zgetrf ( nn , nn , A , nn , ipiv , info1 ) !!! call zgetrs(nn, A, nn, ipiv, work, nn*nn, info2) call zgetrs ( 'n' , nn , nn , A , nn , ipiv , work , nn , info2 ) call zcopy ( nn * nn , work , 1 , A , 1 ) !$omp end target data !$omp target update from(A,work,ipiv) !$omp target exit data map(delete:A,work,ipiv) if ( info1 . ne . 0 ) then print * , 'SEVERE warning: zgetrf failed, info=' , info1 A = czero end if if ( info2 . ne . 0 ) then print * , 'SEVERE warning: zgetri failed, info=' , info2 A = czero end if deallocate ( work ) deallocate ( ipiv ) end subroutine invert !!  Sancho-Rubio subroutine sancho ( nm , E , S_00 , H00 , H10 , G00 , GBB ) integer i , j , k , nm , nmax , ii , jj COMPLEX ( dp ) :: z real ( dp ) :: E , error REAL ( dp ) :: TOL = 1.0D-100 ! [eV] COMPLEX ( dp ), INTENT ( IN ) :: S_00 ( nm , nm ), H00 ( nm , nm ), H10 ( nm , nm ) COMPLEX ( dp ), INTENT ( OUT ) :: G00 ( nm , nm ), GBB ( nm , nm ) COMPLEX ( dp ), EXTERNAL :: ZLANGE complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) character * 1 :: transa , transb integer :: info ! nmax = 50 z = dcmplx ( E , 1.0d-5 ) Id = dcmplx ( 0.0d0 , 0.0d0 ) ! tmp = 0.0d0 do i = 1 , nm Id ( i , i ) = 1.0d0 end do H_BB = H00 H_10 = H10 H_01 = TRANSPOSE ( CONJG ( H_10 )) H_SS = H00 transa = 'N' transb = 'N' !$omp target update to(S_00,H_BB,H_10,H_01,H_SS,Id) ! print *, 'start sancho' do i = 1 , nmax !$omp target data use_device_ptr(C,A,H_10,H_01,B,H_SS,H_BB,S_00,ipiv,work,Id) ! A = z*S_00 - H_BB call zscal ( nm * nm , beta , A , 1 ) call zaxpy ( nm * nm , - alpha , H_BB , 1 , A , 1 ) call zaxpy ( nm * nm , z , S_00 , 1 , A , 1 ) ! inv(A) call zgetrf ( nm , nm , A , nm , ipiv , info ) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrs ( transa , nm , nm , A , nm , ipiv , work , nm , info ) call zcopy ( nm * nm , work , 1 , A , 1 ) call Zgemm ( transa , transb , nm , nm , nm , alpha , A , nm , H_10 , nm , beta , B , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) call zaxpy ( nm * nm , alpha , C , 1 , H_SS , 1 ) call zaxpy ( nm * nm , alpha , C , 1 , H_BB , 1 ) call Zgemm ( transa , transb , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , C , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , A , nm , H_01 , nm , beta , B , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , A , nm ) ! H_10 = C ! H_BB = H_BB + A call zcopy ( nm * nm , C , 1 , H_10 , 1 ) call zaxpy ( nm * nm , alpha , A , 1 , H_BB , 1 ) call Zgemm ( transa , transb , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) ! H_01 = C call zcopy ( nm * nm , C , 1 , H_01 , 1 ) !$omp end target data !$omp target update from(C) ! NORM --> inspect the diagonal of A error = 0.0d0 DO k = 1 , nm DO j = 1 , nm error = error + sqrt ( aimag ( C ( k , j )) ** 2 + Dble ( C ( k , j )) ** 2 ) END DO END DO !write(90,*)E,i,error ! tmp = H_SS ! call zcopy(nm*nm,H_SS,1,tmp,1) IF ( abs ( error ) < TOL ) THEN write ( 90 , * ) 'SR: Exited, abs(error)=' , i , abs ( error ) EXIT END IF IF ( i . EQ . nmax ) THEN write ( * , * ) 'SEVERE warning: nmax reached in sancho!!!' , error END IF end do ! !$omp target data use_device_ptr(C,A,H_10,H_01,B,H_SS,H_BB,S_00,ipiv,work,Id,G00,GBB) ! G00 = z*S_00 - H_SS call zcopy ( nm * nm , H_SS , 1 , G00 , 1 ) call zscal ( nm * nm , - alpha , G00 , 1 ) call zaxpy ( nm * nm , z , S_00 , 1 , G00 , 1 ) ! call invert(G00, nm) call zgetrf ( nm , nm , G00 , nm , ipiv , info ) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrs ( transa , nm , nm , G00 , nm , ipiv , work , nm , info ) call zcopy ( nm * nm , work , 1 , G00 , 1 ) ! ! GBB = z*S_00 - H_BB call zcopy ( nm * nm , H_BB , 1 , GBB , 1 ) call zscal ( nm * nm , - alpha , GBB , 1 ) call zaxpy ( nm * nm , z , S_00 , 1 , GBB , 1 ) ! call invert(GBB, nm) call zgetrf ( nm , nm , GBB , nm , ipiv , info ) call zcopy ( nm * nm , Id , 1 , work , 1 ) call zgetrs ( transa , nm , nm , GBB , nm , ipiv , work , nm , info ) call zcopy ( nm * nm , work , 1 , GBB , 1 ) !$omp end target data !$omp target update from(GBB,G00) ! end subroutine sancho subroutine triMUL_C ( A , B , C , R , trA , trB , trC ) complex ( 8 ), intent ( in ), dimension (:, :) :: A , B , C complex ( 8 ), intent ( inout ), allocatable :: R (:, :) character , intent ( in ) :: trA , trB , trC complex ( 8 ), allocatable , dimension (:, :) :: tmp integer :: n , m , k , kb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trB is wrong: \" , trB call abort () end if if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in triMUL_C! Matrix dimension is wrong\" , k , kb call abort () end if call MUL_C ( A , B , trA , trB , tmp ) call MUL_C ( tmp , C , 'n' , trC , R ) deallocate ( tmp ) end subroutine triMUL_C subroutine MUL_C ( A , B , trA , trB , R ) complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ), intent ( inout ), allocatable :: R (:, :) CHARACTER , intent ( in ) :: trA , trB integer :: n , m , k , kb , lda , ldb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trB is wrong: \" , trB call abort () end if lda = size ( A , 1 ) ldb = size ( B , 1 ) if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in MUL_C! Matrix dimension is wrong\" , k , kb call abort () end if if ( allocated ( R )) then if (( size ( R , 1 ) . ne . m ) . or . ( size ( R , 2 ) . ne . n )) then deallocate ( R ) Allocate ( R ( m , n )) end if else Allocate ( R ( m , n )) end if R = dcmplx ( 0.0d0 , 0.0d0 ) !$omp target enter data map(to:A,B,R) !$omp target data use_device_ptr(A,B,R) call zgemm ( trA , trB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), R , m ) !$omp end target data !$omp target update from(A,B,R) !$omp target exit data map(delete:A,B,R) end subroutine MUL_C !!  Fermi distribution function elemental Function ferm ( a ) Real ( dp ), intent ( in ) :: a real ( dp ) :: ferm ferm = 1.0d0 / ( 1.0d0 + Exp ( a )) End Function ferm end module cuda_rgf_mod","tags":"","loc":"sourcefile/cuda_rgf_mod.f90.html"},{"title":"mkl_dfti.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~mkl_dfti.f90~~AfferentGraph sourcefile~mkl_dfti.f90 mkl_dfti.f90 sourcefile~fft_mod.f90 fft_mod.f90 sourcefile~fft_mod.f90->sourcefile~mkl_dfti.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules MKL_DFT_TYPE MKL_DFTI Source Code mkl_dfti.f90 Source Code !=============================================================================== ! Copyright 2002-2018 Intel Corporation. ! ! This software and the related documents are Intel copyrighted  materials,  and ! your use of  them is  governed by the  express license  under which  they were ! provided to you (License).  Unless the License provides otherwise, you may not ! use, modify, copy, publish, distribute,  disclose or transmit this software or ! the related documents without Intel's prior written permission. ! ! This software and the related documents  are provided as  is,  with no express ! or implied  warranties,  other  than those  that are  expressly stated  in the ! License. !=============================================================================== ! Content: !    Intel(R) Math Kernel Library (Intel(R) MKL) !    Discrete Fourier Transform Interface (DFTI) !***************************************************************************** MODULE MKL_DFT_TYPE TYPE , PUBLIC :: DFTI_DESCRIPTOR PRIVATE INTEGER :: dontuse ! Structure of this type is not used in Fortran code ! the pointer to this type is used only END TYPE DFTI_DESCRIPTOR !====================================================================== ! These real type kind parameters are not for direct use !====================================================================== INTEGER , PARAMETER :: DFTI_SPKP = SELECTED_REAL_KIND ( 6 , 37 ) INTEGER , PARAMETER :: DFTI_DPKP = SELECTED_REAL_KIND ( 15 , 307 ) !====================================================================== ! Descriptor configuration parameters [default values in brackets] !====================================================================== ! Domain for forward transform. No default value INTEGER , PARAMETER :: DFTI_FORWARD_DOMAIN = 0 ! Dimensionality, or rank. No default value INTEGER , PARAMETER :: DFTI_DIMENSION = 1 ! Length(s) of transform. No default value INTEGER , PARAMETER :: DFTI_LENGTHS = 2 ! Floating point precision. No default value INTEGER , PARAMETER :: DFTI_PRECISION = 3 ! Scale factor for forward transform [1.0] INTEGER , PARAMETER :: DFTI_FORWARD_SCALE = 4 ! Scale factor for backward transform [1.0] INTEGER , PARAMETER :: DFTI_BACKWARD_SCALE = 5 ! Exponent sign for forward transform [DFTI_NEGATIVE] ! INTEGER, PARAMETER :: DFTI_FORWARD_SIGN = 6 ! NOT IMPLEMENTED ! Number of data sets to be transformed [1] INTEGER , PARAMETER :: DFTI_NUMBER_OF_TRANSFORMS = 7 ! Storage of finite complex-valued sequences in complex domain ! [DFTI_COMPLEX_COMPLEX] INTEGER , PARAMETER :: DFTI_COMPLEX_STORAGE = 8 ! Storage of finite real-valued sequences in real domain ! [DFTI_REAL_REAL] INTEGER , PARAMETER :: DFTI_REAL_STORAGE = 9 ! Storage of finite complex-valued sequences in conjugate-even ! domain [DFTI_COMPLEX_REAL] INTEGER , PARAMETER :: DFTI_CONJUGATE_EVEN_STORAGE = 10 ! Placement of result [DFTI_INPLACE] INTEGER , PARAMETER :: DFTI_PLACEMENT = 11 ! Generalized strides for input data layout ! [tight, col-major for Fortran] INTEGER , PARAMETER :: DFTI_INPUT_STRIDES = 12 ! Generalized strides for output data layout ! [tight, col-major for Fortran] INTEGER , PARAMETER :: DFTI_OUTPUT_STRIDES = 13 ! Distance between first input elements for multiple transforms [0] INTEGER , PARAMETER :: DFTI_INPUT_DISTANCE = 14 ! Distance between first output elements for multiple transforms [0] INTEGER , PARAMETER :: DFTI_OUTPUT_DISTANCE = 15 ! Effort spent in initialization [DFTI_MEDIUM] ! INTEGER, PARAMETER :: DFTI_INITIALIZATION_EFFORT = 16 ! NOT IMPLEMENTED ! Use of workspace during computation [DFTI_ALLOW] INTEGER , PARAMETER :: DFTI_WORKSPACE = 17 ! Ordering of the result [DFTI_ORDERED] INTEGER , PARAMETER :: DFTI_ORDERING = 18 ! Possible transposition of result [DFTI_NONE] INTEGER , PARAMETER :: DFTI_TRANSPOSE = 19 ! User-settable descriptor name [\"\"] INTEGER , PARAMETER :: DFTI_DESCRIPTOR_NAME = 20 ! Packing format for DFTI_COMPLEX_REAL storage of finite ! conjugate-even sequences [DFTI_CCS_FORMAT] INTEGER , PARAMETER :: DFTI_PACKED_FORMAT = 21 ! Commit status of the descriptor. Read-only parameter INTEGER , PARAMETER :: DFTI_COMMIT_STATUS = 22 ! Version string for this DFTI implementation. Read-only parameter INTEGER , PARAMETER :: DFTI_VERSION = 23 ! Ordering of the forward transform. Read-only parameter ! INTEGER, PARAMETER :: DFTI_FORWARD_ORDERING = 24 ! NOT IMPLEMENTED ! Ordering of the backward transform. Read-only parameter ! INTEGER, PARAMETER :: DFTI_BACKWARD_ORDERING = 25 ! NOT IMPLEMENTED ! Number of user threads that share the descriptor [1] INTEGER , PARAMETER :: DFTI_NUMBER_OF_USER_THREADS = 26 ! Limit the number of threads used by this descriptor [0 = don't care] INTEGER , PARAMETER :: DFTI_THREAD_LIMIT = 27 !====================================================================== ! Values of the descriptor configuration parameters !====================================================================== ! DFTI_COMMIT_STATUS INTEGER , PARAMETER :: DFTI_COMMITTED = 30 INTEGER , PARAMETER :: DFTI_UNCOMMITTED = 31 ! DFTI_FORWARD_DOMAIN INTEGER , PARAMETER :: DFTI_COMPLEX = 32 INTEGER , PARAMETER :: DFTI_REAL = 33 ! INTEGER, PARAMETER :: DFTI_CONJUGATE_EVEN = 34 ! NOT IMPLEMENTED ! DFTI_PRECISION INTEGER , PARAMETER :: DFTI_SINGLE = 35 INTEGER , PARAMETER :: DFTI_DOUBLE = 36 ! DFTI_PRECISION for reduced size of statically linked application. ! Recommended use: modify statement 'USE MKL_DFTI' in your program, ! so that it reads as either of: ! USE MKL_DFTI, FORGET=>DFTI_SINGLE, DFTI_SINGLE=>DFTI_SINGLE_R ! USE MKL_DFTI, FORGET=>DFTI_DOUBLE, DFTI_DOUBLE=>DFTI_DOUBLE_R ! where word 'FORGET' can be any name not used in the program. REAL ( DFTI_SPKP ), PARAMETER :: DFTI_SINGLE_R = REAL ( 35 ) REAL ( DFTI_DPKP ), PARAMETER :: DFTI_DOUBLE_R = REAL ( 36 ) ! DFTI_FORWARD_SIGN ! INTEGER, PARAMETER :: DFTI_NEGATIVE = 37 ! NOT IMPLEMENTED ! INTEGER, PARAMETER :: DFTI_POSITIVE = 38 ! NOT IMPLEMENTED ! DFTI_COMPLEX_STORAGE and DFTI_CONJUGATE_EVEN_STORAGE INTEGER , PARAMETER :: DFTI_COMPLEX_COMPLEX = 39 INTEGER , PARAMETER :: DFTI_COMPLEX_REAL = 40 ! DFTI_REAL_STORAGE INTEGER , PARAMETER :: DFTI_REAL_COMPLEX = 41 INTEGER , PARAMETER :: DFTI_REAL_REAL = 42 ! DFTI_PLACEMENT INTEGER , PARAMETER :: DFTI_INPLACE = 43 ! Result overwrites input INTEGER , PARAMETER :: DFTI_NOT_INPLACE = 44 ! Have another place for result ! DFTI_INITIALIZATION_EFFORT ! INTEGER, PARAMETER :: DFTI_LOW = 45 ! NOT IMPLEMENTED ! INTEGER, PARAMETER :: DFTI_MEDIUM = 46 ! NOT IMPLEMENTED ! INTEGER, PARAMETER :: DFTI_HIGH = 47 ! NOT IMPLEMENTED ! DFTI_ORDERING INTEGER , PARAMETER :: DFTI_ORDERED = 48 INTEGER , PARAMETER :: DFTI_BACKWARD_SCRAMBLED = 49 ! INTEGER, PARAMETER :: DFTI_FORWARD_SCRAMBLED  = 50 ! NOT IMPLEMENTED ! Allow/avoid certain usages INTEGER , PARAMETER :: DFTI_ALLOW = 51 ! Allow transposition or workspace INTEGER , PARAMETER :: DFTI_AVOID = 52 ! Avoid auxiliary storage INTEGER , PARAMETER :: DFTI_NONE = 53 ! DFTI_PACKED_FORMAT ! (for storing congugate-even finite sequence in real array) INTEGER , PARAMETER :: DFTI_CCS_FORMAT = 54 ! Complex conjugate-symmetric INTEGER , PARAMETER :: DFTI_PACK_FORMAT = 55 ! Pack format for real DFT INTEGER , PARAMETER :: DFTI_PERM_FORMAT = 56 ! Perm format for real DFT INTEGER , PARAMETER :: DFTI_CCE_FORMAT = 57 ! Complex conjugate-even !====================================================================== ! Error classes !====================================================================== INTEGER , PARAMETER :: DFTI_NO_ERROR = 0 INTEGER , PARAMETER :: DFTI_MEMORY_ERROR = 1 INTEGER , PARAMETER :: DFTI_INVALID_CONFIGURATION = 2 INTEGER , PARAMETER :: DFTI_INCONSISTENT_CONFIGURATION = 3 INTEGER , PARAMETER :: DFTI_MULTITHREADED_ERROR = 4 INTEGER , PARAMETER :: DFTI_BAD_DESCRIPTOR = 5 INTEGER , PARAMETER :: DFTI_UNIMPLEMENTED = 6 INTEGER , PARAMETER :: DFTI_MKL_INTERNAL_ERROR = 7 INTEGER , PARAMETER :: DFTI_NUMBER_OF_THREADS_ERROR = 8 INTEGER , PARAMETER :: DFTI_1D_LENGTH_EXCEEDS_INT32 = 9 ! Maximum length of error string INTEGER , PARAMETER :: DFTI_MAX_MESSAGE_LENGTH = 80 ! Maximum length of user-settable descriptor name INTEGER , PARAMETER :: DFTI_MAX_NAME_LENGTH = 10 ! Maximum length of Intel(R) MKL version string INTEGER , PARAMETER :: DFTI_VERSION_LENGTH = 198 END MODULE MKL_DFT_TYPE MODULE MKL_DFTI USE MKL_DFT_TYPE INTERFACE DftiCreateDescriptor ! overloading of DftiCreateDescriptor for 1D DFT FUNCTION dfti_create_descriptor_1d ( desc , precision , domain , dim , length ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_create_descriptor_1d !DEC$ ATTRIBUTES REFERENCE :: dfti_create_descriptor_1d INTEGER dfti_create_descriptor_1d TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc INTEGER , INTENT ( IN ) :: precision INTEGER , INTENT ( IN ) :: domain INTEGER , INTENT ( IN ) :: dim , length END FUNCTION dfti_create_descriptor_1d ! overloading of DftiCreateDescriptor for nD DFT FUNCTION dfti_create_descriptor_highd ( desc , precision , domain , dim , length ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_create_descriptor_highd !DEC$ ATTRIBUTES REFERENCE :: dfti_create_descriptor_highd INTEGER dfti_create_descriptor_highd TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc INTEGER , INTENT ( IN ) :: precision INTEGER , INTENT ( IN ) :: domain INTEGER , INTENT ( IN ) :: dim INTEGER , INTENT ( IN ), DIMENSION ( * ) :: length END FUNCTION dfti_create_descriptor_highd ! overloading of DftiCreateDescriptor for SP 1D DFT ! second parameter (precision) should be any REAL*4 value ! for dispatching during compile time FUNCTION dfti_create_descriptor_s_1d ( desc , s , dom , one , dim ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_create_descriptor_s_1d !DEC$ ATTRIBUTES REFERENCE :: dfti_create_descriptor_s_1d INTEGER dfti_create_descriptor_s_1d TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( IN ) :: s INTEGER , INTENT ( IN ) :: dom INTEGER , INTENT ( IN ) :: one INTEGER , INTENT ( IN ) :: dim END FUNCTION dfti_create_descriptor_s_1d ! overloading of DftiCreateDescriptor for SP nD DFT ! second parameter (precision) should be any REAL*4 value ! for dispatching during compile time FUNCTION dfti_create_descriptor_s_md ( desc , s , dom , many , dims ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_create_descriptor_s_md !DEC$ ATTRIBUTES REFERENCE :: dfti_create_descriptor_s_md INTEGER dfti_create_descriptor_s_md TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( IN ) :: s INTEGER , INTENT ( IN ) :: dom INTEGER , INTENT ( IN ) :: many INTEGER , INTENT ( IN ), DIMENSION ( * ) :: dims END FUNCTION dfti_create_descriptor_s_md ! overloading of DftiCreateDescriptor for DP 1D DFT ! second parameter (precision) should be any REAL*8 value ! for dispatching during compile time FUNCTION dfti_create_descriptor_d_1d ( desc , d , dom , one , dim ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_create_descriptor_d_1d !DEC$ ATTRIBUTES REFERENCE :: dfti_create_descriptor_d_1d INTEGER dfti_create_descriptor_d_1d TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( IN ) :: d INTEGER , INTENT ( IN ) :: dom INTEGER , INTENT ( IN ) :: one INTEGER , INTENT ( IN ) :: dim END FUNCTION dfti_create_descriptor_d_1d ! overloading of DftiCreateDescriptor for DP nD DFT ! second parameter (precision) should be any REAL*8 value ! for dispatching during compile time FUNCTION dfti_create_descriptor_d_md ( desc , d , dom , many , dims ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_create_descriptor_d_md !DEC$ ATTRIBUTES REFERENCE :: dfti_create_descriptor_d_md INTEGER dfti_create_descriptor_d_md TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( IN ) :: d INTEGER , INTENT ( IN ) :: dom INTEGER , INTENT ( IN ) :: many INTEGER , INTENT ( IN ), DIMENSION ( * ) :: dims END FUNCTION dfti_create_descriptor_d_md END INTERFACE INTERFACE DftiCopyDescriptor FUNCTION dfti_copy_descriptor_external ( desc , new_desc ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_copy_descriptor_external !DEC$ ATTRIBUTES REFERENCE :: dfti_copy_descriptor_external INTEGER dfti_copy_descriptor_external TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc TYPE ( DFTI_DESCRIPTOR ), POINTER :: new_desc END FUNCTION dfti_copy_descriptor_external END INTERFACE INTERFACE DftiCommitDescriptor FUNCTION dfti_commit_descriptor_external ( desc ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_commit_descriptor_external !DEC$ ATTRIBUTES REFERENCE :: dfti_commit_descriptor_external INTEGER dfti_commit_descriptor_external TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_commit_descriptor_external END INTERFACE INTERFACE DftiSetValue ! overloading of DftiSetValue for integer value FUNCTION dfti_set_value_intval ( desc , OptName , IntVal ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_set_value_intval !DEC$ ATTRIBUTES REFERENCE :: dfti_set_value_intval INTEGER dfti_set_value_intval INTEGER , INTENT ( IN ) :: OptName INTEGER , INTENT ( IN ) :: IntVal TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_set_value_intval ! overloading of DftiSetValue for SP value FUNCTION dfti_set_value_sglval ( desc , OptName , sglval ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_set_value_sglval !DEC$ ATTRIBUTES REFERENCE :: dfti_set_value_sglval INTEGER dfti_set_value_sglval INTEGER , INTENT ( IN ) :: OptName REAL ( DFTI_SPKP ), INTENT ( IN ) :: sglval TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_set_value_sglval ! overloading of DftiSetValue for DP value FUNCTION dfti_set_value_dblval ( desc , OptName , DblVal ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_set_value_dblval !DEC$ ATTRIBUTES REFERENCE :: dfti_set_value_dblval INTEGER dfti_set_value_dblval INTEGER , INTENT ( IN ) :: OptName REAL ( DFTI_DPKP ), INTENT ( IN ) :: DblVal TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_set_value_dblval ! overloading of DftiSetValue for integer vector FUNCTION dfti_set_value_intvec ( desc , OptName , IntVec ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_set_value_intvec !DEC$ ATTRIBUTES REFERENCE :: dfti_set_value_intvec INTEGER dfti_set_value_intvec INTEGER , INTENT ( IN ) :: OptName INTEGER , INTENT ( IN ), DIMENSION ( * ) :: IntVec TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_set_value_intvec ! overloading of DftiSetValue for char vector FUNCTION dfti_set_value_chars ( desc , OptName , Chars ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_set_value_chars !DEC$ ATTRIBUTES REFERENCE :: dfti_set_value_chars INTEGER dfti_set_value_chars INTEGER , INTENT ( IN ) :: OptName CHARACTER ( * ), INTENT ( IN ) :: Chars TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_set_value_chars END INTERFACE INTERFACE DftiGetValue ! overloading of DftiGetValue for integer value FUNCTION dfti_get_value_intval ( desc , OptName , IntVal ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_get_value_intval !DEC$ ATTRIBUTES REFERENCE :: dfti_get_value_intval INTEGER dfti_get_value_intval INTEGER , INTENT ( IN ) :: OptName INTEGER , INTENT ( OUT ) :: IntVal TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_get_value_intval ! overloading of DftiGetValue for SP value FUNCTION dfti_get_value_sglval ( desc , OptName , sglval ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_get_value_sglval !DEC$ ATTRIBUTES REFERENCE :: dfti_get_value_sglval INTEGER dfti_get_value_sglval INTEGER , INTENT ( IN ) :: OptName REAL ( DFTI_SPKP ), INTENT ( OUT ) :: sglval TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_get_value_sglval ! overloading of DftiGetValue for DP value FUNCTION dfti_get_value_dblval ( desc , OptName , DblVal ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_get_value_dblval !DEC$ ATTRIBUTES REFERENCE :: dfti_get_value_dblval INTEGER dfti_get_value_dblval INTEGER , INTENT ( IN ) :: OptName REAL ( DFTI_DPKP ), INTENT ( OUT ) :: DblVal TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_get_value_dblval ! overloading of DftiGetValue for integer vector FUNCTION dfti_get_value_intvec ( desc , OptName , IntVec ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_get_value_intvec !DEC$ ATTRIBUTES REFERENCE :: dfti_get_value_intvec INTEGER dfti_get_value_intvec INTEGER , INTENT ( IN ) :: OptName INTEGER , INTENT ( OUT ), DIMENSION ( * ) :: IntVec TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_get_value_intvec ! overloading of DftiGetValue for char vector FUNCTION dfti_get_value_chars ( desc , OptName , Chars ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_get_value_chars !DEC$ ATTRIBUTES REFERENCE :: dfti_get_value_chars INTEGER dfti_get_value_chars INTEGER , INTENT ( IN ) :: OptName CHARACTER ( * ), INTENT ( OUT ) :: Chars TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_get_value_chars END INTERFACE INTERFACE DftiComputeForward ! overloading of DftiComputeForward for SP R2C DFT (inplace) FUNCTION dfti_compute_forward_s ( desc , sSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_s !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_s INTEGER dfti_compute_forward_s TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: sSrcDst END FUNCTION dfti_compute_forward_s ! overloading of DftiComputeForward for SP C2C DFT (inplace) FUNCTION dfti_compute_forward_c ( desc , cSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_c !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_c INTEGER dfti_compute_forward_c TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_SPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: cSrcDst END FUNCTION dfti_compute_forward_c ! overloading of DftiComputeForward for SP C2C DFT (inplace, split complex) FUNCTION dfti_compute_forward_ss ( desc , sSrcDstRe , sSrcDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_ss !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_ss INTEGER dfti_compute_forward_ss TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), DIMENSION ( * ) :: sSrcDstRe REAL ( DFTI_SPKP ), DIMENSION ( * ) :: sSrcDstIm END FUNCTION dfti_compute_forward_ss ! overloading of DftiComputeForward for SP R2C DFT (out-of-place) FUNCTION dfti_compute_forward_sc ( desc , sSrc , cDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_sc !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_sc INTEGER dfti_compute_forward_sc TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: sSrc COMPLEX ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: cDst END FUNCTION dfti_compute_forward_sc ! overloading of DftiComputeForward for SP C2C DFT (out-of-place) FUNCTION dfti_compute_forward_cc ( desc , cSrc , cDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_cc !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_cc INTEGER dfti_compute_forward_cc TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: cSrc COMPLEX ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: cDst END FUNCTION dfti_compute_forward_cc ! overloading of DftiComputeForward for SP C2C DFT (out-of-place, split ! complex) FUNCTION dfti_compute_forward_ssss ( desc , sSrcRe , sSrcIm , sDstRe , sDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_ssss !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_ssss INTEGER dfti_compute_forward_ssss TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: sSrcRe REAL ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: sSrcIm REAL ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: sDstRe REAL ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: sDstIm END FUNCTION dfti_compute_forward_ssss ! overloading of DftiComputeForward for DP R2C DFT (inplace) FUNCTION dfti_compute_forward_d ( desc , dSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_d !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_d INTEGER dfti_compute_forward_d TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: dSrcDst END FUNCTION dfti_compute_forward_d ! overloading of DftiComputeForward for DP C2C DFT (inplace) FUNCTION dfti_compute_forward_z ( desc , zSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_z !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_z INTEGER dfti_compute_forward_z TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_DPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: zSrcDst END FUNCTION dfti_compute_forward_z ! overloading of DftiComputeForward for DP C2C DFT (inplace, split complex) FUNCTION dfti_compute_forward_dd ( desc , dSrcDstRe , dSrcDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_dd !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_dd INTEGER dfti_compute_forward_dd TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), DIMENSION ( * ) :: dSrcDstRe REAL ( DFTI_DPKP ), DIMENSION ( * ) :: dSrcDstIm END FUNCTION dfti_compute_forward_dd ! overloading of DftiComputeForward for DP R2C DFT (out-of-place) FUNCTION dfti_compute_forward_dz ( desc , dSrc , zDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_dz !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_dz INTEGER dfti_compute_forward_dz TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: dSrc COMPLEX ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: zDst END FUNCTION dfti_compute_forward_dz ! overloading of DftiComputeForward for DP C2C DFT (out-of-place) FUNCTION dfti_compute_forward_zz ( desc , zSrc , zDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_zz !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_zz INTEGER dfti_compute_forward_zz TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: zSrc COMPLEX ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: zDst END FUNCTION dfti_compute_forward_zz ! overloading of DftiComputeForward for DP C2C DFT (out-of-place, split ! complex) FUNCTION dfti_compute_forward_dddd ( desc , dSrcRe , dSrcIm , dDstRe , dDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_forward_dddd !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_forward_dddd INTEGER dfti_compute_forward_dddd TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: dSrcRe REAL ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: dSrcIm REAL ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: dDstRe REAL ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: dDstIm END FUNCTION dfti_compute_forward_dddd END INTERFACE DftiComputeForward INTERFACE DftiComputeBackward ! overloading of DftiComputeBackward for SP C2R DFT (inplace) FUNCTION dfti_compute_backward_s ( desc , sSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_s !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_s INTEGER dfti_compute_backward_s TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: sSrcDst END FUNCTION dfti_compute_backward_s ! overloading of DftiComputeBackward for SP C2C DFT (inplace) FUNCTION dfti_compute_backward_c ( desc , cSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_c !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_c INTEGER dfti_compute_backward_c TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_SPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: cSrcDst END FUNCTION dfti_compute_backward_c ! overloading of DftiComputeBackward for SP C2C DFT (inplace, split complex) FUNCTION dfti_compute_backward_ss ( desc , sSrcDstRe , sSrcDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_ss !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_ss INTEGER dfti_compute_backward_ss TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), DIMENSION ( * ) :: sSrcDstRe REAL ( DFTI_SPKP ), DIMENSION ( * ) :: sSrcDstIm END FUNCTION dfti_compute_backward_ss ! overloading of DftiComputeBackward for SP C2R DFT (out-of-place) FUNCTION dfti_compute_backward_cs ( desc , cSrc , sDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_cs !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_cs INTEGER dfti_compute_backward_cs TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: cSrc REAL ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: sDst END FUNCTION dfti_compute_backward_cs ! overloading of DftiComputeBackward for SP C2C DFT (out-of-place) FUNCTION dfti_compute_backward_cc ( desc , cSrc , cDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_cc !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_cc INTEGER dfti_compute_backward_cc TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: cSrc COMPLEX ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: cDst END FUNCTION dfti_compute_backward_cc ! overloading of DftiComputeBackward for SP C2C DFT (out-of-place, split ! complex) FUNCTION dfti_compute_backward_ssss ( desc , sSrcRe , sSrcIm , sDstRe , sDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_ssss !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_ssss INTEGER dfti_compute_backward_ssss TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: sSrcRe REAL ( DFTI_SPKP ), INTENT ( IN ), DIMENSION ( * ) :: sSrcIm REAL ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: sDstRe REAL ( DFTI_SPKP ), INTENT ( OUT ), DIMENSION ( * ) :: sDstIm END FUNCTION dfti_compute_backward_ssss ! overloading of DftiComputeBackward for DP C2R DFT (inplace) FUNCTION dfti_compute_backward_d ( desc , dSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_d !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_d INTEGER dfti_compute_backward_d TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: dSrcDst END FUNCTION dfti_compute_backward_d ! overloading of DftiComputeBackward for DP C2C DFT (inplace) FUNCTION dfti_compute_backward_z ( desc , zSrcDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_z !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_z INTEGER dfti_compute_backward_z TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_DPKP ), INTENT ( INOUT ), DIMENSION ( * ) :: zSrcDst END FUNCTION dfti_compute_backward_z ! overloading of DftiComputeBackward for DP C2C DFT (inplace, split complex) FUNCTION dfti_compute_backward_dd ( desc , dSrcDstRe , dSrcDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_dd !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_dd INTEGER dfti_compute_backward_dd TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), DIMENSION ( * ) :: dSrcDstRe REAL ( DFTI_DPKP ), DIMENSION ( * ) :: dSrcDstIm END FUNCTION dfti_compute_backward_dd ! overloading of DftiComputeBackward for DP C2R DFT (out-of-place) FUNCTION dfti_compute_backward_zd ( desc , zSrc , dDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_zd !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_zd INTEGER dfti_compute_backward_zd TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: zSrc REAL ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: dDst END FUNCTION dfti_compute_backward_zd ! overloading of DftiComputeBackward for DP C2C DFT (out-of-place) FUNCTION dfti_compute_backward_zz ( desc , zSrc , zDst ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_zz !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_zz INTEGER dfti_compute_backward_zz TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc COMPLEX ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: zSrc COMPLEX ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: zDst END FUNCTION dfti_compute_backward_zz ! overloading of DftiComputeBackward for DP C2C DFT (out-of-place, split ! complex) FUNCTION dfti_compute_backward_dddd ( desc , dSrcRe , dSrcIm , dDstRe , dDstIm ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_compute_backward_dddd !DEC$ ATTRIBUTES REFERENCE :: dfti_compute_backward_dddd INTEGER dfti_compute_backward_dddd TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc REAL ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: dSrcRe REAL ( DFTI_DPKP ), INTENT ( IN ), DIMENSION ( * ) :: dSrcIm REAL ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: dDstRe REAL ( DFTI_DPKP ), INTENT ( OUT ), DIMENSION ( * ) :: dDstIm END FUNCTION dfti_compute_backward_dddd END INTERFACE DftiComputeBackward INTERFACE DftiFreeDescriptor FUNCTION dfti_free_descriptor_external ( desc ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_free_descriptor_external !DEC$ ATTRIBUTES REFERENCE :: dfti_free_descriptor_external INTEGER dfti_free_descriptor_external TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END FUNCTION dfti_free_descriptor_external END INTERFACE INTERFACE DftiErrorClass FUNCTION dfti_error_class_external ( Status , ErrorClass ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_error_class_external !DEC$ ATTRIBUTES REFERENCE :: dfti_error_class_external LOGICAL dfti_error_class_external INTEGER , INTENT ( IN ) :: Status INTEGER , INTENT ( IN ) :: ErrorClass END FUNCTION dfti_error_class_external END INTERFACE INTERFACE DftiErrorMessage FUNCTION dfti_error_message_external ( Status ) USE MKL_DFT_TYPE !DEC$ ATTRIBUTES C :: dfti_error_message_external !DEC$ ATTRIBUTES REFERENCE :: dfti_error_message_external CHARACTER ( LEN = DFTI_MAX_MESSAGE_LENGTH ) :: dfti_error_message_external INTEGER , INTENT ( IN ) :: Status END FUNCTION dfti_error_message_external END INTERFACE END MODULE MKL_DFTI","tags":"","loc":"sourcefile/mkl_dfti.f90.html"},{"title":"deviceHam_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~deviceham_mod.f90~~EfferentGraph sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~graph_partition.f90 graph_partition.f90 sourcefile~deviceham_mod.f90->sourcefile~graph_partition.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~deviceham_mod.f90->sourcefile~matrix_c.f90 sourcefile~wannierham3d.f90 wannierHam3d.f90 sourcefile~deviceham_mod.f90->sourcefile~wannierham3d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~deviceham_mod.f90~~AfferentGraph sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules deviceHam_mod Source Code deviceHam_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! module deviceHam_mod implicit none private integer , parameter :: dp = 8 public :: devH_build_fromCOOfile , devH_build_fromWannierFile contains subroutine load_COOmatrix ( fname , H , nnz , nm , row , col , use0index , iscomplex ) character ( len =* ), intent ( in ) :: fname !! input text file name complex ( dp ), allocatable , intent ( inout ), dimension (:) :: H integer , allocatable , intent ( inout ), dimension (:) :: row , col integer , intent ( out ) :: nnz integer , intent ( out ) :: nm logical , intent ( in ), optional :: use0index , iscomplex logical :: l0index real ( dp ) :: re , im integer :: handle , io integer :: M , NL , i , j , k handle = 101 l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of lines do read ( handle , * , IOSTAT = IO ) i , j , re if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of nonzeros = \",i18)' , NL allocate ( H ( NL )) allocate ( row ( NL )) allocate ( col ( NL )) H = 0.0d0 nnz = NL nm = M ! Read again the file for the matrix rewind handle im = 0.0d0 do k = 1 , NL if (( present ( iscomplex )) . and . iscomplex ) then read ( handle , * ) i , j , re , im else read ( handle , * ) i , j , re end if if ( l0index ) then i = i + 1 j = j + 1 end if row ( k ) = i col ( k ) = j H ( k ) = dcmplx ( re , im ) end do close ( handle ) end subroutine load_COOmatrix subroutine devH_build_fromCOOfile ( hfname , Hii , H1i , Sii , ext , contactBlockSize , nx , use0index , iscomplex , threshold , blocksize , sfname ) use matrix_c , only : type_matrix_complex , malloc use graph_partition , only : slice , convert_fromCOO implicit none character ( len =* ), intent ( in ) :: hfname !! input H file name character ( len =* ), intent ( in ), optional :: sfname !! input S file name integer , intent ( in ) :: ext ( 2 ) !! number of extension blocks on left/right side integer , intent ( in ) :: contactBlockSize ( 2 ) !! number of orbitals in the contact block integer , intent ( out ) :: nx !! total number of slices integer , intent ( in ), optional :: blocksize !! blocksize of H type ( type_matrix_complex ), dimension (:), intent ( inout ), allocatable :: Hii , H1i , Sii !! Hamiltonian blocks logical , intent ( in ), optional :: use0index , iscomplex real ( dp ), intent ( in ), optional :: threshold ! ---- integer :: nnz , norb , i , newnnz , j , num_slices , nmax , ix , mm , nn integer , allocatable , dimension (:, :) :: nmii , nm1i complex ( dp ), allocatable , dimension (:) :: H , newH !! Hamiltonian matrix value in COO complex ( dp ), allocatable , dimension (:) :: S , newS !! overlap matrix value in COO integer , allocatable , dimension (:) :: row , col !! Hamiltonian matrix index in COO integer , allocatable , dimension (:) :: newrow , newcol !! Hamiltonian matrix index in COO integer , allocatable , dimension (:, :) :: Slices !! slicing information , refer to [[graph_partition]] integer , allocatable , dimension (:, :) :: g !! graph , refer to [[graph_partition]] integer , dimension ( contactBlockSize ( 1 )) :: E1 !! edge 1 , refer to [[graph_partition]] integer , dimension ( contactBlockSize ( 2 )) :: E2 !! edge 2 , refer to [[graph_partition]] ! if ( present ( sfname )) call load_COOmatrix ( trim ( Sfname ), S , nnz , norb , row , col , use0index , iscomplex ) call load_COOmatrix ( trim ( hfname ), H , nnz , norb , row , col , use0index , iscomplex ) ! ! ! optionally remove small matrix elements below threshold ! if (present(threshold)) then !     newnnz = count(abs(H) > threshold) !     allocate (newH(newnnz)) !     if (present(sfname)) allocate (newS(newnnz)) !     allocate (newrow(newnnz)) !     allocate (newcol(newnnz)) !     j = 0 !     do i = 1, nnz !         if (abs(H(i)) > threshold) then !             j = j + 1 !             newH(j) = H(i) !             if (present(sfname)) newS(j) = S(i) !             newrow(j) = row(i) !             newcol(j) = col(i) !         end if !     end do !     deallocate (H, row, col) !     if (present(sfname)) deallocate (S) !     call move_alloc(newH, H) !     if (present(sfname)) call move_alloc(newS, S) !     call move_alloc(newrow, row) !     call move_alloc(newcol, col) !     nnz = newnnz ! end if ! ! convert sparse matrix to a graph ! call convert_fromCOO(nnz, row, col, g) ! forall (i=1:contactBlockSize(1)) E1(i) = i ! forall (i=1:contactBlockSize(2)) E2(i) = norb - contactBlockSize(2) + i ! ! slice the device ! nmax = 100 ! ! try 1 contact slicing from left ! call slice(g, E1, Slices) ! slicing from left to right ! num_slices = size(Slices, 2) ! if (((Slices(1, num_slices) - 1) < contactBlockSize(2)) .or. & !     ((maxval(Slices(1, :)) - minval(Slices(1, :))) > (2*minval(Slices(1, :))))) then !     ! too small right contact , or very unbalanced slicing !     ! try 1 contact slicing from right !     call slice(g, E2, Slices) ! slicing from right to left !     num_slices = size(Slices, 2) !     if (((Slices(1, 1) - 1) < contactBlockSize(1)) .or. & !         ((maxval(Slices(1, :)) - minval(Slices(1, :))) > (2*minval(Slices(1, :))))) then !         ! too small left contact , or very unbalanced slicing !         call slice(g, E1, E2, NMAX, Slices) ! try 2 contact slicing !         num_slices = size(Slices, 2) !     end if ! end if ! print *, ' Slicing info: ', num_slices, ' slices, with block sizes = ' ! print '(12 I8)', slices(1, :) - 1 ! allocate the blocks : left extension|device|right extension if ( present ( blocksize )) then nx = norb / blocksize else nx = ext ( 1 ) + num_slices + ext ( 2 ) endif ! print * , \"---- nx=\" , nx , \"norb=\" , norb print * , \"---- nnz=\" , nnz print * , \"---- block size=\" , blocksize ! allocate ( nmii ( 2 , nx )) allocate ( nm1i ( 2 , nx + 1 )) ! if ( present ( blocksize )) then nmii = blocksize nm1i = blocksize else nmii (:, 1 : ext ( 1 )) = contactBlockSize ( 1 ) nmii (:, ( nx - ext ( 2 ) + 1 ): nx ) = contactBlockSize ( 2 ) nmii ( 1 , ext ( 1 ):( nx - ext ( 2 ))) = Slices ( 1 , :) - 1 nmii ( 2 , ext ( 1 ):( nx - ext ( 2 ))) = Slices ( 1 , :) - 1 nm1i (:, 1 ) = nmii (:, 1 ) nm1i (:, nx + 1 ) = nmii (:, nx ) nm1i ( 1 , 2 : nx ) = nmii ( 1 , 2 : nx ) nm1i ( 2 , 2 : nx ) = nmii ( 1 , 1 :( nx - 1 )) endif ! allocate ( Hii ( nx )) allocate ( Sii ( nx )) allocate ( H1i ( nx + 1 )) call malloc ( Hii , nx , nmii ) call malloc ( Sii , nx , nmii ) call malloc ( H1i , nx + 1 , nm1i ) ! build the blocks do i = 1 , nnz ix = row ( i ) / blocksize + 1 mm = row ( i ) - ( ix - 1 ) * blocksize nn = col ( i ) - ( ix - 1 ) * blocksize ! print *, i, ix, mm, nn if ( ix <= nx ) then if ( nn <= blocksize ) then Hii ( ix )% m ( mm , nn ) = H ( i ) Hii ( ix )% m ( nn , mm ) = conjg ( H ( i )) if ( present ( sfname )) then Sii ( ix )% m ( mm , nn ) = S ( i ) endif else if ( nn <= blocksize * 2 ) then H1i ( ix )% m ( mm , nn - blocksize ) = H ( i ) endif endif endif enddo H1i ( nx + 1 )% m = H1i ( nx )% m if (. not . present ( sfname )) then do ix = 1 , nx do mm = 1 , blocksize Sii ( ix )% m ( mm , mm ) = 1.0d0 enddo enddo endif deallocate ( H , col , row , nmii , nm1i ) if ( present ( sfname )) deallocate ( S ) end subroutine devH_build_fromCOOfile subroutine devH_build_fromWannierFile ( fname , Hii , H1i , Sii , nx , nslab , nband , nk , k , length_x , lreorder_axis , axis ) use matrix_c , only : type_matrix_complex , malloc use wannierHam3d , only : w90_load_from_file , w90_free_memory , w90_MAT_DEF , nb , Lx character ( len =* ), intent ( in ) :: fname !! input text file name logical , intent ( in ), optional :: lreorder_axis !! whether to reorder axis integer , intent ( in ), optional :: axis ( 3 ) !! permutation order integer , intent ( in ) :: nx !! number of slabs integer , intent ( in ) :: nslab !! number of cells per slab integer , intent ( out ) :: nband !! number of bands/orbitals per cell (from wannier90) type ( type_matrix_complex ), dimension (:, :), intent ( inout ), allocatable :: Hii , H1i !! Hamiltonian blocks type ( type_matrix_complex ), dimension (:, :), intent ( inout ), allocatable :: Sii !! overlap matrix blocks real ( dp ), intent ( in ) :: k ( 2 , nk ) real ( dp ), intent ( out ) :: length_x integer , intent ( in ) :: nk ! ---- complex ( dp ), allocatable , dimension (:, :) :: H00 , H10 real ( dp ) :: kx , ky , kz integer :: nm , i , im , ik integer , dimension ( 2 , nx + 1 ) :: nmm print * , \"read w90\" open ( unit = 10 , file = trim ( fname ), status = 'unknown' ) call w90_load_from_file ( 10 , lreorder_axis , axis ) close ( 10 ) print * , \"read w90 DONE\" nm = nb * nslab nband = nb length_x = Lx nmm = nm allocate ( H00 ( nm , nm )) allocate ( H10 ( nm , nm )) kx = 0.0d0 ! allocate ( Hii ( nx , nk )) allocate ( H1i ( nx + 1 , nk )) allocate ( Sii ( nx , nk )) do ik = 1 , nk ky = k ( 1 , ik ) kz = k ( 2 , ik ) call w90_MAT_DEF ( H00 , H10 , kx , ky , kz , nslab ) ! call malloc ( Hii (:, ik ), nx , nmm (:, 1 : nx )) call malloc ( Sii (:, ik ), nx , nmm (:, 1 : nx )) call malloc ( H1i (:, ik ), nx + 1 , nmm ) ! do i = 1 , nx Hii ( i , ik )% m = H00 H1i ( i , ik )% m = H10 Sii ( i , ik )% m = dcmplx ( 0.0d0 , 0.0d0 ) do im = 1 , nm Sii ( i , ik )% m ( im , im ) = 1.0d0 end do end do H1i ( nx + 1 , ik )% m = H10 end do deallocate ( H00 , H10 ) call w90_free_memory () end subroutine devH_build_fromWannierFile end module deviceHam_mod","tags":"","loc":"sourcefile/deviceham_mod.f90.html"},{"title":"wannierHam3d.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~wannierham3d.f90~~AfferentGraph sourcefile~wannierham3d.f90 wannierHam3d.f90 sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~deviceham_mod.f90->sourcefile~wannierham3d.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules wannierHam3d Source Code wannierHam3d.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! ! AUTHOR: Jiang Cao ! MODULE wannierHam3d !! Wannier-related functions IMPLICIT NONE private COMPLEX ( 8 ), ALLOCATABLE :: Hr (:, :, :, :, :) COMPLEX ( 8 ), ALLOCATABLE :: rmn (:, :, :, :, :, :) ! position operator COMPLEX ( 8 ), ALLOCATABLE :: pmn (:, :, :, :, :, :) ! momentum operator COMPLEX ( 8 ), ALLOCATABLE :: Vmn (:, :, :, :, :) ! Coulomb operator real ( 8 ), allocatable :: wannier_center (:, :) REAL ( 8 ), DIMENSION ( 3 ) :: alpha , beta , gamm , xhat , yhat , zhat , b1 , b2 REAL ( 8 ) :: Lx , Ly , Lz , cell ( 3 , 3 ) ! in Ang REAL ( 8 ) :: CBM , VBM , Eg ! CB minimum and VB maximum REAL ( 8 ) :: kt_CBM , kt_VBM ! transverse kt value of CBM and VBM location INTEGER :: ymin , ymax , xmin , xmax , zmin , zmax , nb , nx , ny , nz , nvb , spin_deg ! neighbor index range ! nb is the number of Wannier orbitals in a unit cell COMPLEX ( 8 ), PARAMETER :: zzero = dcmplx ( 0.0d0 , 0.0d0 ) COMPLEX ( 8 ), PARAMETER :: z1j = dcmplx ( 0.0d0 , 1.0d0 ) REAL ( 8 ), PARAMETER :: pi = 3.14159265359d0 REAL ( 8 ), PARAMETER :: m0 = 5.6856D-16 ! eV s2 / cm2 REAL ( 8 ), PARAMETER :: hbar = 6.58211899D-16 ! eV s REAL ( 8 ), PARAMETER :: c0 = 2.998d8 ! m/s public :: w90_free_memory , w90_load_from_file , w90_MAT_DEF public :: NB , Lx , Ly , Lz , Nvb , VBM , CBM , kt_CBM , kt_VBM , Eg , spin_deg public :: eig , cross , eigv , b1 , b2 , norm , wannier_center , alpha , beta , invert public :: w90_MAT_DEF_full_device , w90_bare_coulomb_full_device public :: w90_bare_coulomb_blocks public :: w90_momentum_full_device , w90_momentum_blocks CONTAINS SUBROUTINE w90_free_memory () deallocate ( Hr ) if ( allocated ( rmn )) deallocate ( rmn ) if ( allocated ( pmn )) deallocate ( pmn ) if ( allocated ( Vmn )) deallocate ( Vmn ) deallocate ( wannier_center ) END SUBROUTINE w90_free_memory SUBROUTINE w90_load_from_file ( fid , lreorder_axis , axis ) use , intrinsic :: iso_fortran_env !        include \"mpif.h\" integer , intent ( in ) :: fid logical , intent ( in ), optional :: lreorder_axis integer , intent ( in ), optional :: axis ( 3 ) integer :: n , i , nkx , nky , nkz character ( len = 40 ) :: line , comment REAL ( 8 ) :: dky , dkz , aux1 ( 3 ), aux2 ( 3 , 3 ) integer , allocatable :: ind (:) REAL ( 8 ), allocatable :: ham (:, :), energ (:, :), aux3 (:, :) integer ( kind = int32 ) :: rank integer ( kind = int32 ) :: ierror ! Get the individual process (rank) !        call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierror) rank = 0 read ( fid , * ) nvb , spin_deg ! number of VBs, spin-degeneracy read ( fid , * ) comment read ( fid , * ) alpha read ( fid , * ) beta read ( fid , * ) gamm cell (:, 1 ) = alpha cell (:, 2 ) = beta cell (:, 3 ) = gamm read ( fid , * ) comment if ( present ( lreorder_axis )) then if ( lreorder_axis ) then aux2 (:, :) = cell (:, axis ) cell = aux2 alpha = cell (:, 1 ) beta = cell (:, 2 ) gamm = cell (:, 3 ) end if endif read ( fid , * ) n allocate ( ham ( n , 7 )) do i = 1 , n read ( fid , * ) ham ( i , :) end do if ( present ( lreorder_axis )) then if ( ( lreorder_axis )) then allocate ( aux3 ( n , 7 )) aux3 = ham aux3 (:, 1 : 3 ) = ham (:, axis ) ham = aux3 deallocate ( aux3 ) end if endif xmin = minval ( ham (:, 1 )) xmax = maxval ( ham (:, 1 )) ymin = minval ( ham (:, 2 )) ymax = maxval ( ham (:, 2 )) zmin = minval ( ham (:, 3 )) zmax = maxval ( ham (:, 3 )) nb = maxval ( ham (:, 4 )) nx = xmax - xmin + 1 ny = ymax - ymin + 1 nz = zmax - zmin + 1 xhat = alpha / norm ( alpha ) yhat = - cross ( xhat , gamm ) yhat = yhat / norm ( yhat ) zhat = gamm / norm ( gamm ) Ly = abs ( dot_product ( beta , yhat )); ! L is in unit of A Lx = abs ( dot_product ( alpha , xhat )); Lz = norm ( gamm ) if ( rank == 0 ) then print '(A40)' , 'reading Wannier H from file, info:' print '(8a5)' , 'xmin' , 'xmax' , 'ymin' , 'ymax' , 'zmin' , 'zmax' , 'nb' , 'nvb' print '(8i5)' , xmin , xmax , ymin , ymax , zmin , zmax , nb , nvb print '(3a5)' , 'Lx' , 'Ly' , 'Lz' print '(3f5.1)' , Lx , Ly , Lz end if b1 = cross ( beta , gamm ) / dot_product ( alpha , cross ( beta , gamm )) b2 = cross ( gamm , alpha ) / dot_product ( beta , cross ( gamm , alpha )) allocate ( Hr ( nb , nb , nx , ny , nz )) Hr (:, :, :, :, :) = zzero do i = 1 , n Hr ( floor ( ham ( i , 4 )), floor ( ham ( i , 5 )), floor ( ham ( i , 1 )) - xmin + 1 ,& & floor ( ham ( i , 2 )) - ymin + 1 , floor ( ham ( i , 3 )) - zmin + 1 ) = ham ( i , 6 ) + z1j * ham ( i , 7 ); end do !print *, 'Find CBM and VBM' nkx = floor (( 1.0d0 / Lx ) / 0.01d0 ) + 1 nky = floor (( 1.0d0 / Ly ) / 0.01d0 ) + 1 nkz = floor (( 1.0d0 / Lz ) / 0.01d0 ) + 1 if ( nx == 1 ) nkx = 1 if ( ny == 1 ) nky = 1 if ( nz == 1 ) nkz = 1 if ( ny . eq . 1 ) then nky = 1 end if if ( nx . eq . 1 ) then nkx = 1 end if if ( nz . eq . 1 ) then nkz = 1 end if if ( nky > 1 ) then dky = 1.0d0 / dble ( nky - 1 ) * 2 * pi / Ly else dky = 2 * pi / Ly end if if ( nkz > 1 ) then dkz = 1.0d0 / dble ( nkz - 1 ) * 2 * pi / Lz else dkz = 2 * pi / Lz end if allocate ( energ ( nb , nkx * nky * nkz )) allocate ( ind ( nb )) call w90_PLOT_BZ ( nkx , nky , nkz , energ ) ind = maxloc ( energ , 2 ) kt_vbm = mod ( ind ( nvb ), nkx ) * dky - pi / Ly ! k transverse corresponding to VBMax ind = minloc ( energ , 2 ) kt_cbm = mod ( ind ( nvb + 1 ), nkx ) * dky - pi / Ly ! k transverse corresponding to CBM if ( ny . eq . 1 ) then kt_cbm = 0.0d0 kt_vbm = 0.0d0 end if ind = maxloc ( energ , 2 ) VBM = energ ( nvb , ind ( nvb )) ind = minloc ( energ , 2 ) CBM = energ ( nvb + 1 , ind ( nvb + 1 )) Eg = CBM - VBM if ( rank == 0 ) then print '(3A8)' , 'CBM' , 'VBM' , 'Eg' print '(3f8.3)' , CBM , VBM , CBM - VBM print '(3A8)' , 'kt_CBM' , 'kt_VBM' , '2pi/Ly' print '(2f8.3)' , kt_cbm / ( 2.0 * pi / Ly ), kt_vbm / ( 2.0 * pi / Ly ) print '(A40)' , 'reading Wannier centers from file' end if read ( fid , * ) comment allocate ( wannier_center ( 3 , nb )) do i = 1 , nb read ( fid , * ) wannier_center (:, i ) end do if ( present ( lreorder_axis ) ) then if ( ( lreorder_axis )) then allocate ( aux3 ( 3 , nb )) aux3 = wannier_center aux3 ( 1 : 3 , :) = wannier_center ( axis , :) wannier_center = aux3 deallocate ( aux3 ) end if endif ! bring wannier_center into the first unit-cell, only works for orth. ! to-do: make this general do i = 1 , NB if ( wannier_center ( 1 , i ) < 0 ) wannier_center (:, i ) = wannier_center (:, i ) + alpha if ( wannier_center ( 1 , i ) > Lx ) wannier_center (:, i ) = wannier_center (:, i ) - alpha if ( wannier_center ( 2 , i ) < 0 ) wannier_center (:, i ) = wannier_center (:, i ) + beta if ( wannier_center ( 2 , i ) > Ly ) wannier_center (:, i ) = wannier_center (:, i ) - beta if ( wannier_center ( 3 , i ) < 0 ) wannier_center (:, i ) = wannier_center (:, i ) + gamm if ( wannier_center ( 3 , i ) > Lz ) wannier_center (:, i ) = wannier_center (:, i ) - gamm end do ! center z around 0 wannier_center ( 3 , :) = wannier_center ( 3 , :) - ( sum ( wannier_center ( 3 , :) / dble ( NB ))) deallocate ( ham ) deallocate ( energ ) deallocate ( ind ) END SUBROUTINE w90_load_from_file SUBROUTINE w90_PLOT_BZ ( nkx , nky , nkz , EN ) implicit none integer , intent ( in ) :: nkx , nky , nkz real ( 8 ), dimension ( nb , nkx * nky * nkz ), intent ( out ) :: EN integer :: i , j , l real ( 8 ) :: dkx , dky , dkz , kx , ky , kz complex ( 8 ), dimension ( NB , NB ) :: Hii if ( nkx > 1 ) then dkx = 1.0d0 / dble ( nkx - 1 ) * 2 * pi / Lx else dkx = pi / Lx end if if ( nky > 1 ) then dky = 1.0d0 / dble ( nky - 1 ) * 2 * pi / Ly else dky = pi / Ly end if if ( nkz > 1 ) then dkz = 1.0d0 / dble ( nkz - 1 ) * 2 * pi / Lz else dkz = pi / Lz end if do i = 1 , nkx do j = 1 , nky do l = 1 , nkz kx = i * dkx - pi / Lx ky = j * dky - pi / Ly kz = l * dkz - pi / Lz call w90_MAT_DEF_3D ( Hii , kx , ky , kz ) EN ( 1 : NB , i + ( j - 1 ) * nkx + ( l - 1 ) * nkx * nky ) = eig ( NB , Hii ) end do end do end do END SUBROUTINE w90_PLOT_BZ !!! construct the diagonal and off-diagonal blocks H(I,I), H(I+1,I) SUBROUTINE w90_MAT_DEF ( Hii , H1i , kx , ky , kz , ns ) ! ky in [2pi/Ang] implicit none integer , intent ( in ) :: ns COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB * ns , NB * ns ) :: Hii , H1i real ( 8 ), intent ( in ) :: ky , kx , kz integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r Hii (:, :) = zzero H1i (:, :) = zzero do i = 1 , ns do k = 1 , ns do j = ymin , ymax do l = zmin , zmax kv = kx * xhat + ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Hr (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) end if if ((( i - k + ns ) <= xmax ) . and . (( i - k + ns ) >= xmin )) then H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Hr (:, :, i - k - xmin + ns + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) end if end do end do end do end do END SUBROUTINE w90_MAT_DEF !!! construct the fully periodic Hamiltonian matrix SUBROUTINE w90_MAT_DEF_3D ( Hii , kx , ky , kz ) ! kx and ky is in unit of [2pi/Ang] implicit none REAL ( 8 ), INTENT ( IN ) :: kx , ky , kz COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB , NB ) :: Hii real ( 8 ), dimension ( 3 ) :: kv , r integer :: i , j , l Hii (:, :) = zzero kv = kx * xhat + ky * yhat + kz * zhat do i = xmin , xmax do j = ymin , ymax do l = zmin , zmax r = dble ( i ) * alpha + dble ( j ) * beta + dble ( l ) * gamm Hii (:, :) = Hii (:, :) + Hr (:, :, i - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) & & * exp ( - z1j * dot_product ( r , kv )) end do end do end do !!! Hii = (Hii + transpose(conjg(Hii))) / 2.0d0 END SUBROUTINE w90_MAT_DEF_3D !!! construct the full-device Hamiltonian Matrix SUBROUTINE w90_MAT_DEF_full_device ( Ham , ky , kz , length , NS ) implicit none integer , intent ( in ) :: length integer , intent ( in ), optional :: NS real ( 8 ), intent ( in ) :: ky , kz complex ( 8 ), intent ( inout ), dimension ( NB * length , NB * length ) :: Ham integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r complex ( 8 ) :: phi Ham = dcmplx ( 0.0d0 , 0.0d0 ) do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm phi = dcmplx ( 0.0d0 , - dot_product ( r , kv )) if ( present ( NS )) then if (( i - k <= min ( NS , xmax )) . and . ( i - k >= max ( - NS , xmin ))) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & Hr (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if else if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & Hr (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if end if end do end do end do end do END SUBROUTINE w90_MAT_DEF_full_device !!! construct the diagonal and off-diagonal blocks V(I,I), V(I+1,I) SUBROUTINE w90_bare_coulomb_blocks ( Hii , H1i , kx , ky , kz , eps , r0 , NS , ldiag ) ! ky in [2pi/Ang] implicit none integer , intent ( in ) :: ns COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB * ns , NB * ns ) :: Hii , H1i real ( 8 ), intent ( in ) :: ky , kx , kz real ( 8 ), intent ( in ) :: eps ! dielectric constant real ( 8 ), intent ( in ) :: r0 ! length [ang] to remove singularity of 1/r logical , intent ( in ) :: ldiag ! include diagonal integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r Hii (:, :) = zzero H1i (:, :) = zzero kv = kx * xhat + ky * yhat + kz * zhat do i = 1 , ns do k = 1 , ns do j = ymin , ymax do l = zmin , zmax r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k + ns , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end do end do end do end do END SUBROUTINE w90_bare_coulomb_blocks !!! construct the bare Coulomb Matrix for the full-device SUBROUTINE w90_bare_coulomb_full_device ( V , ky , kz , length , eps , r0 , ldiag , NS , method ) implicit none integer , intent ( in ) :: length integer , intent ( in ), optional :: NS real ( 8 ), intent ( in ) :: ky , kz , eps ! dielectric constant / to reduce V real ( 8 ), intent ( in ) :: r0 ! length [ang] to remove singularity of 1/r logical , intent ( in ) :: ldiag ! include diagonal character ( len =* ), intent ( in ), optional :: method character ( len = 20 ) :: cmethod complex ( 8 ), intent ( out ), dimension ( NB * length , NB * length ) :: V integer :: i , j , k , l real ( 8 ), dimension ( 3 ) :: kv , r V = dcmplx ( 0.0d0 , 0.0d0 ) if ( present ( method )) then cmethod = method else cmethod = 'pointlike' end if select case ( trim ( cmethod )) case ( 'pointlike' ) do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm if ( present ( NS )) then if (( i - k <= NS ) . and . ( i - k >= - NS )) then V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end if else V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end if end do end do end do end do case ( 'fromfile' ) call w90_load_coulomb_blocks do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm if ( present ( NS )) then if (( i - k <= NS ) . and . ( i - k >= - NS )) then V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Vmn (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) / eps end if else if ( abs ( i - k ) < 4 ) then V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & Vmn (:, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( - z1j * dot_product ( r , kv )) / eps else V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) = & V ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb ) + & & bare_coulomb ( i - k , j , l , eps , r0 , ldiag ) * exp ( - z1j * dot_product ( r , kv )) end if end if end do end do end do end do end select END SUBROUTINE w90_bare_coulomb_full_device ! function to calculate the bare coulomb potential for wannier orbitals between the (0,0) and (a1,a2) cells FUNCTION bare_coulomb ( a1 , a2 , a3 , eps , r0 , ldiag ) implicit none integer , intent ( in ) :: a1 , a2 , a3 real ( 8 ), dimension ( NB , NB ) :: bare_coulomb real ( 8 ), intent ( in ) :: eps ! dielectric constant real ( 8 ), intent ( in ) :: r0 ! length [ang] to remove singularity of 1/r logical , intent ( in ) :: ldiag ! include diagonal real ( 8 ), parameter :: pi = 3.14159265359d0 real ( 8 ), parameter :: e = 1.6d-19 ! charge of an electron (C) real ( 8 ), parameter :: epsilon0 = 8.85e-12 ! Permittivity of free space (m&#94;-3 kg&#94;-1 s&#94;4 A&#94;2) real ( 8 ) :: r ( 3 ), normr real ( 8 ) :: maxV integer :: i , j do i = 1 , NB do j = 1 , NB r = dble ( a1 ) * alpha + dble ( a2 ) * beta + dble ( a3 ) * gamm + wannier_center (:, i ) - wannier_center (:, j ) normr = norm ( r ) if ( normr > 0.0d0 ) then bare_coulomb ( i , j ) = ( e ) / ( 4.0d0 * pi * epsilon0 * eps * normr * 1.0d-10 ) * tanh ( normr / r0 ) ! in eV else if ( ldiag ) then bare_coulomb ( i , j ) = ( e ) / ( 4.0d0 * pi * epsilon0 * eps * 1.0d-10 ) * ( 1.0d0 / r0 ) ! self-interaction else bare_coulomb ( i , j ) = 0.0d0 end if end if end do end do END FUNCTION bare_coulomb !!! construct the diagonal and off-diagonal blocks P(I,I), P(I+1,I) SUBROUTINE w90_momentum_blocks ( Hii , H1i , kx , ky , kz , NS , method ) ! ky in [2pi/Ang] implicit none integer , intent ( in ) :: ns COMPLEX ( 8 ), INTENT ( OUT ), DIMENSION ( NB * ns , NB * ns , 3 ) :: Hii , H1i ! momentum matrix block [eV] real ( 8 ), intent ( in ) :: ky , kx , kz character ( len =* ), intent ( in ) :: method integer :: i , j , k , l , v real ( 8 ), dimension ( 3 ) :: kv , r complex ( 8 ) :: phi Hii (:, :, :) = zzero H1i (:, :, :) = zzero call calc_momentum_operator ( method ) kv = kx * xhat + ky * yhat + kz * zhat do v = 1 , 3 ! cart direction do i = 1 , ns do k = 1 , ns do j = ymin , ymax do l = zmin , zmax r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm phi = dcmplx ( 0.0d0 , - dot_product ( r , kv )) if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & Hii ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if if ((( i - k + ns ) <= xmax ) . and . (( i - k + ns ) >= xmin )) then H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & H1i ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 + NS , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if end do end do end do end do end do END SUBROUTINE w90_momentum_blocks SUBROUTINE w90_momentum_full_device ( Ham , ky , kz , length , NS , method ) implicit none integer , intent ( in ) :: length integer , intent ( in ), optional :: NS real ( 8 ), intent ( in ) :: ky , kz complex ( 8 ), intent ( inout ), dimension ( NB * length , NB * length , 3 ) :: Ham ! momentum matrix [eV] character ( len =* ), intent ( in ) :: method integer :: i , j , k , v , l real ( 8 ), dimension ( 3 ) :: kv , r complex ( 8 ) :: phi Ham = dcmplx ( 0.0d0 , 0.0d0 ) call calc_momentum_operator ( method ) do v = 1 , 3 ! cart direction do i = 1 , length do k = 1 , length do j = ymin , ymax do l = zmin , zmax kv = ky * yhat + kz * zhat r = dble ( i - k ) * alpha + dble ( j ) * beta + dble ( l ) * gamm phi = dcmplx ( 0.0d0 , - dot_product ( r , kv )) if ( present ( NS )) then if (( i - k <= min ( NS , xmax )) . and . ( i - k >= max ( - NS , xmin ))) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if else if (( i - k <= xmax ) . and . ( i - k >= xmin )) then Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) = & Ham ((( i - 1 ) * nb + 1 ): i * nb , (( k - 1 ) * nb + 1 ): k * nb , v ) + & & pmn ( v , :, :, i - k - xmin + 1 , j - ymin + 1 , l - zmin + 1 ) * exp ( phi ) end if end if end do end do end do end do end do END SUBROUTINE w90_momentum_full_device ! SUBROUTINE calc_momentum_operator ( method ) implicit none character ( len =* ), intent ( in ) :: method integer :: io , jo , ix , iy , iz , mx , my , mz , mo real ( 8 ) :: r ( 3 ) complex ( 8 ) :: pre_fact if (. not . ( allocated ( pmn ))) allocate ( pmn ( 3 , NB , NB , nx , ny , nz )) ! [eV] pre_fact = 1.0d-8 * dcmplx ( 0.0d0 , 1.0d0 ) * m0 / hbar * 1.0d2 * c0 ! multiply light-speed so c0*pmn in energy eV select case ( method ) case ( 'approx' ) ! use wannier centers, point-like orbitals pmn = 0.0d0 do io = 1 , NB do jo = 1 , NB do ix = xmin , xmax do iy = ymin , ymax do iz = zmin , zmax r = dble ( ix ) * alpha + dble ( iy ) * beta + dble ( iz ) * gamm + wannier_center (:, io ) - wannier_center (:, jo ) pmn (:, io , jo , ix - xmin + 1 , iy - ymin + 1 , iz - zmin + 1 ) = & Hr ( io , jo , ix - xmin + 1 , iy - ymin + 1 , iz - zmin + 1 ) * r end do end do end do end do end do pmn = pmn * pre_fact case ( 'exact' ) ! use position operator : im_0/hbar sum_{R'l} H_{nl}(R-R') r_{lm}(R') - r_{nl}(R-R') H_{lm}(R') pmn = 0.0d0 do io = 1 , NB do jo = 1 , NB do ix = xmin , xmax do iy = ymin , ymax do iz = zmin , zmax do mo = 1 , NB do mx = xmin , xmax do my = ymin , ymax do mz = zmin , zmax if ((( ix - mx ) >= xmin ) . and . (( ix - mx ) <= xmax ) . and . (( iy - my ) >= ymin ) & . and . (( iy - my ) <= ymax ) . and . (( iz - mz ) >= zmin ) . and . (( iz - mz ) <= zmax )) then pmn (:, io , jo , ix - xmin + 1 , iy - ymin + 1 , iz - zmin + 1 ) = & pmn (:, io , jo , ix - xmin + 1 , iy - ymin + 1 , iz - zmin + 1 ) & + Hr ( io , mo , ix - mx - xmin + 1 , iy - my - ymin + 1 , iz - zmin + 1 ) & * rmn (:, mo , jo , mx - xmin + 1 , my - ymin + 1 , mz - zmin + 1 ) & - rmn (:, io , mo , ix - mx - xmin + 1 , iy - my - ymin + 1 , iz - mz - zmin + 1 ) & * Hr ( mo , jo , mx - xmin + 1 , my - ymin + 1 , mz - zmin + 1 ) end if end do end do end do end do end do end do end do end do end do pmn = pmn * pre_fact case default print * , 'Unknown method!!' call abort () end select END SUBROUTINE FUNCTION norm ( vector ) implicit none REAL ( 8 ) :: vector ( 3 ), norm norm = sqrt ( dot_product ( vector , vector )) END FUNCTION FUNCTION cross ( a , b ) implicit none REAL ( 8 ), DIMENSION ( 3 ) :: cross REAL ( 8 ), DIMENSION ( 3 ), INTENT ( IN ) :: a , b cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION cross FUNCTION eig ( NN , A ) implicit none INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A REAL ( 8 ) :: eig ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) CALL zheev ( 'N' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eig (:) = W (:) END FUNCTION eig FUNCTION eigv ( NN , A ) implicit none INTEGER , INTENT ( IN ) :: NN COMPLEX ( 8 ), INTENT ( INOUT ), DIMENSION (:, :) :: A REAL ( 8 ) :: eigv ( NN ) real ( 8 ) :: W ( 1 : NN ) integer :: INFO , LWORK , lrwork complex ( 8 ), allocatable :: work (:) real ( 8 ), allocatable :: RWORK (:) !integer, allocatable :: iwork(:) lwork = max ( 1 , 2 * NN - 1 ) lrwork = max ( 1 , 3 * NN - 2 ) allocate ( work ( lwork )) allocate ( rwork ( lrwork )) CALL zheev ( 'V' , 'U' , NN , A , NN , W , WORK , LWORK , RWORK , INFO ) deallocate ( work , rwork ) if ( INFO . ne . 0 ) then write ( * , * ) 'SEVERE WARNING: ZHEEV HAS FAILED. INFO=' , INFO call abort () end if eigv (:) = W (:) END FUNCTION eigv subroutine invert ( A , nn ) implicit none integer :: info , lda , lwork , nn integer , dimension (:), allocatable :: ipiv complex ( 8 ), dimension ( nn , nn ), intent ( inout ) :: A complex ( 8 ), dimension (:), allocatable :: work allocate ( work ( nn * nn )) allocate ( ipiv ( nn )) call zgetrf ( nn , nn , A , nn , ipiv , info ) call zgetri ( nn , A , nn , ipiv , work , nn * nn , info ) deallocate ( work ) deallocate ( ipiv ) end subroutine invert subroutine w90_load_coulomb_blocks () implicit none integer :: i real ( 8 ) :: reV ( NB ) real ( 8 ), parameter :: ry2ev = 1 3.6d0 real ( 8 ) :: tmp ( NB , NB ) allocate ( Vmn ( NB , NB , nx , ny , nz )) Vmn = dcmplx ( 0.0d0 , 0.0d0 ) open ( unit = 10 , file = 'V_CNT_0_0_dat' , status = 'unknown' ) do i = 1 , NB read ( 10 , * ) reV ( 1 : NB ) Vmn (:, i , - xmin + 1 , 1 , 1 ) = dcmplx ( reV , 0.0d0 ) * ry2ev Vmn ( i , i , - xmin + 1 , 1 , 1 ) = dcmplx ( max ( reV ( i ) * ry2ev , 0.01 ), 0.0d0 ) end do close ( 10 ) !! symmetrize V tmp = transpose ( conjg ( Vmn (:, :, - xmin + 1 , 1 , 1 ))) Vmn (:, :, - xmin + 1 , 1 , 1 ) = ( Vmn (:, :, - xmin + 1 , 1 , 1 ) + tmp (:, :)) / 2.0d0 open ( unit = 10 , file = 'V_CNT_0_1_dat' , status = 'unknown' ) do i = 1 , NB read ( 10 , * ) reV ( 1 : NB ) Vmn (:, i , - xmin + 2 , 1 , 1 ) = dcmplx ( reV , 0.0d0 ) * ry2ev end do close ( 10 ) open ( unit = 10 , file = 'V_CNT_0_2_dat' , status = 'unknown' ) do i = 1 , NB read ( 10 , * ) reV ( 1 : NB ) Vmn (:, i , - xmin + 3 , 1 , 1 ) = dcmplx ( reV , 0.0d0 ) * ry2ev end do close ( 10 ) open ( unit = 10 , file = 'V_CNT_0_3_dat' , status = 'unknown' ) do i = 1 , NB read ( 10 , * ) reV ( 1 : NB ) Vmn (:, i , - xmin + 4 , 1 , 1 ) = dcmplx ( reV , 0.0d0 ) * ry2ev end do close ( 10 ) do i = 1 , 3 Vmn (:, :, - xmin + 1 - i , 1 , 1 ) = transpose ( conjg ( Vmn (:, :, - xmin + 1 + i , 1 , 1 ))) end do end subroutine w90_load_coulomb_blocks END MODULE wannierHam3d","tags":"","loc":"sourcefile/wannierham3d.f90.html"},{"title":"fft_mod.f90 – Quantum transport simulator","text":"!!!!!!!!!!!!!! AUTHOR: Jiang Cao\n!!!!!!!!!!!!!! DATE: 08/2023 This file depends on sourcefile~~fft_mod.f90~~EfferentGraph sourcefile~fft_mod.f90 fft_mod.f90 sourcefile~mkl_dfti.f90 mkl_dfti.f90 sourcefile~fft_mod.f90->sourcefile~mkl_dfti.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules fft_mod Source Code fft_mod.f90 Source Code !!!!!!!!!!!!!!!! AUTHOR: Jiang Cao !!!!!!!!!!!!!!!! DATE: 08/2023 module fft_mod !! FFT, conv, and corr functions implicit none private public :: corr1d , conv1d , do_mkl_dfti_conv public :: corr1d2 , conv1d2 complex ( 8 ), parameter :: cone = cmplx ( 1.0d0 , 0.0d0 ) complex ( 8 ), parameter :: czero = cmplx ( 0.0d0 , 0.0d0 ) complex ( 8 ), parameter :: c1i = cmplx ( 0.0d0 , 1.0d0 ) REAL ( 8 ), PARAMETER :: pi = 3.14159265359d0 REAL ( 8 ), PARAMETER :: tpi = 3.14159265359d0 * 2.0d0 CONTAINS ! Z(nop) = sum_ie X(ie) Y(ie-nop) function corr1d ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n ) complex ( 8 ) :: Z ( 2 * n - 1 ) complex ( 8 ), allocatable , dimension (:) :: X_ , Y_ integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do i = - n + 1 , n - 1 do ie = max ( i + 1 , 1 ), min ( n , n + i ) Z ( i + n ) = Z ( i + n ) + X ( ie ) * Y ( ie - i ) end do end do case ( 'simple' ) do i = - n + 1 , n - 1 Z ( i + n ) = sum ( X ( max ( 1 , 1 + i ): min ( n + i , n )) * Y ( max ( 1 - i , 1 ): min ( n , n - i ))) end do case ( 'fft' ) allocate ( X_ ( n * 2 - 1 )) allocate ( Y_ ( n * 2 - 1 )) X_ = czero ! pad by zero Y_ = czero X_ ( 1 : n ) = X Y_ ( 1 : n ) = Y ( n : 1 : - 1 ) call do_mkl_dfti_conv ( n * 2 - 1 , X_ , Y_ , Z ) deallocate ( X_ , Y_ ) end select end function corr1d ! Z(nop) = sum_ie X(ie) Y(ie-nop) function corr1d2 ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n ) complex ( 8 ) :: Z ( n ) complex ( 8 ), allocatable , dimension (:) :: X_ , Y_ , Z_ integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do i = - n / 2 + 1 , n / 2 - 1 do ie = max ( i + 1 , 1 ), min ( n , n + i ) Z ( i + n / 2 ) = Z ( i + n / 2 ) + X ( ie ) * Y ( ie - i ) end do end do case ( 'simple' ) do i = - n / 2 + 1 , n / 2 - 1 Z ( i + n / 2 ) = sum ( X ( max ( 1 , 1 + i ): min ( n + i , n )) * Y ( max ( 1 - i , 1 ): min ( n , n - i ))) end do case ( 'fft' ) allocate ( X_ ( n * 2 - 1 )) allocate ( Y_ ( n * 2 - 1 )) allocate ( Z_ ( n * 2 - 1 )) X_ = czero ! pad by zero Y_ = czero X_ ( 1 : n ) = X Y_ ( 1 : n ) = Y ( n : 1 : - 1 ) call do_mkl_dfti_conv ( n * 2 - 1 , X_ , Y_ , Z_ ) Z = Z_ ( n - n / 2 : n + n / 2 - 1 ) deallocate ( X_ , Y_ , Z_ ) end select end function corr1d2 ! Z(ie) = sum_nop X(ie-nop) Y(nop) function conv1d ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n * 2 - 1 ) complex ( 8 ) :: Z ( n ) complex ( 8 ), allocatable , dimension (:) :: x_in , y_in , z_in integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do ie = 1 , n do i = - n + 1 , n - 1 if (( ie . gt . max ( i , 1 )) . and . ( ie . lt . min ( n , ( n + i )))) then Z ( ie ) = Z ( ie ) + X ( ie - i ) * Y ( i + n ) end if end do end do case ( 'simple' ) do i = 1 , n Z ( i ) = sum ( X ( n : 1 : - 1 ) * Y ( i : i + n - 1 )) end do case ( 'fft' ) allocate ( X_in ( n * 2 - 1 )) allocate ( Y_in ( n * 2 - 1 )) allocate ( Z_in ( n * 2 - 1 )) X_in = czero X_in ( 1 : n ) = X Y_in = cshift ( Y , - n ) call do_mkl_dfti_conv ( n * 2 - 1 , Y_in , X_in , Z_in ) Z = Z_in ( 1 : n ) deallocate ( X_in , Y_in , Z_in ) end select end function conv1d ! Z(ie) = sum_nop X(ie-nop) Y(nop) function conv1d2 ( n , X , Y , method ) result ( Z ) integer , intent ( in ) :: n character ( len =* ), intent ( in ) :: method complex ( 8 ), intent ( in ) :: X ( n ), Y ( n ) complex ( 8 ) :: Z ( n ) complex ( 8 ), allocatable , dimension (:) :: x_in , y_in , z_in integer :: i , ie select case ( trim ( method )) case ( 'index' ) Z = czero do ie = 1 , n do i = - n / 2 + 1 , n / 2 - 1 if (( ie . gt . max ( i , 1 )) . and . ( ie . lt . min ( n , ( n + i )))) then Z ( ie ) = Z ( ie ) + X ( ie - i ) * Y ( i + n / 2 ) end if end do end do case ( 'simple' ) allocate ( Y_in ( n * 2 - 1 )) Y_in ( n - n / 2 : n + n / 2 - 1 ) = Y do i = 1 , n Z ( i ) = sum ( X ( n : 1 : - 1 ) * Y_in ( i : i + n - 1 )) end do deallocate ( Y_in ) case ( 'fft' ) allocate ( X_in ( n * 2 - 1 )) allocate ( Y_in ( n * 2 - 1 )) allocate ( Z_in ( n * 2 - 1 )) X_in = czero Y_in = czero X_in ( 1 : n ) = X Y_in ( 1 : n / 2 ) = Y ( n / 2 + 1 : n ) Y_in ( n * 2 - n / 2 : n * 2 - 1 ) = Y ( 1 : n / 2 ) call do_mkl_dfti_conv ( n * 2 - 1 , Y_in , X_in , Z_in ) Z = Z_in ( 1 : n ) deallocate ( X_in , Y_in , Z_in ) end select end function conv1d2 subroutine do_mkl_dfti_conv ( n , X_in , Y_in , Z_out ) ! 1D complex to complex Use MKL_DFTI integer :: n Complex ( 8 ) :: X_in ( n ), Y_in ( n ), Z_out ( n ) Complex ( 8 ) :: X_out ( n ), Y_out ( n ), Z_in ( n ) type ( DFTI_DESCRIPTOR ), POINTER :: My_Desc1_Handle , My_Desc2_Handle Integer :: Status ! Perform a complex to complex transform Status = DftiCreateDescriptor ( My_Desc1_Handle , DFTI_DOUBLE , DFTI_COMPLEX , 1 , n ) Status = DftiSetValue ( My_Desc1_Handle , DFTI_PLACEMENT , DFTI_NOT_INPLACE ) Status = DftiCommitDescriptor ( My_Desc1_Handle ) Status = DftiComputeForward ( My_Desc1_Handle , X_in , X_out ) Status = DftiComputeForward ( My_Desc1_Handle , Y_in , Y_out ) ! Z_in (:) = X_out (:) * Y_out (:) ! Status = DftiComputeBackward ( My_Desc1_Handle , Z_in , Z_out ) Status = DftiFreeDescriptor ( My_Desc1_Handle ) Z_out (:) = Z_out (:) / dble ( n ) end subroutine do_mkl_dfti_conv end module fft_mod","tags":"","loc":"sourcefile/fft_mod.f90.html"},{"title":"test-sgemm.f90 – Quantum transport simulator","text":"Contents Programs example_sgemm Source Code test-sgemm.f90 Source Code program example_sgemm implicit none real ( 4 ), dimension (:,:), allocatable :: A , B , C , ref real ( 8 ) :: tstart , tstop , elapsed_time real ( 8 ) :: gflops , sum , L2 integer ( 8 ) :: devPtrA , devPtrB , devPtrC integer :: n = 2048 integer :: size_of_real = 4 !4->single precision; 8->double precision integer :: i , j integer , dimension ( 8 ) :: values integer :: seed integer :: index real ( 8 ), parameter :: pi = 4.0 * atan ( 1.0 ) allocate ( A ( n , n )) allocate ( B ( n , n )) allocate ( C ( n , n )) allocate ( ref ( n , n )) call cublas_alloc ( n * n , size_of_real , devPtrA ) call cublas_alloc ( n * n , size_of_real , devPtrB ) call cublas_alloc ( n * n , size_of_real , devPtrC ) call date_and_time ( VALUES = values ) !values(8) = milisecs of the second seed = values ( 8 ) !using value in milisecs as seeder call srand ( seed ) !not a std implementation, but i like it better. !initiating matrix value do j = 1 , n do i = 1 , n A ( i , j ) = 1.0 B ( i , j ) = 2.0 end do end do !solution matrix C = 0.0 !reference matrix ref = 0.0 !  call cpu_time(tstart) !copy data to GPU call cublas_set_matrix ( n , n , size_of_real , A , n , devPtrA , n ) call cublas_set_matrix ( n , n , size_of_real , B , n , devPtrB , n ) call cublas_set_matrix ( n , n , size_of_real , C , n , devPtrC , n ) call cpu_time ( tstart ) !call SGEMM from CUBLAS call cublas_sgemm ( 'n' , 'n' , n , n , n , 1.0 , devPtrA , n , devPtrB , n , 0.0 , devPtrC , n ) !copy data from GPU call cublas_get_matrix ( n , n , size_of_real , devPtrC , n , C , n ) call cpu_time ( tstop ) elapsed_time = tstop - tstart !in seconds write ( * , * ) 'Matrix A ' , n , 'x' , n write ( * , * ) 'Matrix B ' , n , 'x' , n write ( * , 20 ) 'Elapsed time : ' , elapsed_time , 'secs' gflops = 2 * float ( n ) * float ( n ) * float ( n ) / ( elapsed_time * 1.0e9 ) write ( * , 10 ) 'Performance:' , gflops , ' GFLOPS' 10 format ( A12 , 2 X , 1 F0 . 4 , 2 X , A7 ) 20 format ( A15 , 2 X , 1 F0 . 8 , 2 X , A4 ) !reference from CPU ref = matmul ( A , B ) print * , C ( 1 , 1 ) print * , ref ( 1 , 1 ) index = n sum = 0.0 !show result do j = 1 , index do i = 1 , index sum = sum + ( ref ( i , j ) - C ( i , j ) ) * ( ref ( i , j ) - C ( i , j ) ) end do end do L2 = sqrt ( sum / ( float ( index ) * float ( index ) ) ) write ( * , 30 ) 'L2-residual :' , L2 30 format ( A15 , 2 X , 1E18 . 8 ) !Free GPU memory call cublas_free ( devPtrA ) call cublas_free ( devPtrB ) call cublas_free ( devPtrC ) end program example_sgemm","tags":"","loc":"sourcefile/test-sgemm.f90.html"},{"title":"_cuda_rgf_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~_cuda_rgf_mod.f90~~EfferentGraph sourcefile~_cuda_rgf_mod.f90 _cuda_rgf_mod.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~_cuda_rgf_mod.f90->sourcefile~linalg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules cuda_rgf_mod Source Code _cuda_rgf_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! ! AUTHOR: Jiang Cao ! module cuda_rgf_mod !! Recursive  Green's  function  solvers module implicit none private integer , parameter :: dp = 8 REAL ( dp ), PARAMETER :: BOLTZ = 8.61734d-05 !eV K-1 public :: sancho contains !!  Sancho-Rubio subroutine sancho ( nm , E , S00 , H00 , H10 , G00 , GBB ) use cublas use linalg , only : invert integer i , j , k , nm , nmax COMPLEX ( dp ) :: z real ( dp ) :: E , error REAL ( dp ) :: TOL = 1.0D-100 ! [eV] COMPLEX ( dp ), INTENT ( IN ) :: S00 ( nm , nm ), H00 ( nm , nm ), H10 ( nm , nm ) COMPLEX ( dp ), INTENT ( OUT ) :: G00 ( nm , nm ), GBB ( nm , nm ) COMPLEX ( dp ), ALLOCATABLE :: A (:, :), B (:, :), C (:, :), tmp (:, :) COMPLEX ( dp ), ALLOCATABLE :: H_BB (:, :), H_SS (:, :), H_01 (:, :), H_10 (:, :), Id (:, :) COMPLEX ( dp ), EXTERNAL :: ZLANGE complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) ! Allocate ( H_BB ( nm , nm )) Allocate ( H_SS ( nm , nm )) Allocate ( H_01 ( nm , nm )) Allocate ( H_10 ( nm , nm )) Allocate ( Id ( nm , nm )) Allocate ( A ( nm , nm )) Allocate ( B ( nm , nm )) Allocate ( C ( nm , nm )) Allocate ( tmp ( nm , nm )) nmax = 50 z = dcmplx ( E , 1.0d-5 ) Id = dcmplx ( 0.0d0 , 0.0d0 ) tmp = 0.0d0 do i = 1 , nm Id ( i , i ) = 1.0d0 tmp ( i , i ) = dcmplx ( 0.0d0 , 1.0d0 ) end do H_BB = H00 H_10 = H10 H_01 = TRANSPOSE ( CONJG ( H_10 )) H_SS = H00 do i = 1 , nmax A = z * S00 - H_BB call invert ( A , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H_10 , nm , beta , B , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_SS = H_SS + C H_BB = H_BB + C call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , C , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H_01 , nm , beta , B , nm ) call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , A , nm ) H_10 = C H_BB = H_BB + A call Zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_01 = C ! NORM --> inspect the diagonal of A error = 0.0d0 DO k = 1 , nm DO j = 1 , nm error = error + sqrt ( aimag ( C ( k , j )) ** 2 + Dble ( C ( k , j )) ** 2 ) END DO END DO !write(90,*)E,i,error tmp = H_SS IF ( abs ( error ) < TOL ) THEN !write(90,*) 'SR: Exited, abs(error)=',i,abs(error) EXIT ELSE END IF IF ( i . EQ . nmax ) THEN write ( * , * ) 'SEVERE warning: nmax reached in sancho!!!' , error END IF end do G00 = z * S00 - H_SS call invert ( G00 , nm ) ! GBB = z * S00 - H_BB call invert ( GBB , nm ) ! Deallocate ( tmp ) Deallocate ( A ) Deallocate ( B ) Deallocate ( C ) Deallocate ( H_BB ) Deallocate ( H_SS ) Deallocate ( H_01 ) Deallocate ( H_10 ) Deallocate ( Id ) end subroutine sancho end module cuda_rgf_mod","tags":"","loc":"sourcefile/_cuda_rgf_mod.f90.html"},{"title":"output_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~output_mod.f90~~EfferentGraph sourcefile~output_mod.f90 output_mod.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~output_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~output_mod.f90~~AfferentGraph sourcefile~output_mod.f90 output_mod.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~negf_mod.f90->sourcefile~output_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules Output Source Code output_mod.f90 Source Code module Output use matrix_c , only : type_matrix_complex , sizeof implicit none private integer , parameter :: dp = 8 public :: write_spectrum_summed_over_k contains ! write spectrum into file (pm3d map) subroutine write_spectrum_summed_over_k ( dataset , i , G , nen , en , nk , length , NB , NS , Lx , coeff , append ) character ( len =* ), intent ( in ) :: dataset type ( type_matrix_complex ), intent ( in ), dimension ( length , nen , nk ) :: G integer , intent ( in ) :: i , nen , length , NB , NS , nk real ( dp ), intent ( in ) :: Lx , en ( nen ), coeff ( 2 ) logical , intent ( in ), optional :: append ! ---- integer :: ix , ie , j , ib , k , ik character ( len = 4 ) :: i_str character ( len = 8 ) :: fmt real ( dp ) :: xx complex ( dp ) :: tr logical append_ append_ = . false . if ( present ( append )) append_ = append fmt = '(I4.4)' write ( i_str , fmt ) i if ( append_ ) then open ( unit = 11 , file = trim ( dataset ) // i_str // '.dat' , status = 'unknown' , position = 'append' ) else open ( unit = 11 , file = trim ( dataset ) // i_str // '.dat' , status = 'unknown' ) end if ! do ie = 1 , nen xx = 0.0d0 ix = 0 do j = 1 , length do k = 1 , NS ix = ix + 1 xx = xx + Lx tr = 0.0d0 !!!$omp parallel default(shared) private(ik, ib) reduction(+:tr) !!!$omp do do ik = 1 , nk do ib = 1 , nb tr = tr + G ( j , ie , ik )% m ( ib + ( k - 1 ) * NB , ib + ( k - 1 ) * NB ) end do end do !!!$omp end do !!!$omp end parallel tr = tr / dble ( nk ) write ( 11 , '(4E18.4)' ) xx , en ( ie ), dble ( tr ) * coeff ( 1 ), aimag ( tr ) * coeff ( 2 ) end do end do write ( 11 , * ) end do close ( 11 ) end subroutine write_spectrum_summed_over_k end module Output","tags":"","loc":"sourcefile/output_mod.f90.html"},{"title":"static.f90 – Quantum transport simulator","text":"Contents Modules static Source Code static.f90 Source Code MODULE static !! constants IMPLICIT NONE integer , parameter :: dp = 8 complex ( dp ), parameter :: cone = dcmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: czero = dcmplx ( 0.0d0 , 0.0d0 ) complex ( dp ), parameter :: c1i = dcmplx ( 0.0d0 , 1.0d0 ) real ( dp ), parameter :: hbar = 1.0546d-34 ! m&#94;2 kg / s real ( dp ), parameter :: m0 = 9.109d-31 ! kg real ( dp ), parameter :: eps0 = 8.854d-12 ! C/V/m real ( dp ), parameter :: c0 = 2.998d8 ! m/s  v light real ( dp ), parameter :: e0 = 1.6022d-19 ! C electron charge REAL ( dp ), PARAMETER :: pi = 3.14159265359d0 REAL ( dp ), PARAMETER :: twopi = 3.14159265359d0 * 2.0d0 REAL ( dp ), PARAMETER :: m0_ev = 5.6856D-16 !eV s&#94;2 / cm&#94;2   rest mass of electron real ( dp ), PARAMETER :: kg2eV = m0_ev / m0 ! eV s&#94;2 / cm&#94;2 / gram REAL ( dp ), PARAMETER :: hbar_ev = 6.58211899E-16 !eV s REAL ( dp ), PARAMETER :: BOLTZ = 8.61734d-05 !eV K-1 real ( dp ), parameter :: hb2m = 7.6305d-16 ! eV*cm&#94;2 END MODULE static","tags":"","loc":"sourcefile/static.f90.html"},{"title":"graph_partition.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~graph_partition.f90~~AfferentGraph sourcefile~graph_partition.f90 graph_partition.f90 sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~deviceham_mod.f90->sourcefile~graph_partition.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules graph_partition Source Code graph_partition.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! ! AUTHOR: Jiang Cao ! module graph_partition !! Library cuts a graph into slices which have only connections with the left !! and right neighbor slices. [[slice]] is the main subroutine to call. implicit none private public :: AddEdge , ReadGraphFromText , SaveSlicesTxt , SaveTxtGraph , testSlicing , slice public :: getPointsInAllSlices , getPointsInSlice , ReadEdgeFromText public :: convert_fromCOO integer , parameter :: dp = 8 interface slice module procedure slice_1contact , slice_2contacts end interface contains function getPointsInAllSlices ( S ) result ( v ) !! Function returns the points in all the slices implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer :: v ( sum ( S ( 1 , :)) - size ( S , 2 )) integer :: i , n n = 0 do i = 1 , size ( S , 2 ) v ( n + 1 : n + S ( 1 , i ) - 1 ) = S ( 2 : S ( 1 , i ), i ) n = n + S ( 1 , i ) - 1 end do end function getPointsInAllSlices function getPointsInSlice ( S , i ) result ( v ) !! Function returns the points in a slice number `i` implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer , intent ( in ) :: i !! Slice number integer :: v ( S ( 1 , i ) - 1 ) v (:) = S ( 2 : S ( 1 , i ), i ) end function getPointsInSlice subroutine SaveSlicesTxt ( handle , S , X , Y , Z ) !! Procedure saves the slice information into a text file implicit none integer , intent ( in ) :: handle !! file unit number integer , intent ( in ) :: S (:, :) !! Slices information real ( dp ), intent ( in ), optional :: X (:) real ( dp ), intent ( in ), optional :: Y (:) real ( dp ), intent ( in ), optional :: Z (:) integer :: i , j write ( handle , * ) '# number of points in each slice' write ( handle , '(8I10)' ) S ( 1 , :) - 1 ! number of points in each slice if ( present ( X ) . and . present ( Y ) . and . present ( Z )) then write ( handle , * ) '#     X         Y         Z       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(3E15.5,I10)' ) X ( S ( j , i )), Y ( S ( j , i )), Z ( S ( j , i )), i end do end do else write ( handle , * ) '#    Point#       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(2I10)' ) S ( j , i ), i end do end do end if end subroutine SaveSlicesTxt subroutine AddEdge ( g , ij ) !! Subroutine update the graph data (g) by adding an edge from node-i to node-j. !! The memory space for (g) is already allocated before calling this procedure implicit none integer , intent ( out ) :: g (:, :) integer , intent ( in ) :: ij ( 2 ) ! Find if this Edge is already present in the graph, avoiding duplicates if ( ANY ( g ( 2 : g ( 1 , ij ( 1 )), ij ( 1 )) == ij ( 2 ))) then return else g ( 1 , ij ( 1 )) = g ( 1 , ij ( 1 )) + 1 g ( 1 , ij ( 2 )) = g ( 1 , ij ( 2 )) + 1 g ( g ( 1 , ij ( 2 )), ij ( 2 )) = ij ( 1 ) g ( g ( 1 , ij ( 1 )), ij ( 1 )) = ij ( 2 ) end if end subroutine AddEdge subroutine ReadEdgeFromText ( fname , E , use0index ) !! Subroutine for reading the edge data from an ASCII text file. implicit none integer , allocatable , intent ( out ) :: E (:) !! Edge index character ( len =* ), intent ( in ) :: fname !! input text file name logical , intent ( in ), optional :: use0index integer :: NPT , i integer , parameter :: handle = 677 logical :: l0index l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) read ( handle , * ) NPT ! number of points allocate ( E ( NPT )) read ( handle , * ) E (:) if ( l0index ) E (:) = E (:) + 1 !do i=1,NPT !        read(handle,*) E(i) !        if (l0index) then !          E(i) = E(i)+1 !        endif !enddo close ( handle ) end subroutine ReadEdgeFromText subroutine ReadGraphFromText ( fname , g , threshold , use0index ) !! Subroutine for reading in the graph data from an ASCII text file. !! !! @note The graph connectivity table is stored in a 2D integer array `g(:,:)` which !! is allocated inside this subroutine, so remember to deallocate it outside. !! The 2nd index of `g(:,:)` refers to the point ID and 'g(1,:)-1' is the number of connections !! of the point. The text file should contain 2 columns of integers which are the point !! IDs of 2 connected points in the graph. !! implicit none integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table. character ( len =* ), intent ( in ) :: fname !! input text file name real ( 8 ), intent ( in ), optional :: threshold logical , intent ( in ), optional :: use0index integer , allocatable :: gn (:) !! Temporary array for sizing the Graph Table integer :: i , j , k !! Looping variables integer :: NL !! Number of lines in the text file integer :: IO !! IO state during reading integer :: M !! Number of points in the graph integer :: NC integer , parameter :: handle = 675 logical :: l0index real ( 8 ) :: weight l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of points in the graph do read ( handle , * , IOSTAT = IO ) i , j if ( l0index ) then i = i + 1 j = j + 1 end if if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of Points = \",i18)' , M allocate ( gn ( M )) gn = 0 ! Read again the file to know about the size of the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if else gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if end do NC = maxval ( gn ) print '(\"Max Number of Connections = \",i18)' , NC allocate ( g ( NC + 1 , M )) g (:, :) = 0 g ( 1 , :) = 1 deallocate ( gn ) ! Read last time the file for the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( i . ne . j ) then if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then call AddEdge ( g , ( / i , j / )) end if else call AddEdge ( g , ( / i , j / )) end if end if end do close ( handle ) end subroutine ReadGraphFromText subroutine SaveTxtGraph ( handle , g ) !! Subroutine for saving the graph data into an ASCII text file. !! !! @note The 1st column is the point ID, and the following columns are the connecting points' ID. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ), optional :: handle !! Unit number of the input text file character ( len = 1024 ) :: str !! String for FORMAT writing integer :: i !! Looping variable write ( str , \"(I10)\" ) size ( g , 1 ) + 1 if ( present ( handle )) then do i = 1 , size ( g , 2 ) write ( handle , '(' // trim ( adjustl ( str )) // 'i10)' ) i , g ( 2 : g ( 1 , i ), i ) end do else do i = 1 , size ( g , 2 ) print '(' // trim ( adjustl ( str )) // 'i10)' , i , g ( 2 : g ( 1 , i ), i ) end do end if end subroutine SaveTxtGraph subroutine SaveTxt2col ( handle , g ) !! Subroutine for saving the graph data into an ASCII text file with 2 columns format !! !! @note The 1st and 2nd columns are point IDs. Each connection is represented by 1 line. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ), optional :: handle !! Unit number of the input text file integer :: i , j !! Looping variable do i = 1 , size ( g , 2 ) do j = 2 , g ( 1 , i ) if ( i . le . g ( j , i )) then if ( present ( handle )) then write ( handle , '(2i10)' ) i , g ( j , i ) else write ( * , '(2i10)' ) i , g ( j , i ) end if end if end do end do end subroutine SaveTxt2col function dist ( g , E ) result ( D ) !! Function returns the distance of all the points to an edge of the graph. !! Distance means the number of steps needed to arrive at this point starting from the edge !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: E (:) !! Edge points' IDs integer :: D ( 1 : size ( g , 2 )) !! Distance table integer :: ST ( 0 : size ( g , 2 ) * 2 ) !! Circular Stack for BFS algorithm integer :: LST !! Length of the Stack integer :: SLP !! Lower Stack Pointer integer :: SHP !! Higher Stack Pointer integer :: PID !! A point ID integer :: PID2 !! A point ID integer :: i !! Looping integer D (:) = HUGE ( 1 ) D ( E (:)) = 0 SLP = 1 SHP = size ( E ) + 1 ST = 0 ST ( SLP : SHP - 1 ) = E (:) LST = size ( ST ) do while ( SHP . ne . SLP ) PID = ST ( SLP ) ! Take 1 point out from the Stack do i = 2 , g ( 1 , PID ) PID2 = g ( i , PID ) ! Look at its connections if ( D ( PID2 ) . eq . HUGE ( 1 )) then D ( PID2 ) = D ( PID ) + 1 ST ( SHP ) = PID2 ! Push the point into Stack for further moves SHP = MOD ( SHP + 1 , LST ) end if end do SLP = MOD ( SLP + 1 , LST ) end do end function dist function part ( DL , DR ) result ( P ) !! Function returns the partition of a graph depending on the distances to the edges !! obtained from [[edge]] !! implicit none integer , intent ( in ) :: DL (:) !! Distance to the left edge obtained from [[edge]] integer , intent ( in ) :: DR (:) !! Distance to the right edge obtained from [[edge]] integer :: P ( 1 : size ( DL )) !! Partition, 1 for left part, and 2 for right part P = 2 where ( DL < DR ) P = 1 end function part function PtsInParts ( P , PID ) result ( PT ) !! Function returns a list of points' IDs in a partition obtained from [[part]] !! implicit none integer , intent ( in ) :: P (:) !! Partition from [[part]] integer , intent ( in ) :: PID !! Part Number integer :: PT ( COUNT ( P == PID )) !! List of Points in the part #PID integer :: i , j j = 1 do i = 1 , size ( P ) if ( P ( i ) == PID ) then PT ( j ) = i j = j + 1 end if end do end function PtsInParts function edge ( g , P ) result ( E ) !! Function returns the edges of a partition of the graph. !! The partition is obtained from function [[part]] !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: P (:) !! Partition Information from [[part]] integer :: E ( size ( P ), maxval ( P )) !! Edge of each part integer :: i , j !! Loop integers E = 0 E ( 1 , :) = 1 do i = 1 , size ( g , 2 ) ! Loop over all the points do j = 2 , g ( 1 , i ) ! Look up its connecting points if ( P ( g ( j , i )) . ne . P ( i )) then ! They belong to different parts E ( 1 , P ( i )) = E ( 1 , P ( i )) + 1 E ( E ( 1 , P ( i )), P ( i )) = i ! Add this point into the Edge list of part-i exit end if end do end do end function edge function subgraph ( g , PT ) result ( sg ) !! Function returns the sub-graph of a graph by providing a list of points in the sub-graph !! @note The sub-graph has a different point index than the original graph, since it contains !! only the selected points. !! To find the original point index, one has to refer to array PT. For exemple, point `1` !! in the sub-graph corresponds the point `PT(1)` in original graph. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: PT (:) !! List of points in the sub-graph integer :: sg ( size ( g , 1 ) + 1 , size ( PT )) !! Sub-Graph connectivity table integer :: i , j !! Looping integers sg = 0 sg ( 1 , :) = 1 do i = 1 , size ( PT ) do j = 2 , g ( 1 , PT ( i )) if ( ANY ( PT == g ( j , PT ( i )))) then ! point PT(i) connects to a point belonging to PT sg ( 1 , i ) = sg ( 1 , i ) + 1 ! append the connection list of sub-graph sg ( sg ( 1 , i ), i ) = index ( PT , g ( j , PT ( i ))) ! Add the connected point, with new index in sub-graph end if end do end do end function subgraph pure function index ( A , y ) result ( x ) !! Function returns the index of one value y in a list A !! implicit none integer , intent ( in ) :: A (:), y integer :: x , i x = - 1 do i = 1 , size ( A ) if ( y == A ( i )) then x = i exit end if end do end function index function indexes ( A , y ) result ( x ) !! Function returns the index of an array of values y in the list A by calling [[index]] !! implicit none integer , intent ( in ) :: A (:), y (:) integer :: x ( size ( y )), i FORALL ( i = 1 : size ( y )) x ( i ) = index ( A , y ( i )) end function indexes function resize ( A ) result ( B ) !! Function returns a more compact table list by resizing the array !! implicit none integer , intent ( in ) :: A (:, :) !! Table with too many 0, to be compressed integer :: B ( maxval ( A ( 1 , :)), size ( A , 2 )) !! Output resized table B (:, :) = A ( 1 : size ( B , 1 ), :) end function resize subroutine slice_1contact ( g , E , S ) !! Procedure returns the slices of the graph going from 1 edge. BFS algorithm is used to !! assign a distance to the edge for each point, then the slice number = distance. !! !! @note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: E (:) !! Left Edge points' IDs integer , allocatable , intent ( out ) :: S (:, :) !! Output the Slices, 2nd index is the Slice number integer :: D ( size ( g , 2 )) !! Distance table of the points integer :: i , NP D = dist ( g , E ) + 1 ! Add 1 in order to have distance=1 for the edge points NP = - 1 do i = 1 , maxval ( D ) if ( COUNT ( D == i ) > NP ) NP = COUNT ( D == i ) end do if ( allocated ( S )) deallocate ( S ) allocate ( S ( NP + 1 , maxval ( D ))) S = 1 do i = 1 , size ( g , dim = 2 ) S ( 1 , D ( i )) = S ( 1 , D ( i )) + 1 S ( S ( 1 , D ( i )), D ( i )) = i end do end subroutine slice_1contact recursive subroutine slice_2contacts ( g , E1 , E2 , NMAX , S ) !! Function returns the slices of the graph. The problem is solved in a divide-and-conquer !! manner, using recursive bisection method described in [Journal of Computational Physics 228 (2009) 8548–8565]. !! !! 1. Compute the left/right distance of points to left/right edges, by calling [[dist]] !! 2. Divide the graph into 2 'balanced' parts, based on if the right distance is larger than the left distance !! 3. Find the connections between 2 parts, and define a new set of edges !! 4. Recursion, ``Slice`` seperately the 2 parts !! 5. Combine the results !! !! Stop condition: either the 2 edges touch each other, or the number of points in the remaining part gets !! small enough. !! !! @note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: E1 (:) !! Left Edge points' IDs integer , intent ( in ) :: E2 (:) !! RightEdge points' IDs integer , intent ( in ) :: NMAX !! Maximum number of points in a single slice integer , allocatable , intent ( out ) :: S (:, :) !! Output the Slices, 2nd index is the Slice number integer :: P ( 1 : size ( g , 2 )) !! Partition table integer :: E ( 1 : size ( g , 2 ), 2 ) !! Edge table integer :: NP ( 2 ) !! Number of points in parts integer , allocatable :: S1 (:, :) !! Slices in the left part integer , allocatable :: S2 (:, :) !! Slices in the right part integer , allocatable :: PT (:) !! Point list in a part integer :: i , err do i = 1 , size ( E1 ) if ( ANY ( E2 (:) == E1 ( i ))) then ! If the 2 edges contact, than we need to put the whole part into one slice allocate ( S ( size ( g , 2 ) + 1 , 1 )) S ( 1 , 1 ) = size ( g , 2 ) + 1 S ( 2 :, 1 ) = ( / ( i , i = 1 , size ( g , 2 )) / ) return end if end do ! Split the Graph into 2 parts P = part ( dist ( g , E1 ), dist ( g , E2 )) FORALL ( i = 1 : 2 ) NP ( i ) = count ( P == i ) ! Determinate the edges E = edge ( g , P ) ! Slice each part ! If a part contains less points than NMAX, than all the points in this part goes into one slice allocate ( PT ( NP ( 1 )), stat = err ) if ( err /= 0 ) print * , \"PT: Allocation request denied\" PT = PtsInParts ( P , 1 ) if (( NP ( 1 ) . gt . NMAX ) . and . ( NP ( 1 ) . gt . size ( E1 ))) then CALL slice ( subgraph ( g , PT ), indexes ( PT , E1 ), indexes ( PT , E ( 2 : E ( 1 , 1 ), 1 )), NMAX , S1 ) ! Recover the original point ID FORALL ( i = 2 : size ( S1 , 1 )) where ( S1 ( i , :) . ne . - 1 ) S1 ( i , :) = PT ( S1 ( i , :)) ! -1 to indicate no number end forall else allocate ( S1 ( NP ( 1 ) + 1 , 1 )) S1 ( 1 , 1 ) = NP ( 1 ) + 1 S1 ( 2 :, 1 ) = PT end if if ( allocated ( PT )) deallocate ( PT , stat = err ) if ( err /= 0 ) print * , \"PT: Deallocation request denied\" allocate ( PT ( NP ( 2 )), stat = err ) if ( err /= 0 ) print * , \"PT: Allocation request denied\" PT = PtsInParts ( P , 2 ) if (( NP ( 2 ) . gt . NMAX ) . and . ( NP ( 2 ) . gt . size ( E2 ))) then CALL slice ( subgraph ( g , PT ), indexes ( PT , E ( 2 : E ( 1 , 2 ), 2 )), indexes ( PT , E2 ), NMAX , S2 ) ! Recover the original point ID FORALL ( i = 2 : size ( S2 , 1 )) where ( S2 ( i , :) . ne . - 1 ) S2 ( i , :) = PT ( S2 ( i , :)) ! -1 to indicate no number end forall else allocate ( S2 ( NP ( 2 ) + 1 , 1 )) S2 ( 1 , 1 ) = NP ( 2 ) + 1 S2 ( 2 :, 1 ) = PT end if if ( allocated ( PT )) deallocate ( PT , stat = err ) if ( err /= 0 ) print * , \"PT: Deallocation request denied\" ! Merge the results of 2 parts if ( allocated ( S )) deallocate ( S ) allocate ( S ( max ( size ( S1 , 1 ), size ( S2 , 1 )), size ( S1 , 2 ) + size ( S2 , 2 ))) S = - 1 ! -1 to indicate no number S ( 1 : size ( S1 , 1 ), 1 : size ( S1 , 2 )) = S1 S ( 1 : size ( S2 , 1 ), 1 + size ( S1 , 2 ):) = S2 if ( allocated ( S1 )) deallocate ( S1 , stat = err ) if ( err /= 0 ) print * , \"S1: Deallocation request denied\" if ( allocated ( S2 )) deallocate ( S2 , stat = err ) if ( err /= 0 ) print * , \"S2: Deallocation request denied\" end subroutine slice_2contacts function testSlicing ( g , S ) result ( b ) !! Function tests if a slicing from subroutine [[slice]]  of the graph is consistent by !! looking at the neighbors of all the points in each slice. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer :: b !! Test result integer , intent ( in ) :: S (:, :) !! Slices, 2nd index is the Slice number integer :: L ( size ( g , 2 )) !! Slice number of points integer :: i , k , j , err L = - 1 L = SliceNum ( S ) IF ( ANY ( L == - 1 )) then b = - 1 ! Not all points belong to a slice return end if do i = 1 , size ( S , 2 ) ! Loop over the slices do j = 2 , S ( 1 , i ) ! Loop over the points in one slice do k = 2 , g ( 1 , S ( j , i )) ! Loop over all its neighbor points if ( abs ( L ( g ( k , S ( j , i ))) - i ) > 1 ) then b = i ! It connects to a points too far print '(4I18)' , L ( g ( k , S ( j , i ))), g ( k , S ( j , i )), i , S ( j , i ) return end if end do end do end do b = 0 end Function testSlicing function SliceNum ( S ) result ( N ) !! Function returns an array of indexes of slice to which the points belong !! implicit none integer , intent ( in ) :: S (:, :) !! Slices, 2nd index is the Slice number integer :: N ( 1 : maxval ( S ( 2 :, :))) !! Slice number of points integer :: i , j do i = 1 , size ( S , 2 ) ! Loop over the slices do j = 2 , S ( 1 , i ) ! Loop over the points in one slice N ( S ( j , i )) = i end do end do end Function SliceNum subroutine convert_fromCOO ( nnz , row , col , g ) !! Subroutine convert a sparse matrix in COO format into a graph !!   The graph will be allocated inside the subroutine, so remember to deallocate the memory outside implicit none integer , intent ( in ) :: nnz integer , intent ( in ), dimension ( nnz ) :: row , col !! IA and JA index vectors of a CSR matrix integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table end subroutine convert_fromCOO end module graph_partition","tags":"","loc":"sourcefile/graph_partition.f90.html"},{"title":"rgf_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~rgf_mod.f90~~EfferentGraph sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~rgf_mod.f90->sourcefile~linalg.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~rgf_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules rgf_mod Source Code rgf_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! ! AUTHOR: Jiang Cao ! module rgf_mod !! Recursive  Green's  function  solvers module use omp_lib implicit none private integer , parameter :: dp = 8 REAL ( dp ), PARAMETER :: BOLTZ = 8.61734d-05 !eV K-1 public :: rgf_variableblock_backward public :: rgf_variableblock_forward contains !!  Recursive Forward Green's solver subroutine rgf_variableblock_forward ( nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) use matrix_c , only : type_matrix_complex , MUL_C , triMUL_C , trace use linalg , only : invert type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ), Gl ( nx ), Gln ( nx ) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: M , ii , jj complex ( dp ) :: z real ( dp ) :: tim , start , finish , start_0 complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) ! z = dcmplx ( En , 0.0d0 ) ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmal ( M , M )) allocate ( sig ( M , M )) ! start = omp_get_wtime () start_0 = start ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B H10 = H1i ( ii )% m call sancho ( M , En , Sii ( ii )% m , H00 , transpose ( conjg ( H10 )), G00 , GBB ) !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical ! !! \\Sigma&#94;R = H(i,i+1) * G00 * H(i+1,i) !! Gl(i) = [E*S(i,i) - H00 - \\Sigma_R]&#94;{-1} call triMUL_c ( H10 , G00 , H10 , sigmal , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmal call invert ( B , M ) Gl ( ii )% m = B ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + (-(\\Sigma&#94;R - \\Sigma_R&#94;\\dagger)*ferm(..))] * Gl(i)&#94;\\dagger call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig , H10 ) ! finish = omp_get_wtime () print * , \"--- left contact took seconds\" , finish - start start = finish ! allocate ( A ( M , M )) ! inside device l -> r do ii = 2 , nx - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) !! Gl(i) = [E*S(i,i) - H00 - H(i,i-1) * Gl(i-1) * H(i-1,i)]&#94;{-1} call triMUL_c ( H1i ( ii )% m , Gl ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B call invert ( A , M ) Gl ( ii )% m = A ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)&#94;\\dagger call triMUL_c ( H1i ( ii )% m , Gln ( ii - 1 )% m , H1i ( ii )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! finish = omp_get_wtime () print * , \"--- first pass took seconds\" , finish - start start = finish ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmar ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = H1i ( nx + 1 )% m ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H10 , G00 , H10 , sigmar , 'c' , 'n' , 'n' ) ! !!!$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(Gbb)) !!        close (10) !!!$omp end critical ! call triMUL_c ( H1i ( nx )% m , Gl ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B - sigmar ! call invert ( A , M ) G_r ( ii )% m = A Gl ( ii )% m = A ! !! \\Sigma&#94;< = \\Sigma_11&#94;< + \\Sigma_{ph}&#94;< + \\Sigma_s&#94;< call triMUL_c ( H1i ( nx )% m , Gln ( nx - 1 )% m , H1i ( nx )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( nx )% m , Sii ( nx )% m , 'n' , 'n' , A ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !! G&#94;< = G * \\Sigma&#94;< * G&#94;\\dagger call triMUL_c ( G_r ( ii )% m , sig , G_r ( ii )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( ii )% m = B G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) ! A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) ! Jdens ( ii )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( ii )% m ( jj , jj )) end do tr = tim ! transmission deallocate ( sigmar , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! finish = omp_get_wtime () print * , \"--- right contact took seconds\" , finish - start start = finish ! ! inside device r -> l do ii = nx - 1 , 1 , - 1 M = size ( Hii ( ii )% m , 1 ) !! A = G&#94;<(i+1) * H(i+1,i) * Gl(i)&#94;\\dagger + G(i+1) * H(i+1,i) * Gln(i) call triMUL_c ( G_lesser ( ii + 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii + 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !! B = H(i,i+1) * A !! Jdens(i) = -2 * B call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * B (:, :) ! !! GN0 = Gl(i) * H(i,i+1) * G(i+1) !! G(i) = Gl(i) + GN0 * H(i+1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii + 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !! G&#94;<(i) = Gln(i) + Gl(i) * H(i,i+1) * G&#94;<(i+1) * H(i+1,i) *Gl(i)&#94;\\dagger call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii + 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + GN0 * H(i+1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + Gln(i) * H(i,i+1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;>(i) = G&#94;<(i) + [G(i) - G(i)&#94;\\dagger] G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ! finish = omp_get_wtime () print * , \"--- second pass took seconds\" , finish - start start = finish ! ii = 1 ! on the left contact A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tre = tim deallocate ( B , A , C , GN0 , sigmal ) ! end subroutine rgf_variableblock_forward !!  Recursive Backward Green's solver subroutine rgf_variableblock_backward ( nx , En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) use matrix_c , only : type_matrix_complex , MUL_C , triMUL_C , trace use linalg , only : invert type ( type_matrix_complex ), intent ( in ) :: Hii ( nx ), H1i ( nx + 1 ), Sii ( nx ), sigma_lesser_ph ( nx ), sigma_r_ph ( nx ) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) integer , intent ( in ) :: nx !! lenght of the device type ( type_matrix_complex ), intent ( inout ) :: G_greater ( nx ), G_lesser ( nx ), G_r ( nx ), Jdens ( nx ), Gl ( nx ), Gln ( nx ) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: M , ii , jj complex ( dp ) :: z real ( dp ) :: tim complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) z = dcmplx ( En , 0.0d0 ) ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmar ( M , M )) allocate ( sig ( M , M )) ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B call sancho ( M , En , Sii ( ii )% m , H00 , H1i ( ii + 1 )% m , G00 , GBB ) !!        !$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 2, -aimag(trace(Gbb)) !!        close (10) !!        !$omp end critical ! !! \\Sigma&#94;R = H(i,i+1) * G00 * H(i+1,i) !! Gl(i) = [E*S(i,i) - H00 - \\Sigma_R]&#94;{-1} call triMUL_c ( H1i ( ii + 1 )% m , G00 , H1i ( ii + 1 )% m , sigmar , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmar call invert ( B , M ) Gl ( ii )% m = B ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + (-(\\Sigma&#94;R - \\Sigma_R&#94;\\dagger)*ferm(..))] * Gl(i)&#94;\\dagger call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig ) ! allocate ( A ( M , M )) ! inside device r -> l do ii = nx - 1 , 2 , - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !! H00 = H(i,i) + \\Sigma_{ph}(i) * S(i,i) !! Gl(i) = [E*S(i,i) - H00 - H(i,i+1) * Gl(i+1) * H(i+1,i)]&#94;{-1} call triMUL_c ( H1i ( ii + 1 )% m , Gl ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B call invert ( A , M ) Gl ( ii )% m = A ! !! Gln(i) = Gl(i) * [\\Sigma_{ph}&#94;<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)&#94;\\dagger call triMUL_c ( H1i ( ii + 1 )% m , Gln ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmal ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = transpose ( conjg ( H1i ( 1 )% m )) ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H1i ( 1 )% m , G00 , H1i ( 1 )% m , sigmal , 'c' , 'n' , 'n' ) ! !!        !$omp critical !!        open (unit=10, file='sancho_g00.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(G00)) !!        close (10) !!        open (unit=10, file='sancho_gbb.dat', position='append') !!        write (10, *) En, 1, -aimag(trace(Gbb)) !!        close (10) !!        !$omp end critical ! call triMUL_c ( H1i ( 2 )% m , Gl ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( 1 )% m - H00 - B - sigmal ! call invert ( A , M ) G_r ( 1 )% m = A Gl ( 1 )% m = G_r ( 1 )% m ! !! \\Sigma&#94;< = \\Sigma_11&#94;< + \\Sigma_{ph}&#94;< + \\Sigma_s&#94;< call triMUL_c ( H1i ( 2 )% m , Gln ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( 1 )% m , Sii ( 1 )% m , 'n' , 'n' , A ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !! G&#94;< = G * \\Sigma&#94;< * G&#94;\\dagger call triMUL_c ( G_r ( 1 )% m , sig , G_r ( 1 )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( 1 )% m = B G_greater ( 1 )% m = G_lesser ( 1 )% m + ( G_r ( 1 )% m - transpose ( conjg ( G_r ( 1 )% m ))) ! A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( 1 )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( 1 )% m , 'n' , 'n' , C ) ! Jdens ( 1 )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( 1 )% m ( jj , jj )) end do tre = tim deallocate ( sigmal , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! inside device l -> r do ii = 2 , nx M = size ( Hii ( ii )% m , 1 ) !! A = G&#94;<(i-1) * H(i-1,i) * Gl(i)&#94;\\dagger + G(i-1) * H(i-1,i) * Gln(i) call triMUL_c ( G_lesser ( ii - 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii - 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !! B = H(i,i-1) * A !! Jdens(i) = -2 * re(B) call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * B (:, :) ! !! GN0 = Gl(i) * H(i,i-1) * G(i-1) !! G(i) = Gl(i) + GN0 * H(i-1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii - 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !! G&#94;<(i) = Gln(i) + Gl(i) * H(i,i-1) * G&#94;<(i-1) * H(i-1,i) *Gl(i)&#94;\\dagger call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii - 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + GN0 * H(i-1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;<(i) = G&#94;<(i) + Gln(i) * H(i,i-1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !! G&#94;>(i) = G&#94;<(i) + [G(i) - G(i)&#94;\\dagger] G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ii = nx ! on the right contact A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tr = tim deallocate ( B , A , C , GN0 , sigmar ) ! end subroutine rgf_variableblock_backward !!  Fermi distribution function elemental Function ferm ( a ) Real ( dp ), intent ( in ) :: a real ( dp ) :: ferm ferm = 1.0d0 / ( 1.0d0 + Exp ( a )) End Function ferm !!  Sancho-Rubio subroutine sancho ( nm , E , S00 , H00 , H10 , G00 , GBB ) use linalg , only : invert integer i , j , k , nm , nmax COMPLEX ( dp ) :: z real ( dp ) :: E , error REAL ( dp ) :: TOL = 1.0D-100 ! [eV] COMPLEX ( dp ), INTENT ( IN ) :: S00 ( nm , nm ), H00 ( nm , nm ), H10 ( nm , nm ) COMPLEX ( dp ), INTENT ( OUT ) :: G00 ( nm , nm ), GBB ( nm , nm ) COMPLEX ( dp ), ALLOCATABLE :: A (:, :), B (:, :), C (:, :), tmp (:, :) COMPLEX ( dp ), ALLOCATABLE :: H_BB (:, :), H_SS (:, :), H_01 (:, :), H_10 (:, :), Id (:, :) COMPLEX ( dp ), EXTERNAL :: ZLANGE complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) character * 1 :: transa , transb ! Allocate ( H_BB ( nm , nm )) Allocate ( H_SS ( nm , nm )) Allocate ( H_01 ( nm , nm )) Allocate ( H_10 ( nm , nm )) Allocate ( Id ( nm , nm )) Allocate ( A ( nm , nm )) Allocate ( B ( nm , nm )) Allocate ( C ( nm , nm )) Allocate ( tmp ( nm , nm )) nmax = 50 z = dcmplx ( E , 1.0d-5 ) Id = dcmplx ( 0.0d0 , 0.0d0 ) tmp = 0.0d0 do i = 1 , nm Id ( i , i ) = 1.0d0 tmp ( i , i ) = dcmplx ( 0.0d0 , 1.0d0 ) end do H_BB = H00 H_10 = H10 H_01 = TRANSPOSE ( CONJG ( H_10 )) H_SS = H00 transa = 'n' transb = 'n' do i = 1 , nmax A = z * S00 - H_BB call invert ( A , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , A , nm , H_10 , nm , beta , B , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_SS = H_SS + C H_BB = H_BB + C call Zgemm ( transa , transb , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , C , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , A , nm , H_01 , nm , beta , B , nm ) call Zgemm ( transa , transb , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , A , nm ) H_10 = C H_BB = H_BB + A call Zgemm ( transa , transb , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_01 = C ! NORM --> inspect the diagonal of A error = 0.0d0 DO k = 1 , nm DO j = 1 , nm error = error + sqrt ( aimag ( C ( k , j )) ** 2 + Dble ( C ( k , j )) ** 2 ) END DO END DO !write(90,*)E,i,error tmp = H_SS IF ( abs ( error ) < TOL ) THEN !write(90,*) 'SR: Exited, abs(error)=',i,abs(error) EXIT ELSE END IF IF ( i . EQ . nmax ) THEN write ( * , * ) 'SEVERE warning: nmax reached in sancho!!!' , error END IF end do G00 = z * S00 - H_SS call invert ( G00 , nm ) ! GBB = z * S00 - H_BB call invert ( GBB , nm ) ! Deallocate ( tmp ) Deallocate ( A ) Deallocate ( B ) Deallocate ( C ) Deallocate ( H_BB ) Deallocate ( H_SS ) Deallocate ( H_01 ) Deallocate ( H_10 ) Deallocate ( Id ) end subroutine sancho end module rgf_mod","tags":"","loc":"sourcefile/rgf_mod.f90.html"},{"title":"main.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~main.f90->sourcefile~matrix_c.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 sourcefile~deviceham_mod.f90->sourcefile~matrix_c.f90 sourcefile~graph_partition.f90 graph_partition.f90 sourcefile~deviceham_mod.f90->sourcefile~graph_partition.f90 sourcefile~wannierham3d.f90 wannierHam3d.f90 sourcefile~deviceham_mod.f90->sourcefile~wannierham3d.f90 sourcefile~negf_mod.f90->sourcefile~matrix_c.f90 sourcefile~cuda_rgf_mod.f90 cuda_rgf_mod.f90 sourcefile~negf_mod.f90->sourcefile~cuda_rgf_mod.f90 sourcefile~output_mod.f90 output_mod.f90 sourcefile~negf_mod.f90->sourcefile~output_mod.f90 sourcefile~output_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Programs main Source Code main.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! PROGRAM main use omp_lib use negf_mod , only : negf_solve use matrix_c , only : type_matrix_complex , free use deviceHam_mod , only : devH_build_fromWannierFile , devH_build_fromCOOfile implicit none type ( type_matrix_complex ), allocatable , dimension (:, :) :: Hii , H1i , Sii integer :: nx , ns , nen , nk , nb real ( 8 ), dimension ( 2 ) :: temp , mu real ( 8 ) :: emin , emax real ( 8 ) :: k ( 2 , 1 ), Lx character ( len = 10 ) :: file_path character ( len = 10 ) :: calc_type integer :: rc , fu integer :: nomp ! openmp process number real ( 8 ) :: start , finish namelist / input / nx , ns , temp , mu , nk , nomp , nen , emin , emax , nb , calc_type ! MPI variables integer ( kind = 4 ) ierr integer ( kind = 4 ) comm_size integer ( kind = 4 ) comm_rank integer ( kind = 4 ) local_NE integer ( kind = 4 ) first_local_energy !    include \"mpif.h\" !    call MPI_Init(ierr) !    call MPI_Comm_size(MPI_COMM_WORLD, comm_size, ierr) !    call MPI_Comm_rank(MPI_COMM_WORLD, comm_rank, ierr) !    call MPI_Barrier(MPI_COMM_WORLD, ierr) comm_size = 1 comm_rank = 0 if ( comm_rank == 0 ) then print * , 'Comm Size =' , comm_size else print * , 'Comm Rank =' , comm_rank end if ! default values nx = 5 ns = 3 nb = 10 temp = 30 0.0d0 mu = 0.0d0 nk = 1 nen = 100 emin = - 1 0.0d0 emax = 5.0d0 k = 0.0d0 nomp = 4 calc_type = 'w90' print * , 'read input' ! Check whether file exists. file_path = 'input' inquire ( file = file_path , iostat = rc ) if ( rc /= 0 ) then write ( * , '(\"Warn: input file \", a, \" does not exist\")' ) file_path else ! Open and read Namelist file. open ( action = 'read' , file = file_path , iostat = rc , newunit = fu ) read ( nml = input , iostat = rc , unit = fu ) close ( fu ) end if call omp_set_num_threads ( nomp ) local_NE = nen / comm_size first_local_energy = local_NE * comm_rank + 1 if ( comm_rank == 0 ) then print * , \"read ham\" endif if ( calc_type == 'w90' ) then call devH_build_fromWannierFile ( 'ham_dat' , Hii , H1i , Sii , nx , ns , nb , nk , & k , Lx ) else call devH_build_fromCOOfile ( 'h_dat' , Hii , H1i , Sii , ( / 0 , 0 / ), ( / nb , nb / ), nx , & use0index = . true ., iscomplex = . false ., threshold = 1 d - 10 , blocksize = nb ) endif if ( comm_rank == 0 ) then print * , \"start NEGF solver ... \" endif start = omp_get_wtime () call negf_solve ( nx , nen , nk , emin , emax , Hii , H1i , Sii , temp , mu , & comm_size , comm_rank , local_NE , first_local_energy , NB , & NS , Lx ) finish = omp_get_wtime () if ( comm_rank == 0 ) then print * , \"Total Work took seconds\" , finish - start endif call free ( Hii ) call free ( H1i ) call free ( Sii ) !deallocate (Hii, H1i, Sii) ! call MPI_FINALIZE( ierr ) END PROGRAM main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"matrix_c.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~matrix_c.f90~~AfferentGraph sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~deviceham_mod.f90->sourcefile~matrix_c.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matrix_c.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 sourcefile~negf_mod.f90->sourcefile~matrix_c.f90 sourcefile~output_mod.f90 output_mod.f90 sourcefile~negf_mod.f90->sourcefile~output_mod.f90 sourcefile~output_mod.f90->sourcefile~matrix_c.f90 sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~rgf_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules matrix_c Source Code matrix_c.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. module matrix_c !! Complex Matrix Library !! A 2D complex array, element to form a list/table of complex matrices use cublas implicit none type type_matrix_complex complex ( 8 ), allocatable :: m (:, :) !! complex matrix integer :: size ( 2 ) !! matrix size end type type_matrix_complex interface operator (. m .) module procedure array_times_array_simple end interface interface operator ( ** ) module procedure array_power , & array_transpose end interface interface operator (. md .) module procedure array_times_array_dagger end interface interface operator (. dm .) module procedure array_dagger_times_array end interface interface sizeof module procedure array_size , matrix_size , matrix_list_size , matrix_size_dim , matrix_list_size2 end interface sizeof interface ReadTxt module procedure matrix_read end interface ReadTxt interface SaveTxt module procedure matrix_list_print , array_print end interface SaveTxt interface show module procedure array_print_on_screen end interface show interface malloc module procedure matrix_list_allocElem2 , matrix_list_allocElem module procedure matrix_alloc , matrix_alloc2 , array_alloc , array_alloc2 end interface interface free module procedure matrix_free end interface interface eye module procedure array_eye end interface interface diag module procedure array_to_diag end interface interface trace module procedure array_trace , matrix_trace end interface contains !  =====  Allocation/Deallocation  ===== ! allocate a matrix pure subroutine matrix_alloc ( M , n , nn , source ) implicit none type ( type_matrix_complex ), intent ( out ) :: M integer , intent ( in ) :: n integer , intent ( in ), optional :: nn complex ( 8 ), intent ( in ), optional :: source (:, :) if ( present ( nn )) then call matrix_alloc2 ( M , ( / n , nn / ), source = source ) else call matrix_alloc2 ( M , ( / n , n / ), source = source ) end if end subroutine matrix_alloc ! allocate a matrix pure subroutine matrix_alloc2 ( M , n , source ) implicit none type ( type_matrix_complex ), intent ( inout ) :: M integer , intent ( in ) :: n ( 2 ) complex ( 8 ), intent ( in ), optional :: source ( 1 : n ( 1 ), 1 : n ( 2 )) if (. not . allocated ( M % m )) then allocate ( M % m ( n ( 1 ), n ( 2 ))) else if (( M % size ( 1 ) == n ( 1 )) . and . ( M % size ( 2 ) == n ( 2 ))) then else deallocate ( M % m ) allocate ( M % m ( n ( 1 ), n ( 2 ))) end if end if if ( present ( source )) then M % m (:, :) = source (:, :) else M % m (:, :) = dcmplx ( 0.0d0 , 0.0d0 ) end if M % size = n end subroutine matrix_alloc2 ! allocate an array pure subroutine array_alloc ( M , n , nn ) implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n integer , intent ( in ), optional :: nn if ( present ( nn )) then call array_alloc2 ( M , ( / n , nn / )) else call array_alloc2 ( M , ( / n , n / )) end if end subroutine array_alloc pure subroutine array_alloc2 ( M , n ) !! This function allocates a 2D complex array. If the array is already allocated, this function !! will resize the array to the new size. The allocated array is initiated to zero. implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n ( 2 ) if (. not . allocated ( M )) then allocate ( M ( n ( 1 ), n ( 2 ))) else if (( size ( M , 1 ) == n ( 1 )) . and . ( size ( M , 2 ) == n ( 2 ))) then else deallocate ( M ) allocate ( M ( n ( 1 ), n ( 2 ))) end if end if M = dcmplx ( 0.0d0 , 0.0d0 ) end subroutine array_alloc2 pure function array_eye ( n ) result ( R ) implicit none integer , intent ( in ) :: n complex ( 8 ) :: R ( n , n ) INTEGER :: ii R = dcmplx ( 0.0d0 , 0.0d0 ) forall ( ii = 1 : n ) R ( ii , ii ) = dcmplx ( 1.0d0 , 0.0d0 ) end function array_eye pure subroutine matrix_list_allocElem ( this , nx , nm , nn , source ) implicit none integer , intent ( in ) :: nx integer , intent ( in ) :: nm ( 1 : nx ) integer , intent ( in ), optional :: nn ( 1 : nx ) type ( type_matrix_complex ), intent ( out ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx if ( present ( nn )) then if ( present ( source )) then call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nn ( ii ) / ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nn ( ii ) / )) endif else if ( present ( source )) then call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nm ( ii ) / ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nm ( ii ) / )) endif end if end do end subroutine matrix_list_allocElem pure subroutine matrix_list_allocElem2 ( this , nx , n , source ) implicit none integer , intent ( in ) :: nx , n ( 2 , 1 : nx ) type ( type_matrix_complex ), intent ( inout ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx if ( present ( source )) then call matrix_alloc2 ( this ( ii ), n ( 1 : 2 , ii ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), n ( 1 : 2 , ii )) endif end do end subroutine matrix_list_allocElem2 elemental subroutine matrix_free ( this ) implicit none type ( type_matrix_complex ), intent ( out ) :: this if ( allocated ( this % m )) deallocate ( this % m ) end subroutine matrix_free !  =====  size, print  ===== pure function matrix_list_size ( list , dim ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) integer , intent ( in ) :: dim INTEGER :: nm ( size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm ( ii ) = list ( ii )% size ( dim ) end function matrix_list_size pure function matrix_list_size2 ( list ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) INTEGER :: nm ( 2 , size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm (:, ii ) = list ( ii )% size (:) end function matrix_list_size2 pure function array_size ( this ) result ( s ) implicit none complex ( 8 ), intent ( in ) :: this (:, :) integer :: s ( 2 ), ii FORALL ( ii = 1 : 2 ) s ( ii ) = size ( this , dim = ii ) end function array_size pure function matrix_size ( this ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer :: s ( 2 ) s (:) = this % size end function matrix_size pure function matrix_size_dim ( this , dim ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: s s = this % size ( dim ) end function matrix_size_dim subroutine matrix_list_print ( handle , this ) implicit none type ( type_matrix_complex ), intent ( in ) :: this (:) integer , intent ( in ), optional :: handle integer :: ii , xx , yy if ( present ( handle )) then write ( handle , '(1(i8))' ) size ( this ) do ii = 1 , size ( this ) write ( handle , '(2(i8))' ) this ( ii )% size (:) end do write ( handle , '(es15.4,es15.4)' ) ((( this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) else print '(3(i8),es15.4,es15.4)' , ((( ii , xx , yy , this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) end if end subroutine matrix_list_print subroutine array_print ( handle , A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: handle integer :: xx , yy write ( handle , '(2(i8))' ) size ( A , 1 ), size ( A , 2 ) write ( handle , '(es15.4,es15.4)' ) (( A ( xx , yy ), xx = 1 , size ( A , 1 )), yy = 1 , size ( A , 2 )) write ( handle , '(A)' ) \"END\" end subroutine array_print subroutine matrix_read ( handle , A ) implicit none type ( type_matrix_complex ), intent ( out ) :: A integer , intent ( in ) :: handle integer :: xx , yy real ( 8 ) :: re , im character ( len = 100 ) :: s read ( handle , * ) xx , yy call matrix_alloc ( A , xx , yy ) read ( handle , '(100A)' ) s do while ( trim ( s ) /= \"END\" ) read ( s , * ) re , im A % m ( xx , yy ) = dcmplx ( re , im ) read ( handle , '(100A)' ) s end do end subroutine matrix_read subroutine array_print_on_screen ( A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: xx , yy do xx = 1 , size ( A , 1 ) print '(10(A,es8.1,\",\",es8.1,\")\"))' , ( \"(\" , A ( xx , yy ), yy = 1 , size ( A , 2 )) end do end subroutine array_print_on_screen pure function array_testHermitian ( M ) result ( b ) implicit none complex ( 8 ), intent ( in ) :: M (:, :) logical :: b integer :: i , j real ( 8 ), parameter :: TOL = 1.0D-10 b = . true . do i = 1 , size ( M , 2 ) do j = 1 , i if ( abs ( M ( i , j ) - conjg ( M ( j , i ))) . gt . TOL ) then b = . false . return end if end do end do end function array_testHermitian !  =====  Multiplications and others  ===== pure function array_times_array_dagger ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 1 )) C = array_times_array ( A , B , trA = . false ., trB = . true ., cjA = . false ., cjB = . true .) end function array_times_array_dagger pure function array_dagger_times_array ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 2 ), size ( B , 2 )) C = array_times_array ( A , B , trA = . true ., trB = . false ., cjA = . true ., cjB = . false .) end function array_dagger_times_array pure function array_times_array ( A , B , trA , trB , cjA , cjB ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) LOGICAL ( KIND = 4 ), intent ( in ) :: trA , trB complex ( 8 ) :: C ( size ( A , merge ( 2 , 1 , trA )), size ( B , merge ( 1 , 2 , trB ))) LOGICAL ( KIND = 4 ), intent ( in ), optional :: cjA , cjB integer :: lda , ldb , k , m , kb , n character :: ctrA , ctrB interface pure subroutine ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) COMPLEX ( 8 ), intent ( in ) :: ALPHA , BETA INTEGER , intent ( in ) :: K , LDA , LDB , LDC , M , N CHARACTER , intent ( in ) :: TRANSA , TRANSB COMPLEX ( 8 ), intent ( in ) :: A ( lda , * ), B ( ldb , * ) COMPLEX ( 8 ), intent ( inout ) :: C ( ldc , * ) end subroutine ZGEMM end interface lda = size ( A , 1 ) ldb = size ( B , 1 ) if (. not . trA ) then k = size ( A , 2 ) m = size ( A , 1 ) ctrA = 'n' else k = size ( A , 1 ) m = size ( A , 2 ) if ( present ( cjA ) . and . cjA ) then ctrA = 'c' else ctrA = 't' end if end if if (. not . trB ) then kb = size ( B , 1 ) n = size ( B , 2 ) ctrB = 'n' else kb = size ( B , 2 ) n = size ( B , 1 ) if ( present ( cjB ) . and . cjB ) then ctrB = 'c' else ctrB = 't' end if end if call zgemm ( ctrA , ctrB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), C , m ) end function array_times_array pure function array_times_array_simple ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 2 )) C = array_times_array ( A , B , . false ., . false .) end function array_times_array_simple function array_power ( A , n ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: n complex ( 8 ) :: B ( size ( A , 1 ), size ( A , 1 )) complex ( 8 ) :: C ( size ( A , 1 ), size ( A , 1 )) integer :: ii if ( n > 0 ) then B = A do ii = 2 , n B = B . m . A end do C = B elseif ( n == 0 ) then C = array_eye ( size ( A , dim = 1 )) elseif ( n == - 1 ) then C = array_inverse ( A ) else C = array_inverse ( A ) B = C do ii = 2 , - n B = B . m . C end do C = B end if end function array_power pure function array_transpose ( A , t ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) character , intent ( in ) :: t complex ( 8 ) :: C ( size ( A , 2 ), size ( A , 1 )) if (( t == 't' ) . or . ( t == 'T' )) then C = Transpose ( A ) elseif (( t == 'c' ) . or . ( t == 'C' )) then C = Transpose ( Conjg ( A )) end if end function array_transpose function array_eigen ( A , B , eigvec , itype , uplo ) result ( eig ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ), intent ( in ), optional :: B (:, :) real ( 8 ) :: eig ( size ( A , 1 )) complex ( 8 ), intent ( inout ), optional :: eigvec ( size ( A , 1 ), size ( A , 2 )) integer , intent ( in ), optional :: itype CHARACTER , intent ( in ), optional :: uplo integer :: LDA , N , LDB , lwork , INFO , itypeop CHARACTER :: jobz , uploop real ( 8 ) :: RWORK ( 3 * size ( A , 2 )) complex ( 8 ) :: work ( 1 + 4 * size ( A , 2 ) + size ( A , 2 ) ** 2 ), C ( size ( A , 1 ), size ( A , 2 )) C (:, :) = A (:, :) if ( present ( eigvec )) then jobz = 'V' else jobz = 'N' end if uploop = merge ( uplo , 'U' , present ( uplo )) itypeop = merge ( itype , 1 , present ( itype )) N = size ( A , dim = 2 ) LDA = size ( A , dim = 1 ) LWORK = size ( WORK ) if ( present ( B )) then LDB = size ( B , dim = 1 ) call zhegv ( itypeop , jobz , uploop , N , C , LDA , B , LDB , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEGV fails with INFO=' , INFO call abort () end if else LDB = LDA call zheev ( jobz , uploop , N , C , LDA , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEEV fails with INFO=' , INFO call abort () end if end if if ( present ( eigvec )) eigvec = C end function array_eigen pure function array_to_diag ( A ) result ( diag ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: diag ( size ( A , 1 )) integer :: ii do concurrent ( ii = 1 : size ( A , 1 )) diag ( ii ) = A ( ii , ii ) end do end function array_to_diag function array_inverse2 ( A , UPLO ) ! for Hermitian matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: array_inverse2 ( size ( A , dim = 1 ), size ( A , dim = 1 )) CHARACTER , intent ( in ) :: UPLO integer :: info , lda , lwork , n , nnz integer :: ipiv ( size ( A , 1 )) complex ( 8 ), allocatable :: work (:, :) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse2 (:, :) = A (:, :) allocate ( work ( n * n , n * n )) LDA = size ( A , 2 ) call zhetrf ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , size ( WORK ), info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRF fails with INFO=' , info call abort () end if call zhetri ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRI fails with INFO=' , info call abort () end if end function array_inverse2 function array_inverse ( A ) ! for General matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: info , n integer :: ipiv ( size ( A , 1 )) complex ( 8 ), dimension ( size ( A , dim = 1 ), size ( A , dim = 1 )) :: array_inverse complex ( 8 ), allocatable :: work (:) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse (:, :) = A (:, :) allocate ( work ( n * n )) call zgetrf ( n , n , array_inverse , n , ipiv , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRF fails with INFO=' , info call abort () end if call zgetri ( n , array_inverse , n , ipiv , work , n * n , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRI fails with INFO=' , info call abort () end if end function array_inverse !$omp declare target device_type(any) pure function array_trace ( A ) result ( tr ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: tr integer :: ii tr = sum (( / ( A ( ii , ii ), ii = 1 , size ( A , 1 )) / )) end function array_trace elemental function matrix_trace ( M ) result ( tr ) implicit none type ( type_matrix_complex ), intent ( in ) :: M complex ( 8 ) :: tr integer :: ii tr = sum (( / ( M % m ( ii , ii ), ii = 1 , M % size ( 1 )) / )) end function matrix_trace subroutine matrix_copy ( matrices , tab ) implicit none type ( type_matrix_complex ), intent ( in ) :: matrices (:) complex ( 8 ), intent ( out ) :: tab (:, :, :) integer :: i do concurrent ( i = 1 : size ( matrices )) tab ( 1 : matrices ( i )% size ( 1 ), 1 : matrices ( i )% size ( 2 ), i ) = matrices ( i )% m (:, :) end do end subroutine matrix_copy subroutine triMUL_C ( A , B , C , R , trA , trB , trC ) complex ( 8 ), intent ( in ), dimension (:, :) :: A , B , C complex ( 8 ), intent ( inout ), allocatable :: R (:, :) character , intent ( in ) :: trA , trB , trC complex ( 8 ), allocatable , dimension (:, :) :: tmp integer :: n , m , k , kb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trB is wrong: \" , trB call abort () end if if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in triMUL_C! Matrix dimension is wrong\" , k , kb call abort () end if call MUL_C ( A , B , trA , trB , tmp ) call MUL_C ( tmp , C , 'n' , trC , R ) deallocate ( tmp ) end subroutine triMUL_C subroutine MUL_C ( A , B , trA , trB , R ) complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ), intent ( inout ), allocatable :: R (:, :) CHARACTER , intent ( in ) :: trA , trB integer :: n , m , k , kb , lda , ldb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trB is wrong: \" , trB call abort () end if lda = size ( A , 1 ) ldb = size ( B , 1 ) if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in MUL_C! Matrix dimension is wrong\" , k , kb call abort () end if if ( allocated ( R )) then if (( size ( R , 1 ) . ne . m ) . or . ( size ( R , 2 ) . ne . n )) then deallocate ( R ) Allocate ( R ( m , n )) end if else Allocate ( R ( m , n )) end if R = dcmplx ( 0.0d0 , 0.0d0 ) call zgemm ( trA , trB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), R , m ) end subroutine MUL_C end module matrix_c","tags":"","loc":"sourcefile/matrix_c.f90.html"},{"title":"selfenergy_mod.f90 – Quantum transport simulator","text":"Contents Source Code selfenergy_mod.f90 Source Code","tags":"","loc":"sourcefile/selfenergy_mod.f90.html"}]}